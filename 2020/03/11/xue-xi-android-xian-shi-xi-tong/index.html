<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>学习android-显示系统 | Hunter</title>
  <meta name="keywords" content=" android , surfaceflinger ">
  <meta name="description" content="学习android-显示系统 | Hunter">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="document.querySelectorAll(&#39;.github-emoji&#39;)           .forEach(el &#x3D;&gt; {             if (!el.dataset.src) { return; }             const img &#x3D; document.createElement(&#39;img&#39;);             img.style">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="https://blog.changdong.ltd/about/index.html">
<meta property="og:site_name" content="Hunter">
<meta property="og:description" content="document.querySelectorAll(&#39;.github-emoji&#39;)           .forEach(el &#x3D;&gt; {             if (!el.dataset.src) { return; }             const img &#x3D; document.createElement(&#39;img&#39;);             img.style">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-03-01T07:18:22.000Z">
<meta property="article:modified_time" content="2021-04-02T01:25:22.118Z">
<meta property="article:author" content="Hunter">
<meta property="article:tag" content="ISP DSP GPU Android">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Hunter" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Hunter</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/hfutjcd"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/gernie"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:jcdhf0902@sohu.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(13)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="Android">
                        
                        Android
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Android, linux, 编译工具">
                        
                        Android, linux, 编译工具
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="hexo">
                        
                        hexo
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="linux">
                        
                        linux
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="NPU">
                        
                        NPU
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="图像处理">
                        
                        图像处理
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="待办">
                        
                        待办
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="编程">
                        
                        编程
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="编译工具">
                        
                        编译工具
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="语法测试">
                        
                        语法测试
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="13">
<input type="hidden" id="yelog_site_word_count" value="32.7k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>android</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>bat</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>bazel</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>clangd</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Dimensity 1000</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hexo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MTK</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>NPU</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>sdk</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>shell</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>surfaceflinger</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>todo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>图像处理</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>指令集</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>编程语言</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>语法测试</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="全部文章 编译工具 "
           href="/2021/03/24/clangd-an-zhuang/"
           data-tag="clangd"
           data-author="" >
            <span class="post-title" title="clangd安装">clangd安装</span>
            <span class="post-date" title="2021-03-24 00:00:00">2021/03/24</span>
        </a>
        
        <a  class="全部文章 linux "
           href="/2021/03/18/oh-my-zsh-zhong-duan/"
           data-tag="shell"
           data-author="" >
            <span class="post-title" title="oh-my-zsh终端">oh-my-zsh终端</span>
            <span class="post-date" title="2021-03-18 00:00:00">2021/03/18</span>
        </a>
        
        <a  class="全部文章 编程 "
           href="/2021/01/25/bat-jiao-ben-bu-dan-chuang-yun-xing/"
           data-tag="bat"
           data-author="" >
            <span class="post-title" title="bat脚本不弹窗执行">bat脚本不弹窗执行</span>
            <span class="post-date" title="2021-01-25 00:00:00">2021/01/25</span>
        </a>
        
        <a  class="全部文章 图像处理 "
           href="/2020/07/07/tu-xiang-chu-li-jing-dian-wang-luo/"
           data-tag="图像处理"
           data-author="" >
            <span class="post-title" title="图像处理经典网络">图像处理经典网络</span>
            <span class="post-date" title="2020-07-07 00:00:00">2020/07/07</span>
        </a>
        
        <a  class="全部文章 Android, linux, 编译工具 "
           href="/2020/06/08/ubuntu-install-android-sdk-ndk/"
           data-tag="android,sdk"
           data-author="" >
            <span class="post-title" title="ubuntu install android sdk ndk">ubuntu install android sdk ndk</span>
            <span class="post-date" title="2020-06-08 22:25:43">2020/06/08</span>
        </a>
        
        <a  class="全部文章 编译工具 "
           href="/2020/06/08/build-with-bazel/"
           data-tag="bazel"
           data-author="" >
            <span class="post-title" title="build with Bazel">build with Bazel</span>
            <span class="post-date" title="2020-06-08 00:00:00">2020/06/08</span>
        </a>
        
        <a  class="全部文章 待办 "
           href="/2020/06/08/todo/"
           data-tag="todo"
           data-author="" >
            <span class="post-title" title="todo">todo</span>
            <span class="post-date" title="2020-06-08 00:00:00">2020/06/08</span>
        </a>
        
        <a  class="全部文章 "
           href="/2020/04/13/da-jian-jupyter-notebook-yuan-cheng-fu-wu-qi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="搭建jupyter notebook 远程服务器">搭建jupyter notebook 远程服务器</span>
            <span class="post-date" title="2020-04-13 23:02:03">2020/04/13</span>
        </a>
        
        <a  class="全部文章 NPU "
           href="/2020/04/06/mtk-npu-dimensity-1000/"
           data-tag="MTK,NPU,Dimensity 1000"
           data-author="" >
            <span class="post-title" title="MTK NPU Dimensity 1000">MTK NPU Dimensity 1000</span>
            <span class="post-date" title="2020-04-06 15:00:34">2020/04/06</span>
        </a>
        
        <a  class="全部文章 linux "
           href="/2020/04/04/shi-me-shi-zhi-ling-ji/"
           data-tag="指令集,编程语言"
           data-author="" >
            <span class="post-title" title="什么是指令集">什么是指令集</span>
            <span class="post-date" title="2020-04-04 21:38:46">2020/04/04</span>
        </a>
        
        <a  class="全部文章 hexo "
           href="/2020/03/27/hexo-da-jian-de-keng/"
           data-tag="hexo"
           data-author="" >
            <span class="post-title" title="hexo 搭建的坑">hexo 搭建的坑</span>
            <span class="post-date" title="2020-03-27 20:18:31">2020/03/27</span>
        </a>
        
        <a  class="全部文章 Android "
           href="/2020/03/11/xue-xi-android-xian-shi-xi-tong/"
           data-tag="android,surfaceflinger"
           data-author="" >
            <span class="post-title" title="学习android-显示系统">学习android-显示系统</span>
            <span class="post-date" title="2020-03-11 22:25:43">2020/03/11</span>
        </a>
        
        <a  class="全部文章 语法测试 "
           href="/2020/03/01/bo-ke-ce-shi/"
           data-tag="语法测试"
           data-author="" >
            <span class="post-title" title="博客测试">博客测试</span>
            <span class="post-date" title="2020-03-01 22:25:43">2020/03/01</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-学习android-显示系统" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">学习android-显示系统</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Android">Android</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color3">android</a>
            
            <a class="color5">surfaceflinger</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2021-04-02 09:25:22'>2020-03-11 22:25</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:27.1k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#androidQ-surfaceflinger介绍"><span class="toc-text">androidQ surfaceflinger介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#综述"><span class="toc-text">综述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从下层往上层理解"><span class="toc-text">从下层往上层理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#显示屏"><span class="toc-text">显示屏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SurfaceFlinger-图形合成者"><span class="toc-text">SurfaceFlinger-图形合成者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#上层绘图"><span class="toc-text">上层绘图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VSync以及三缓冲"><span class="toc-text">VSync以及三缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Drawing-Without-VSync"><span class="toc-text">Drawing Without VSync</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Drawing-With-VSync"><span class="toc-text">Drawing With VSync</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Choreographer-VSync信号的上层接收者"><span class="toc-text">Choreographer VSync信号的上层接收者</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#parallel-processing-and-triple-buffering"><span class="toc-text">parallel processing and triple buffering</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rc文件配置"><span class="toc-text">rc文件配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#surfaceflinger对象创建"><span class="toc-text">surfaceflinger对象创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建surfaceflinger实例"><span class="toc-text">创建surfaceflinger实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SurfaceFlinger和SurfaceFlingerEx"><span class="toc-text">SurfaceFlinger和SurfaceFlingerEx</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SurfaceFlinger初始化"><span class="toc-text">SurfaceFlinger初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OnFistRef调用"><span class="toc-text">OnFistRef调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mEventQueue"><span class="toc-text">mEventQueue</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init初始化"><span class="toc-text">init初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#surfaceFlinger运行通路"><span class="toc-text">surfaceFlinger运行通路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#app-Vsync信号注册和回调"><span class="toc-text">app-Vsync信号注册和回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sf-Vsync信号注册和回调"><span class="toc-text">sf-Vsync信号注册和回调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码调用流程"><span class="toc-text">代码调用流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#流程图"><span class="toc-text">流程图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建Activity和注册surface流程"><span class="toc-text">创建Activity和注册surface流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity的启动流程"><span class="toc-text">Activity的启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一切从main-方法开始"><span class="toc-text">一切从main()方法开始</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建Application的消息是如何发送的呢？"><span class="toc-text">创建Application的消息是如何发送的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IActivityManager-mgr是个啥？"><span class="toc-text">IActivityManager mgr是个啥？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplicationThread-mAppThread又是个啥？"><span class="toc-text">ApplicationThread mAppThread又是个啥？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityManagerService调度发送初始化消息"><span class="toc-text">ActivityManagerService调度发送初始化消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#收到初始化消息之后的世界"><span class="toc-text">收到初始化消息之后的世界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instrumentation仪表，什么鬼？"><span class="toc-text">Instrumentation仪表，什么鬼？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LoadedApk就是data-info哦！"><span class="toc-text">LoadedApk就是data.info哦！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#现在把目光移回Instrumentation"><span class="toc-text">现在把目光移回Instrumentation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LaunchActivity"><span class="toc-text">LaunchActivity</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#surfaceFlinger创建surface"><span class="toc-text">surfaceFlinger创建surface</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#window添加view过程"><span class="toc-text">window添加view过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#native层创建surface"><span class="toc-text">native层创建surface</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SurfaceComposerClient的创建"><span class="toc-text">SurfaceComposerClient的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Surface的创建"><span class="toc-text">Surface的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SurfaceControl的创建"><span class="toc-text">SurfaceControl的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#IGraphicBufferProducer-gbp-的创建"><span class="toc-text">IGraphicBufferProducer(gbp)的创建</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#从SurfaceControl中获取Surface"><span class="toc-text">从SurfaceControl中获取Surface</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#app侧硬件加速绘制surface流程"><span class="toc-text">app侧硬件加速绘制surface流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-OpenGL环境的初始化"><span class="toc-text">Android OpenGL环境的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-OpenGL-GPU-渲染"><span class="toc-text">Android OpenGL GPU 渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SyncAndDrawFrame-同步"><span class="toc-text">SyncAndDrawFrame 同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Render线程issue提交OpenGL渲染命令"><span class="toc-text">Render线程issue提交OpenGL渲染命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Render线程swapBuffers提交图形缓冲区（加Fence机制）"><span class="toc-text">Render线程swapBuffers提交图形缓冲区（加Fence机制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#surfaceflinger合成surface"><span class="toc-text">surfaceflinger合成surface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SurfaceFlinger合成消息"><span class="toc-text">SurfaceFlinger合成消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handleMessageTransaction"><span class="toc-text">handleMessageTransaction()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handleMessageInvalidate"><span class="toc-text">handleMessageInvalidate()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handleMessageRefresh"><span class="toc-text">handleMessageRefresh()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#void-SurfaceFlinger-preComposition"><span class="toc-text">void SurfaceFlinger::preComposition()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-SurfaceFlinger-rebuildLayerStacks"><span class="toc-text">void SurfaceFlinger::rebuildLayerStacks()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-SurfaceFlinger-setUpHWComposer"><span class="toc-text">void SurfaceFlinger::setUpHWComposer()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-SurfaceFlinger-doComposition"><span class="toc-text">void SurfaceFlinger::doComposition()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-SurfaceFlinger-postComposition-refreshStartTime"><span class="toc-text">void SurfaceFlinger::postComposition(refreshStartTime)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HWC消息合成通路"><span class="toc-text">HWC消息合成通路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HWC接收surface"><span class="toc-text">HWC接收surface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HWC处理surface"><span class="toc-text">HWC处理surface</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-4 i,
    .toc-level-4 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="androidQ-surfaceflinger介绍"><a href="#androidQ-surfaceflinger介绍" class="headerlink" title="androidQ surfaceflinger介绍"></a>androidQ surfaceflinger介绍</h1><p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#androidQ-surfaceflinger介绍"><span class="toc-text">androidQ surfaceflinger介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#综述"><span class="toc-text">综述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从下层往上层理解"><span class="toc-text">从下层往上层理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#显示屏"><span class="toc-text">显示屏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SurfaceFlinger-图形合成者"><span class="toc-text">SurfaceFlinger-图形合成者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#上层绘图"><span class="toc-text">上层绘图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VSync以及三缓冲"><span class="toc-text">VSync以及三缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Drawing-Without-VSync"><span class="toc-text">Drawing Without VSync</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Drawing-With-VSync"><span class="toc-text">Drawing With VSync</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Choreographer-VSync信号的上层接收者"><span class="toc-text">Choreographer VSync信号的上层接收者</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#parallel-processing-and-triple-buffering"><span class="toc-text">parallel processing and triple buffering</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rc文件配置"><span class="toc-text">rc文件配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#surfaceflinger对象创建"><span class="toc-text">surfaceflinger对象创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建surfaceflinger实例"><span class="toc-text">创建surfaceflinger实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SurfaceFlinger和SurfaceFlingerEx"><span class="toc-text">SurfaceFlinger和SurfaceFlingerEx</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SurfaceFlinger初始化"><span class="toc-text">SurfaceFlinger初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OnFistRef调用"><span class="toc-text">OnFistRef调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mEventQueue"><span class="toc-text">mEventQueue</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init初始化"><span class="toc-text">init初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#surfaceFlinger运行通路"><span class="toc-text">surfaceFlinger运行通路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#app-Vsync信号注册和回调"><span class="toc-text">app-Vsync信号注册和回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sf-Vsync信号注册和回调"><span class="toc-text">sf-Vsync信号注册和回调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码调用流程"><span class="toc-text">代码调用流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#流程图"><span class="toc-text">流程图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建Activity和注册surface流程"><span class="toc-text">创建Activity和注册surface流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity的启动流程"><span class="toc-text">Activity的启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一切从main-方法开始"><span class="toc-text">一切从main()方法开始</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建Application的消息是如何发送的呢？"><span class="toc-text">创建Application的消息是如何发送的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IActivityManager-mgr是个啥？"><span class="toc-text">IActivityManager mgr是个啥？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplicationThread-mAppThread又是个啥？"><span class="toc-text">ApplicationThread mAppThread又是个啥？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityManagerService调度发送初始化消息"><span class="toc-text">ActivityManagerService调度发送初始化消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#收到初始化消息之后的世界"><span class="toc-text">收到初始化消息之后的世界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instrumentation仪表，什么鬼？"><span class="toc-text">Instrumentation仪表，什么鬼？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LoadedApk就是data-info哦！"><span class="toc-text">LoadedApk就是data.info哦！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#现在把目光移回Instrumentation"><span class="toc-text">现在把目光移回Instrumentation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LaunchActivity"><span class="toc-text">LaunchActivity</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#surfaceFlinger创建surface"><span class="toc-text">surfaceFlinger创建surface</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#window添加view过程"><span class="toc-text">window添加view过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#native层创建surface"><span class="toc-text">native层创建surface</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SurfaceComposerClient的创建"><span class="toc-text">SurfaceComposerClient的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Surface的创建"><span class="toc-text">Surface的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SurfaceControl的创建"><span class="toc-text">SurfaceControl的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#IGraphicBufferProducer-gbp-的创建"><span class="toc-text">IGraphicBufferProducer(gbp)的创建</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#从SurfaceControl中获取Surface"><span class="toc-text">从SurfaceControl中获取Surface</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#app侧硬件加速绘制surface流程"><span class="toc-text">app侧硬件加速绘制surface流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-OpenGL环境的初始化"><span class="toc-text">Android OpenGL环境的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-OpenGL-GPU-渲染"><span class="toc-text">Android OpenGL GPU 渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SyncAndDrawFrame-同步"><span class="toc-text">SyncAndDrawFrame 同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Render线程issue提交OpenGL渲染命令"><span class="toc-text">Render线程issue提交OpenGL渲染命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Render线程swapBuffers提交图形缓冲区（加Fence机制）"><span class="toc-text">Render线程swapBuffers提交图形缓冲区（加Fence机制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#surfaceflinger合成surface"><span class="toc-text">surfaceflinger合成surface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SurfaceFlinger合成消息"><span class="toc-text">SurfaceFlinger合成消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handleMessageTransaction"><span class="toc-text">handleMessageTransaction()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handleMessageInvalidate"><span class="toc-text">handleMessageInvalidate()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handleMessageRefresh"><span class="toc-text">handleMessageRefresh()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#void-SurfaceFlinger-preComposition"><span class="toc-text">void SurfaceFlinger::preComposition()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-SurfaceFlinger-rebuildLayerStacks"><span class="toc-text">void SurfaceFlinger::rebuildLayerStacks()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-SurfaceFlinger-setUpHWComposer"><span class="toc-text">void SurfaceFlinger::setUpHWComposer()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-SurfaceFlinger-doComposition"><span class="toc-text">void SurfaceFlinger::doComposition()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-SurfaceFlinger-postComposition-refreshStartTime"><span class="toc-text">void SurfaceFlinger::postComposition(refreshStartTime)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HWC消息合成通路"><span class="toc-text">HWC消息合成通路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HWC接收surface"><span class="toc-text">HWC接收surface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HWC处理surface"><span class="toc-text">HWC处理surface</span></a></li></ol></li></ol></li></ol></div></p>
<p><em>surfaceflinger是android系统的一个重要后台服务，该服务跟随系统启动，由systemservice服务启动。主要负责android的显示控制任务，本文主要介绍androidQ(android 10)系统中的surfaceflinger服务。</em></p>
<hr>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>本文讲解的内容是Android4.1以后的系统机制，将从整体上分析Android图形显示系统的结构，不深入分析每一层内部的代码实现，更多的是使用流程图和结构图来让大家理解Android是如何绘制、合成图形并显示到屏幕上。</p>
<p>本文将从三个层次进行讲解，大致如下图：</p>
<p>可以理解为上层生产，下层消费模型。</p>
<p><img src="20170423222358983.png" alt="image"></p>
<p>可以理解为上层生产，下层消费模型。</p>
<p>其中每一层之间的数据传递是使用Buffer（图形缓冲区）作为载体：<br><img src="20170423222539614.png" alt="图形数据的载体"><br>这里的缓冲区，大家可以理解为带有宽高和像素密度的内存区块。</p>
<h3 id="从下层往上层理解"><a href="#从下层往上层理解" class="headerlink" title="从下层往上层理解"></a>从下层往上层理解</h3><h4 id="显示屏"><a href="#显示屏" class="headerlink" title="显示屏"></a>显示屏</h4><p>显示屏上的内容，是从硬件帧缓冲区读取的，大致读取过程为：从Buffer的起始地址开始，从上往下，从左往右扫描整个Buffer，将内容映射到显示屏上：<br><img src="20170423220626775.png" alt="屏幕与帧缓冲区关系图1"></p>
<p>当然，屏幕上的内容需要需要不断的更新，如果在同一个Buffer进行读取和写入（合成）操作，将会导致屏幕显示多帧内容。所以硬件层除了提供一个Buffer用于屏幕显示，还提供了一个Buffer用于后台的图形合成，也就是我们常说的双缓冲：<br><img src="20170423221054667.png" alt="屏幕与帧缓冲区关系图2"></p>
<p>上图中包含两个缓冲区：<br><strong>前缓冲区：</strong>用来显示内容到屏幕的帧缓冲区<br><strong>后缓冲区：</strong>用于后台合成下一帧图形的帧缓冲区</p>
<p>假设前一帧显示完毕，后一帧准备好了，屏幕将会开始读取下一帧的内容，也就是开始读取上图中的后缓冲区的内容：<br><img src="20170423223702548.png" alt="屏幕与帧缓冲区关系图途2"></p>
<p>此时，前后缓冲区进行一次角色互换，之前的后缓冲区变为前缓冲区，进行图形的显示，之前的前缓冲区则变为后缓冲区，进行图形的合成。</p>
<p>然而，理想很丰满，现实很骨感，上面假设“当前一帧显示完毕，后一帧准备好了”的情况，在现实中这两个事件并非同时完成。那么，屏幕扫描缓冲区的速度和系统合成帧的速度之间有什么关系呢，带着这个疑惑我们看看下面两个概念：</p>
<p><strong>屏幕刷新率（HZ）：</strong>代表屏幕在一秒内刷新屏幕的次数，Android手机一般为60HZ（也就是1秒刷新60帧，大约16.67毫秒刷新1帧）</p>
<p><strong>系统帧速率（FPS）：</strong>代表了系统在一秒内合成的帧数，该值的大小由系统算法和硬件决定。</p>
<p>我们用以下两个假设来分析两者的关系：</p>
<p>① 屏幕刷新速率比系统帧速率快<br>此时，在前缓冲区内容全部映射到屏幕上之后，后缓冲区尚未准备好下一帧，屏幕将无法读取下一帧，所以只能继续显示当前一帧的图形，造成一帧显示多次，也就是卡顿。</p>
<p>② 系统帧速率比屏幕刷新率快<br>此时，屏幕未完全把前缓冲区的一帧映射到屏幕，而系统已经在后缓冲区准备好了下一帧，并要求读取下一帧到屏幕，将会导致屏幕上半部分是上一帧的图形，而下半部分是下一帧的图形，造成屏幕上显示多帧，也就是屏幕撕裂。</p>
<p>上面两种情况，都会导致问题，根本原因就是两个缓冲区的操作速率不一致，解决办法就是让屏幕控制前后缓冲区的切换，让系统帧速率配合屏幕刷新率的节奏。</p>
<p>那么屏幕是如何控制这个节奏的呢？</p>
<p><strong>垂直同步（VSync）：</strong>当屏幕从缓冲区扫描完一帧到屏幕上之后，开始扫描下一帧之前，发出的一个同步信号，该信号用来切换前缓冲区和后缓冲区。</p>
<p>通过上面的分析可以看出，屏幕的显示节奏是固定的，操作系统需要配合屏幕的显示，在固定的时间内准备好下一帧，以供屏幕进行显示。两者通过VSync信号来实现同步。</p>
<p>关于屏幕这一块的知识点讲解到这，不再深入分析，接下来我们将会了解后缓冲区的图形合成者。</p>
<h4 id="SurfaceFlinger-图形合成者"><a href="#SurfaceFlinger-图形合成者" class="headerlink" title="SurfaceFlinger-图形合成者"></a>SurfaceFlinger-图形合成者</h4><p>如果说屏幕是消费者，那么SurfaceFlinger相对屏幕来说就是生产者，其具有如下特性：</p>
<ul>
<li>作为上层应用的消费者，硬件层的生产者。</li>
<li>负责图形的合成</li>
<li>和ActivityManagerService一样，是一个系统服务</li>
</ul>
<p>为了更好的理解SurfaceFlinger这个服务的工作内容，以及他是如何做到一个承上启下的作用，我们通过下面的这个界面分析：</p>
<p><img src="20170502235504168.png" alt="这里写图片描述"></p>
<p>界面很简单，拆开来看，包含微信、悬浮工具箱、通知栏、底部虚拟按键栏：</p>
<p><img src="20170502235325462.png" alt="界面对应的surface"></p>
<p>我们可以先这样理解上面这幅图，上层每一个界面，其实都对应SufaceFlinger里的一个Surface对象，上层将自己的内容绘制在对应的Surface内，接着，SufaceFlinger需要将所有上层对应的Surface内的图形进行合成，具体看下图：<br><img src="20170503000053286.png" alt="SurfaceFlinger合成过程"></p>
<p>没错，SurfaceFlinger就是将多个Surface里的内容进行合成，最后提交到屏幕的后缓冲区，等待屏幕的下一个垂直同步信号的到来，再显示到屏幕上。</p>
<p>我们会发现SufaceFlinger通过屏幕后缓冲区与屏幕建立联系。同时通过Surface与上层建立联系。从而起到一个承上启下的作用，是Android图形系统结构中的关键组成部分。</p>
<p>为了继续往上层讲，我们需要了解什么是Surface：</p>
<ul>
<li>对应上层的一个Window（对话框、Activity、状态栏）</li>
<li>作为上层图形绘制的画板</li>
<li>Canvas是画笔，上层通过调用Canvas的API向Surface上绘制图形</li>
<li>Surface内部存在多个缓冲区，形成一个BufferQueue</li>
</ul>
<p>如果说SurfaceFinger是图形的合成者，那么图形的提供者就是上层。文章一开始就提到，图形的传递是通过Buffer作为载体，Surface是对Buffer的进一步封装，也就是说Surface内部具有多个Buffer供上层使用，如何管理这些Buffer呢？请看下面这个模型：</p>
<p><img src="20170503094309913.png" alt="image"></p>
<p>Surface内部提供一个BufferQueue，与上层和SurfaceFlinger形成一个生产者消费者模型，上层对应Producer，SurfaceFlinger对应Consumer。三者通过Buffer产生联系，每个Buffer都有四种状态：</p>
<ul>
<li>Free：可被上层使用</li>
<li>Dequeued：出列，正在被上层使用</li>
<li>Queued：入列，已完成上层绘制，等待SurfaceFlinger合成</li>
<li>Acquired：被获取，SurfaceFlinger正持有该Buffer进行合成</li>
</ul>
<p>Buffer的一次转移过程大致为：</p>
<p>从BufferQueue转移到上层</p>
<ul>
<li>上层绘制完成再放回BufferQueue</li>
<li>接着SurfaceFlinger再拿去合成</li>
<li>最后又放回BufferQueue</li>
<li>如此循环，形成一个Buffer被循环使用的过程。</li>
</ul>
<p>关于SurfaceFlinger以及SurfaceFlinger与上层建立联系的Surface讲解完了，接下来看看上层是如何将图形绘制到Surface的Buffer中。</p>
<h4 id="上层绘图"><a href="#上层绘图" class="headerlink" title="上层绘图"></a>上层绘图</h4><p>上层绘图的大体流程见下图：<br><img src="20170503095551180.jpg" alt="上层绘图"></p>
<p>之前有说到，Surface里的Buffer作为上层的画板，Canvas作为画笔，通过调用Canvas的API完成图形的绘制，上层通过调用draw方法来调用Canvas的API，当然这里的draw方法并没有真正的将图形绘制到缓冲区，而是记录了一下绘制命令，具体需要了解DisplayList相关只是，后面会对其进行分析。</p>
<p>从流程上看:</p>
<ol>
<li>测量View的宽高（Measure）</li>
<li>设置View的宽高位置（Layout）</li>
<li>创建显示列表，并执行绘制（Draw）</li>
<li>生成多边形和纹理</li>
<li>对多边形和纹理进行栅格化操作</li>
</ol>
<p>从执行者的角度看：</p>
<ol>
<li>CPU：Measure，Layout，纹理和多边形生成，发送纹理和多边形到GPU</li>
<li>GPU：将CPU生成的纹理和多边形进行栅格化以及合成</li>
</ol>
<p>上面说的的纹理和多边形还有栅格化以及合成，这里不做具体的讲解，需要了解的是图形的绘制流程需要经过这些操作。从上面的分析可以看出，上层绘制图形时需要经过CPU计算，再经过GPU计算。</p>
<p>经过上面的分析，整个Android的图形绘制大体流程已经分析完成，接下来将会分析一些流程的具体实现，分析的内容包括：</p>
<ul>
<li>Android 4.1 加入的VSync信号同步到上层以及三缓冲</li>
<li>从上层往下层具体分析每一步流程</li>
</ul>
<h4 id="VSync以及三缓冲"><a href="#VSync以及三缓冲" class="headerlink" title="VSync以及三缓冲"></a>VSync以及三缓冲</h4><h5 id="Drawing-Without-VSync"><a href="#Drawing-Without-VSync" class="headerlink" title="Drawing Without VSync"></a>Drawing Without VSync</h5><p>从上面的讲解可以看出，整个绘制流程的节奏，分成两个生产者消费者模型，一个由屏幕和SurfaceFlinger构成，另一个由SurfaceFlinger和上层应用构成，具体流程可以用下图来描述：<br><img src="20170503115001960.jpg" alt="drawing without vsync"></p>
<p>其中：</p>
<ol>
<li>CPU和GPU代表上层的绘制执行者</li>
<li>Composite代表的是SurfaceFlinger对多个Surface的合成</li>
<li>Background Buffer和Front Buffer分别代表的是硬件帧缓冲区中的前缓冲和后缓冲</li>
<li>显示屏扫描完一帧之后，会发出VSync信号来切换并显示下一帧</li>
</ol>
<p>上面的流程中，存在一个问题，屏幕的VSync信号只是用来控制帧缓冲区的切换，并未控制上层的绘制节奏，也就是说上层的生产节奏和屏幕的显示节奏是脱离的：</p>
<p><img src="20170503120335778.png" alt="drawing without vsync"></p>
<p>上图中，横轴表示时间，纵轴表示Buffer的使用者，每个长方形表示Buffer的使用，长方形的宽度代表使用时长，VSync代表垂直同步信号，两个VSync信号之间间隔16.6ms。此图描述了Android在4.1系统版本之前，上层的绘图流程在没有VSync信号的时候，出现的绘制问题。</p>
<p>我们从时间为0开始看，当前屏幕显示第0帧，上层CPU开始计算第1帧的纹理，计算完成后，交由GPU进行栅格化。当下一个垂直同步信号到来，屏幕显示下一帧，这时候，上层CPU并未马上开始准备下一帧，而当CPU开始准备下一帧的时候已经太晚了，下一个VSync信号来临的时候，GPU未能绘制完第二帧的处理，导致屏幕再次显示上一帧，造成卡顿：</p>
<p><img src="20170503141658724.png" alt="drawing without vsync"></p>
<h5 id="Drawing-With-VSync"><a href="#Drawing-With-VSync" class="headerlink" title="Drawing With VSync"></a>Drawing With VSync</h5><p>因为上层不知道VSync信号已经发出，导致上层未能开始CPU的计算。google在Android 4.1系统中加入了上层接收垂直同步信号的逻辑，大致流程如下：<br><img src="20170503142142473.png" alt="draw with vsync"></p>
<p>也就是说，屏幕在显示完一帧后，发出的垂直同步除了通知帧缓冲区的切换之外，该消息还会发送到上层，通知上层开始绘制下一帧。</p>
<p>那么，上层是如何接受这个VSync消息的呢？</p>
<h6 id="Choreographer-VSync信号的上层接收者"><a href="#Choreographer-VSync信号的上层接收者" class="headerlink" title="Choreographer VSync信号的上层接收者"></a>Choreographer VSync信号的上层接收者</h6><p>Google为上层设计了一个Choreographer类，翻译成中文是“编舞者”，是希望通过它来控制上层的绘制（舞蹈）节奏。</p>
<p>首先看看Choreographer的类图：</p>
<p><img src="20170503143059916.png" alt="img"></p>
<p>可以发现，Choreographer需要向SurfaceFlinger来注册一个VSync信号的接收器DisplayEventReceiver。同时在Choreographer的内部维护了一个CallbackQueue，用来保存上层关心VSync信号的组件，包括ViewRootImpl，TextView，ValueAnimator等。</p>
<p>再看看上层接收VSync的时序图：</p>
<p><img src="20170503143510309.png" alt="上层接收VSync时序图"></p>
<p>知道了Choreographer是上层用来接收VSync的角色之后，我们需要进一步了解VSync信号是如何控制上层的绘制的：<br><img src="20170503143848832.png" alt="上层VSync与绘制相结合的时序图"></p>
<p>一般，上层需要绘制新的UI都是因为View的requestLayout或者是invalidate方法被调用触发的，我们以这个为起点，跟踪上层View的绘制流程：</p>
<ol>
<li>requestLayout或者invalidate触发更新视图请求</li>
<li>更新请求传递到ViewRootImpl中，ViewRootImpl向主线程MessageQueue中加入一个阻塞器，该阻塞器将会拦截所有同步消息，也就是说此时，我们再通过Handler向主线程MessageQueue发送的所有Message都将无法被执行。</li>
<li>ViewRootImpl向Choreographer注册下一个VSync信号</li>
<li>Choreographer通过DisplayEventReceiver向framework层注册下一个VSync信号</li>
<li>当底层产生下一个VSync消息时，该信号将会发送给DisplayEventReceiver，最后传递给Choreographer</li>
<li>Choreographer收到VSync信号之后，向主线程MessageQueue发送了一个异步消息，我们在第二步提到，ViewRootImpl向MessageQueue发送了一个同步消息阻塞器。这里Choreographer发送的异步消息，是不会被阻塞器拦截的。</li>
<li>最后，异步消息的执行者是ViewRootImpl，也就是真正开始绘制下一帧了</li>
</ol>
<p>至此，底层的VSync控制上层的逻辑就解释完了，此时上层绘制图形的流程与VSync信号的关系可以用下图表示：<br><img src="20170503145317930.png" alt="draw with vsync"></p>
<p>时间从屏幕显示第0帧开始，CPU开始准备第1帧图形的处理，好了之后交给GPU进行处理，在上层收到下一个VSync之后，CPU立马开始第2帧的处理，上层绘图的节奏就和VSync信号保持一致了，整个绘图非常流畅。</p>
<p>然而，理想很丰满，现实很骨感，如果CPU和GPU没能在下一个VSync信号到来之前完成下一帧的绘制工作，又会是怎么样的呢？<br><img src="20170503150149613.png" alt="parallel processing and double buffering"></p>
<p>还是从屏幕显示第A帧开始，时间进入第一个16.6ms，CPU和GPU合成第B帧，当下一个VSync信号到来的时候，GPU未能及时完成第B帧的绘制，此时，GPU占有一个Surface里的Buffer，而同时SurfaceFlinger又持有一个Buffer用于合成显示下一帧到屏幕，这样的话，就导致Surface里的两个缓冲区都被占用了。此时SurfaceFlinger只能使用第A帧已经准备好的Buffer来合成，GPU继续在另一个缓冲区中合成第B帧，此时CPU无法开始下一帧的合成，因为缓冲区用完了。另外一个不好的事情是CPU只有在VSync信号来的时候才开始绘制下一帧，也是就是说在第二个16.6ms时间内，CPU一直处于空闲状态，未进行下一帧的计算。<br>只有等到第二个VSync信号来了之后，CPU才开始在绘制下一帧。如果CPU和GPU需要合成的图形太多，将会导致连续性的卡顿，如果CPU和GPU大部分时候都无法在16.6ms完成一帧的绘制，将会导致连续的卡顿现象。</p>
<p>别着急，请看看Google的决绝方案。</p>
<h5 id="parallel-processing-and-triple-buffering"><a href="#parallel-processing-and-triple-buffering" class="headerlink" title="parallel processing and triple buffering"></a>parallel processing and triple buffering</h5><p>没错，就是加入第三个Buffer，CPU和GPU还有SurfaceFlinger各占一个Buffer，并行处理图形：<br><img src="20170503153350970.png" alt="parallel processing and triple buffering"></p>
<p>从上图可以看出，在第一个VSync到来时，尽管SurfaceFlinger占了一个Buffer，GPU又占了一个Buffer，CPU仍然可以在第三个Buffer中开始下一帧的计算，整个显示过程就开始时卡顿了一帧，之后都是流畅的。</p>
<p>当然系统并非一直开启三个Buffer，因为Buffer是需要消耗资源的，并且，我们会发现，上图中，GPU处理好的图形，需要跨越两个VSync信号，才能显示。这样的话，给用户的影响是一个延迟的现象。</p>
<p>为了解决该问题，我们需要再次从上层往下层了解Android绘制图形的各个细节，并进行优化。对于应用程序开发人员来说，重点还是上层的优化，对自己的应用程序的内存，UI，数据等进行优化。</p>
<p>总结：</p>
<ul>
<li>Android通过Buffer来保存图形信息，为了让图形显示的更加流程，在提供一一个Buffer用于显示的同时，开辟一个或者多个Buffer用于后台图形的合成。</li>
<li>Android4.1之前，VSync信号并未传递给上层，导致生产与消费节奏不统一</li>
<li>Android4.1之后，上层开始绘制时机都放到了VSync信号的到来时候</li>
<li>除了在上层引入VSync机制，Anroid在4.1还加入了三缓冲，用来减少卡顿的产生</li>
<li>每个Surface都有自己的绘制流程，需要先经过CPU处理，再经过GPU处理，之后经过SurfaceFlinger与其他Surface绘制好的图形和合成在一起，供屏幕显示</li>
<li>VSync信号贯穿整个绘制流程，控制着整个Android图形系统的节奏</li>
</ul>
<p><em>综述转自:<a href="https://blog.csdn.net/a740169405/article/details/70548443" target="_blank" rel="noopener">Android图形显示系统</a></em></p>
<p>##启动surfaceflinger</p>
<h3 id="rc文件配置"><a href="#rc文件配置" class="headerlink" title="rc文件配置"></a>rc文件配置</h3><p>surfaceflinger启动是在系统开机时，由系统systemservice负责启动，启动相关的控制在surfaceflinger.rc中*[rc语法](init.rc 语法与解析)*。</p>
<pre class=" language-c"><code class="language-c">service surfaceflinger <span class="token operator">/</span>system<span class="token operator">/</span>bin<span class="token operator">/</span>surfaceflinger <span class="token comment" spellcheck="true">//服务启动的命令</span>
    class core animation <span class="token comment" spellcheck="true">//服务指定的class名，同一个class 的所有服务必须同时启动或者停止。</span>
    user system <span class="token comment" spellcheck="true">//在启动服务前将用户切换至&lt;system>,默认情况下用户都是root。</span>
    group graphics drmrpc readproc <span class="token comment" spellcheck="true">//在启动服务前将用户组切换至&lt;groupname></span>
    onrestart restart zygote <span class="token comment" spellcheck="true">//当次服务重启时，执行某些命令</span>
    writepid <span class="token operator">/</span>dev<span class="token operator">/</span>stune<span class="token operator">/</span>foreground<span class="token operator">/</span>tasks <span class="token comment" spellcheck="true">//当fork一个子进程时，写子进程的pid到一个给定的文件。是给cgroup/cpuset使用</span>
    <span class="token comment" spellcheck="true">//创建一个名为pdx/system/vr/display/&lt;name>的 socket，然后将它的fd值传给启动它的进，有效的&lt;type>值包括dgram,stream 和seqpacket。ueser 和group 的默认值为0</span>
    socket pdx<span class="token operator">/</span>system<span class="token operator">/</span>vr<span class="token operator">/</span>display<span class="token operator">/</span>client     stream <span class="token number">0666</span> system graphics u<span class="token punctuation">:</span>object_r<span class="token punctuation">:</span>pdx_display_client_endpoint_socket<span class="token punctuation">:</span>s0
    socket pdx<span class="token operator">/</span>system<span class="token operator">/</span>vr<span class="token operator">/</span>display<span class="token operator">/</span>manager    stream <span class="token number">0666</span> system graphics u<span class="token punctuation">:</span>object_r<span class="token punctuation">:</span>pdx_display_manager_endpoint_socket<span class="token punctuation">:</span>s0
    socket pdx<span class="token operator">/</span>system<span class="token operator">/</span>vr<span class="token operator">/</span>display<span class="token operator">/</span>vsync      stream <span class="token number">0666</span> system graphics u<span class="token punctuation">:</span>object_r<span class="token punctuation">:</span>pdx_display_vsync_endpoint_socket<span class="token punctuation">:</span>s0
    critical <span class="token comment" spellcheck="true">//是否关键，也就是4分钟之内重启超过4次的话，重启之后就进入recovery模式</span></code></pre>
<h3 id="surfaceflinger对象创建"><a href="#surfaceflinger对象创建" class="headerlink" title="surfaceflinger对象创建"></a>surfaceflinger对象创建</h3><p>surfaceflinger启动服务的入口函数是main_surfaceflinger.cpp的main函数</p>
<p>[-&gt;main_surfaceflinger.cpp]</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGPIPE<span class="token punctuation">,</span> SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span>

    hardware<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">configureRpcThreadpool</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token comment" spellcheck="true">/* maxThreads */</span><span class="token punctuation">,</span>
            false <span class="token comment" spellcheck="true">/* callerWillJoin */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">startGraphicsAllocatorService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// When SF is launched in its own process, limit the number of</span>
    <span class="token comment" spellcheck="true">// binder threads to 4.设置该线程可以绑定的binder线程数（binder用于通信）</span>
    ProcessState<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">setThreadPoolMaxThreadCount</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// start the thread pool 启动线程池</span>
    sp<span class="token operator">&lt;</span>ProcessState<span class="token operator">></span> <span class="token function">ps</span><span class="token punctuation">(</span>ProcessState<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ps<span class="token operator">-></span><span class="token function">startThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// instantiate surfaceflinger 实例化surfacefinger线程</span>
    sp<span class="token operator">&lt;</span>SurfaceFlinger<span class="token operator">></span> flinger <span class="token operator">=</span> surfaceflinger<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">createSurfaceFlinger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//设置线程优先级</span>
    <span class="token function">setpriority</span><span class="token punctuation">(</span>PRIO_PROCESS<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> PRIORITY_URGENT_DISPLAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//设置调度策略</span>
    <span class="token function">set_sched_policy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SP_FOREGROUND<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Put most SurfaceFlinger threads in the system-background cpuset</span>
    <span class="token comment" spellcheck="true">// Keeps us from unnecessarily using big cores</span>
    <span class="token comment" spellcheck="true">// Do this after the binder thread pool init 设置cpu后台运行策略，避免使用大核</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cpusets_enabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">setCpusetPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// initialize before clients can connect</span>
    flinger<span class="token operator">-></span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// publish surface flinger 添加surfaceflinger服务到服务管理单元</span>
    sp<span class="token operator">&lt;</span>IServiceManager<span class="token operator">></span> <span class="token function">sm</span><span class="token punctuation">(</span><span class="token function">defaultServiceManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sm<span class="token operator">-></span><span class="token function">addService</span><span class="token punctuation">(</span><span class="token function">String16</span><span class="token punctuation">(</span>SurfaceFlinger<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getServiceName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> flinger<span class="token punctuation">,</span> false<span class="token punctuation">,</span>
                   IServiceManager<span class="token punctuation">:</span><span class="token punctuation">:</span>DUMP_FLAG_PRIORITY_CRITICAL <span class="token operator">|</span> IServiceManager<span class="token punctuation">:</span><span class="token punctuation">:</span>DUMP_FLAG_PROTO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//启动显示服务</span>
    <span class="token function">startDisplayService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// dependency on SF getting registered above</span>

    <span class="token keyword">struct</span> sched_param param <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    param<span class="token punctuation">.</span>sched_priority <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sched_setscheduler</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SCHED_FIFO<span class="token punctuation">,</span> <span class="token operator">&amp;</span>param<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">ALOGE</span><span class="token punctuation">(</span><span class="token string">"Couldn't set SCHED_FIFO"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// run surface flinger in this thread</span>
    flinger<span class="token operator">-></span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>main函数主要工作;</p>
<ol>
<li>启动内存管理相关服务。</li>
<li>设置surfaceflinger的binder线程池大小，启动binder线程池。</li>
<li>创建surfaceflinger实例，设置调度策略和优先级。</li>
<li>调用surfaceflinger的init函数初始化实例。</li>
<li>添加surfaceflinger服务到系统服务管理模块。</li>
<li>启动显示服务。</li>
<li>运行surfaceflinger服务。</li>
</ol>
<p>binder线程是用于线程间通信的class，相关文档可以<a href="https://blog.csdn.net/llping2011/article/details/9706679" target="_blank" rel="noopener">参考此文档</a>;由于本文重点介绍surfaceflinger模块，所以接下来主要介绍一下创建surfaceflinger实例。</p>
<h4 id="创建surfaceflinger实例"><a href="#创建surfaceflinger实例" class="headerlink" title="创建surfaceflinger实例"></a>创建surfaceflinger实例</h4><p>surfaceflinger实例通过<strong>surfaceflinger::createSurfaceFlinger()</strong>函数创建，该函数位于SurfaceFlingerFactory.cpp中，定义如下</p>
<pre class=" language-c++"><code class="language-c++">namespace android::surfaceflinger {

sp<SurfaceFlinger> createSurfaceFlinger() {
    class Factory final : public surfaceflinger::Factory {
    public:
        Factory() = default;
        ~Factory() = default;

        std::unique_ptr<DispSync> createDispSync(const char* name, bool hasSyncFramework,
                                                 int64_t dispSyncPresentTimeOffset) override {
            // Note: We create a local temporary with the real DispSync implementation
            // type temporarily so we can initialize it with the configured values,
            // before storing it for more generic use using the interface type.
            auto primaryDispSync = std::make_unique<android::impl::DispSync>(name);
            primaryDispSync->init(hasSyncFramework, dispSyncPresentTimeOffset);
            return primaryDispSync;
        }

        std::unique_ptr<EventControlThread> createEventControlThread(
                std::function<void(bool)> setVSyncEnabled) override {
            return std::make_unique<android::impl::EventControlThread>(setVSyncEnabled);
        }

        std::unique_ptr<HWComposer> createHWComposer(const std::string& serviceName) override {
            return std::make_unique<android::impl::HWComposer>(
                    std::make_unique<Hwc2::impl::Composer>(serviceName));
        }

        std::unique_ptr<MessageQueue> createMessageQueue() override {
            return std::make_unique<android::impl::MessageQueue>();
        }

        std::unique_ptr<scheduler::PhaseOffsets> createPhaseOffsets() override {
            return std::make_unique<scheduler::impl::PhaseOffsets>();
        }

        std::unique_ptr<Scheduler> createScheduler(
                std::function<void(bool)> callback,
                const scheduler::RefreshRateConfigs& refreshRateConfig) override {
            return std::make_unique<Scheduler>(callback, refreshRateConfig);
        }

        std::unique_ptr<SurfaceInterceptor> createSurfaceInterceptor(
                SurfaceFlinger* flinger) override {
            return std::make_unique<android::impl::SurfaceInterceptor>(flinger);
        }

        sp<StartPropertySetThread> createStartPropertySetThread(
                bool timestampPropertyValue) override {
            return new StartPropertySetThread(timestampPropertyValue);
        }

        sp<DisplayDevice> createDisplayDevice(DisplayDeviceCreationArgs&& creationArgs) override {
            return new DisplayDevice(std::move(creationArgs));
        }

        sp<GraphicBuffer> createGraphicBuffer(uint32_t width, uint32_t height, PixelFormat format,
                                              uint32_t layerCount, uint64_t usage,
                                              std::string requestorName) override {
            return new GraphicBuffer(width, height, format, layerCount, usage, requestorName);
        }

        void createBufferQueue(sp<IGraphicBufferProducer>* outProducer,
                               sp<IGraphicBufferConsumer>* outConsumer,
                               bool consumerIsSurfaceFlinger) override {
            BufferQueue::createBufferQueue(outProducer, outConsumer, consumerIsSurfaceFlinger);
        }

        std::unique_ptr<surfaceflinger::NativeWindowSurface> createNativeWindowSurface(
                const sp<IGraphicBufferProducer>& producer) override {
            return surfaceflinger::impl::createNativeWindowSurface(producer);
        }

        std::unique_ptr<compositionengine::CompositionEngine> createCompositionEngine() override {
            return compositionengine::impl::createCompositionEngine();
        }

        sp<ContainerLayer> createContainerLayer(const LayerCreationArgs& args) override {
            return new ContainerLayer(args);
        }

        sp<BufferQueueLayer> createBufferQueueLayer(const LayerCreationArgs& args) override {
            return new BufferQueueLayer(args);
        }

        sp<BufferStateLayer> createBufferStateLayer(const LayerCreationArgs& args) override {
            return new BufferStateLayer(args);
        }

        sp<ColorLayer> createColorLayer(const LayerCreationArgs& args) override {
            return new ColorLayer(args);
        }

        std::shared_ptr<TimeStats> createTimeStats() override {
            return std::make_shared<android::impl::TimeStats>();
        }
    };
    static Factory factory;

    return new SurfaceFlingerEx(factory);
}

} </code></pre>
<p>createSurfaceFlinger函数<strong>首先</strong>定义了Factory类，该类派生于surfaceflinger::Factory,实现了父类定义的所有虚函数。通过函数名可以知道，该类主要用于创建surfaceflinger中的类成员变量的实例。<strong>接着</strong>定义一个Factory实例，最后返回一个通过Factory实例创建的SurfaceFlingerEx对象。</p>
<h4 id="SurfaceFlinger和SurfaceFlingerEx"><a href="#SurfaceFlinger和SurfaceFlingerEx" class="headerlink" title="SurfaceFlinger和SurfaceFlingerEx"></a>SurfaceFlinger和SurfaceFlingerEx</h4><p>surfaceFlingerEx类是surfaceFlinger的之类，这个是由各个厂家自己定义的，除了继承SurfaceFlinger类的方法外，还根据各个厂家的产品自己增加了一些扩展。我司SurfaceFlingerEx的定义请自行于源码中搜索<a href="./vendor/huawei/Emui/frameworks/hwCommInterface/include/SurfaceFlingerEx.h">SurfaceFlingerEx.h</a>和<a href="./vendor/huawei/Emui/frameworks/native/services/surfaceflinger/SurfaceFlingerEx.cpp">SurfaceFlingerEx.cpp</a>查看。我们只看surfaceFlinger类。</p>
<p>[-&gt;surfaceflinger.cpp]</p>
<pre class=" language-C++"><code class="language-C++">SurfaceFlinger::SurfaceFlinger(Factory& factory, SkipInitializationTag)
      : mFactory(factory),
        mPhaseOffsets(mFactory.createPhaseOffsets()),
        mInterceptor(mFactory.createSurfaceInterceptor(this)),
        mTimeStats(mFactory.createTimeStats()),
        mEventQueue(mFactory.createMessageQueue()),
        skipScrnRecDelay(false),
        skipScreenRecord(0),
        mShotSkipVAssistLayer(0),
        mKnuckleScreenShot(0),
        mRogWidth(0),
        mRogHeight(0),
        mRogFeature(0),
        mIsSdrSupported(false),
        mPrimaryConfigSize(0),
        mLastSDRComposeWidth(0),
        mLastSDRComposeHeight(0),
        mCompositionEngine(mFactory.createCompositionEngine()),
        // hisi Xsync and PreComposite opt
        mSuppressTouchSync(false),
        mTouchSyncOn(false),
        mLargeLayerCount(0),
        mIsTouchMode(false),
        mVsyncEnabled(false),
        mDownAppSfOffsetWorkFlag(false),
        mFrameRateOptSwitch(false) {
    mItouchToSurfaceflingerInfo.firstFrameOpt = false;
    mItouchToSurfaceflingerInfo.backPressureOpt = false;
    mItouchToSurfaceflingerInfo.backPressureCount = BACKPRESSURE_INIT_COUNT;
    mItouchToSurfaceflingerInfo.backPressureCountMax = BACKPRESSURE_COUNT_MAX;
}

SurfaceFlinger::SurfaceFlinger(Factory& factory) : SurfaceFlinger(factory, SkipInitialization) {
    ALOGI("SurfaceFlinger is starting");

    hasSyncFramework = running_without_sync_framework(true);

    dispSyncPresentTimeOffset = present_time_offset_from_vsync_ns(0);

    useHwcForRgbToYuv = force_hwc_copy_for_virtual_displays(false);

    maxVirtualDisplaySize = max_virtual_display_dimension(0);

    // Vr flinger is only enabled on Daydream ready devices.
    useVrFlinger = use_vr_flinger(false);

    maxFrameBufferAcquiredBuffers = max_frame_buffer_acquired_buffers(2);

    hasWideColorDisplay = has_wide_color_display(false);

    useColorManagement = use_color_management(false);

    mDefaultCompositionDataspace =
            static_cast<ui::Dataspace>(default_composition_dataspace(Dataspace::V0_SRGB));
    mWideColorGamutCompositionDataspace = static_cast<ui::Dataspace>(wcg_composition_dataspace(
            hasWideColorDisplay ? Dataspace::DISPLAY_P3 : Dataspace::V0_SRGB));
    defaultCompositionDataspace = mDefaultCompositionDataspace;
    wideColorGamutCompositionDataspace = mWideColorGamutCompositionDataspace;
    defaultCompositionPixelFormat = static_cast<ui::PixelFormat>(
            default_composition_pixel_format(ui::PixelFormat::RGBA_8888));
    wideColorGamutCompositionPixelFormat =
            static_cast<ui::PixelFormat>(wcg_composition_pixel_format(ui::PixelFormat::RGBA_8888));

    useContextPriority = use_context_priority(true);

    auto tmpPrimaryDisplayOrientation = primary_display_orientation(
            SurfaceFlingerProperties::primary_display_orientation_values::ORIENTATION_0);
    switch (tmpPrimaryDisplayOrientation) {
        case SurfaceFlingerProperties::primary_display_orientation_values::ORIENTATION_90:
            SurfaceFlinger::primaryDisplayOrientation = DisplayState::eOrientation90;
            break;
        case SurfaceFlingerProperties::primary_display_orientation_values::ORIENTATION_180:
            SurfaceFlinger::primaryDisplayOrientation = DisplayState::eOrientation180;
            break;
        case SurfaceFlingerProperties::primary_display_orientation_values::ORIENTATION_270:
            SurfaceFlinger::primaryDisplayOrientation = DisplayState::eOrientation270;
            break;
        default:
            SurfaceFlinger::primaryDisplayOrientation = DisplayState::eOrientationDefault;
            break;
    }
    ALOGV("Primary Display Orientation is set to %2d.", SurfaceFlinger::primaryDisplayOrientation);

    mInternalDisplayPrimaries = sysprop::getDisplayNativePrimaries();

    // debugging stuff...
    char value[PROPERTY_VALUE_MAX];

    property_get("ro.bq.gpu_to_cpu_unsupported", value, "0");
    mGpuToCpuSupported = !atoi(value);

    property_get("debug.sf.showupdates", value, "0");
    mDebugRegion = atoi(value);

    ALOGI_IF(mDebugRegion, "showupdates enabled");

    // DDMS debugging deprecated (b/120782499)
    property_get("debug.sf.ddms", value, "0");
    int debugDdms = atoi(value);
    ALOGI_IF(debugDdms, "DDMS debugging not supported");

    property_get("debug.sf.disable_backpressure", value, "0");
    mPropagateBackpressure = !atoi(value);
    ALOGI_IF(!mPropagateBackpressure, "Disabling backpressure propagation");

    property_get("debug.sf.enable_gl_backpressure", value, "0");
    mPropagateBackpressureClientComposition = atoi(value);
    ALOGI_IF(mPropagateBackpressureClientComposition,
             "Enabling backpressure propagation for Client Composition");

    property_get("debug.sf.enable_hwc_vds", value, "0");
    mUseHwcVirtualDisplays = atoi(value);
    ALOGI_IF(mUseHwcVirtualDisplays, "Enabling HWC virtual displays");

    property_get("ro.sf.disable_triple_buffer", value, "0");
    mLayerTripleBufferingDisabled = atoi(value);
    ALOGI_IF(mLayerTripleBufferingDisabled, "Disabling Triple Buffering");

    property_get("debug.sf.partialCompose", value, "1");
    mUsePartialCompose = atoi(value);
    ALOGI_IF(!mUsePartialCompose, "Disable partial compose");

    const size_t defaultListSize = MAX_LAYERS;
    auto listSize = property_get_int32("debug.sf.max_igbp_list_size", int32_t(defaultListSize));
    mMaxGraphicBufferProducerListSize = (listSize > 0) ? size_t(listSize) : defaultListSize;

    mUseSmart90ForVideo = use_smart_90_for_video(false);
    property_get("debug.sf.use_smart_90_for_video", value, "0");

    int int_value = atoi(value);
    if (int_value) {
        mUseSmart90ForVideo = true;
    }

    property_get("debug.sf.luma_sampling", value, "1");
    mLumaSampling = atoi(value);

    const auto [early, gl, late] = mPhaseOffsets->getCurrentOffsets();
    mVsyncModulator.setPhaseOffsets(early, gl, late);

    // We should be reading 'persist.sys.sf.color_saturation' here
    // but since /data may be encrypted, we need to wait until after vold
    // comes online to attempt to read the property. The property is
    // instead read after the boot animation
    // hisi Xsync and PreComposite opt
    property_get("persist.kirin.touch_vsync_opt", value, "0");
    mTouchVsyncOpt = atoi(value);
    ALOGI_IF(mTouchVsyncOpt, "Touch Vsync opt enabled");

    if (useTrebleTestingOverride()) {
        // Without the override SurfaceFlinger cannot connect to HIDL
        // services that are not listed in the manifests.  Considered
        // deriving the setting from the set service name, but it
        // would be brittle if the name that's not 'default' is used
        // for production purposes later on.
        setenv("TREBLE_TESTING_OVERRIDE", "true", true);
    }

    GameExLayer::CreateWorkerThread();
    xcollie_init();
}</code></pre>
<p>通过构造函数SurfaceFlinger(Factory&amp; factory)创建对象，该构造函数先通过SurfaceFlinger(Factory&amp; factory, SkipInitializationTag)初始化部分成员变量，然后自己再配置SurfaceFlinger的相关属性参数。其中比较重要的是通过factory对象初始化的变量，如下</p>
<blockquote>
<p>mFactory(factory)<br>mPhaseOffsets(mFactory.createPhaseOffsets())<br>mInterceptor(mFactory.createSurfaceInterceptor(this))<br>mTimeStats(mFactory.createTimeStats())<br>mEventQueue(mFactory.createMessageQueue())<br>mCompositionEngine(mFactory.createCompositionEngine())</p>
</blockquote>
<h3 id="SurfaceFlinger初始化"><a href="#SurfaceFlinger初始化" class="headerlink" title="SurfaceFlinger初始化"></a>SurfaceFlinger初始化</h3><h4 id="OnFistRef调用"><a href="#OnFistRef调用" class="headerlink" title="OnFistRef调用"></a>OnFistRef调用</h4><p>在main_SurfaceFlinger.cpp文件的main函数中可以看到，实例初始化代码是<strong>sp<surfaceflinger> flinger = surfaceflinger::createSurfaceFlinger()</surfaceflinger></strong>，这里使用的是sp强引用，根据C++11的新特性可知，在使用强引用时，会自动调用对象的OnFistRef函数。SurfaceFlinger类重定义了OnFistRef函数如下：</p>
<pre class=" language-c++"><code class="language-c++">void SurfaceFlinger::onFirstRef()
{
    mEventQueue->init(this);
}</code></pre>
<p>onFirstRef函数主要是初始化了mEventQueue，mEventQueue主要作用是线程间发送接收消息。</p>
<p>因为mEnentQueue是通过mFactory创建的，而mFactory对应的类是在createSurfaceFlinger函数中定义的，所以mFactory相关的操作都可以到createSurfaceFlinger中去找，此处从createMessageQueue()函数可知mEventQueue是android::impl::MessageQueue()类的实例。</p>
<h5 id="mEventQueue"><a href="#mEventQueue" class="headerlink" title="mEventQueue"></a>mEventQueue</h5><p>mEventQueue-&gt;init(this)中this及surfaceFlinger对象本身，mEventQueue-&gt;init(this)代码如下：</p>
<p>[-&gt;MessageQueue.cpp]</p>
<pre class=" language-c++"><code class="language-c++">void MessageQueue::init(const sp<SurfaceFlinger>& flinger) {
    mFlinger = flinger;
    mLooper = new Looper(true);
    mHandler = new Handler(*this);
}</code></pre>
<p>init函数保存了surfaceFlinger对象，同时创建了一个looper对象和一个Handler对象。</p>
<p>looper是android的looper类，可以<a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">参考此文档</a>。</p>
<p>Handler继承与MeeeageHandler类，声明和定义如下：</p>
<p>[-&gt;MEssageQueue.h]</p>
<pre class=" language-c++"><code class="language-c++">class MessageQueue final : public android::MessageQueue {
    class Handler : public MessageHandler {
        enum { eventMaskInvalidate = 0x1, eventMaskRefresh = 0x2, eventMaskTransaction = 0x4 };
        MessageQueue& mQueue;
        int32_t mEventMask;

    public:
        explicit Handler(MessageQueue& queue) : mQueue(queue), mEventMask(0) {}
        virtual void handleMessage(const Message& message);
        void dispatchRefresh();
        void dispatchInvalidate();
    };</code></pre>
<p>[-&gt;MessageQueue.cpp]</p>
<pre class=" language-c++"><code class="language-c++">void MessageQueue::Handler::dispatchRefresh() {
    if ((android_atomic_or(eventMaskRefresh, &mEventMask) & eventMaskRefresh) == 0) {
        mQueue.mLooper->sendMessage(this, Message(MessageQueue::REFRESH));
    }
}

void MessageQueue::Handler::dispatchInvalidate() {
    if ((android_atomic_or(eventMaskInvalidate, &mEventMask) & eventMaskInvalidate) == 0) {
        mQueue.mLooper->sendMessage(this, Message(MessageQueue::INVALIDATE));
    }
}

void MessageQueue::Handler::handleMessage(const Message& message) {
    switch (message.what) {
        case INVALIDATE:
            android_atomic_and(~eventMaskInvalidate, &mEventMask);
            mQueue.mFlinger->onMessageReceived(message.what);
            break;
        case REFRESH:
            android_atomic_and(~eventMaskRefresh, &mEventMask);
            mQueue.mFlinger->onMessageReceived(message.what);
            break;
    }
}</code></pre>
<p>可以看到，mHandle主要用于处理message，对象保存了mEventQueue和msurfaceFlinger对象。</p>
<p>mEventQueue中mFlinger，mlooper，mhandler之间关系如下：</p>
<pre class="mermaid">graph LR
A[mhandle]--&gt;|dispatchInvalidate|B[mloop.sendMessage]
A--&gt;|dispatchRefresh|B
A--&gt;|handleMessage|C[mFlinger.onMessageReceived]</pre>

<p>简单描述上述关系是：mEventQueue是SurfaceFlinger的消息管理队列，SurfaceFlinger通过mEventQueue管理消息，mEventQueue又通过mhandle处理消息，其中mhandle通过mlooper发送消息，通过回调SurfaceFlinger的OnMessageReceived函数处理消息。</p>
<p><em>从MessageQueue的代码看，SurfaceFlinger只是通过MessageQueue的looper发送消息，并没用mHandle的handleMessage处理消息，也就是说SurfaceFlinger的OnMessageReceived函数并没有被MessageQueue的mHandle变量调用，那么被谁调用了呢？其实，handleMessage是被looper自动调用的，handler线程被注册到looper线程，loop线程自动调用handler.handleMessage</em></p>
<pre class="mermaid">graph TB
MessageQueue--&gt;|Refresh|mHandler.dispatchRefresh
mHandler.dispatchRefresh--&gt;|Refresh|mLooper.sendMessage
mLooper.sendMessage--&gt;|Refresh|handler.handleMessage
handler.handleMessage--&gt;|Refresh|sflinger.OnMessageReceived
dispVsync--&gt;|gui::bitupe|mLooper
mLooper--&gt;|callback|MessageQueue::cb_eventReceiver
MessageQueue::cb_eventReceiver--&gt;MessageQueue::eventReceiver
MessageQueue::eventReceiver--&gt;Handler::dispatchInvalidate
Handler::dispatchInvalidate--&gt;|Invalided|mLooper.sendMessage
mLooper.sendMessage--&gt;|Invalided|handler.handleMessage
handler.handleMessage--&gt;|Invalided|sflinger.OnMessageReceived
sflinger.OnMessageReceived--&gt;|Invalided_To_Refresh|MessageQueue</pre>



<h4 id="init初始化"><a href="#init初始化" class="headerlink" title="init初始化"></a>init初始化</h4><p>surfaceFlinger的init代码如下：</p>
<p>[-&gt;surfaceFlinger.cpp]</p>
<pre class=" language-c++"><code class="language-c++">void SurfaceFlinger::init() {
    ALOGI(  "SurfaceFlinger's main thread ready to run. "
            "Initializing graphics H/W...");

    ALOGI("Phase offset NS: %" PRId64 "", mPhaseOffsets->getCurrentAppOffset());

    Mutex::Autolock _l(mStateLock);
    // start the EventThread
    mScheduler =
            getFactory().createScheduler([this](bool enabled) { setPrimaryVsyncEnabled(enabled); },
                                         mRefreshRateConfigs);
    auto resyncCallback =
            mScheduler->makeResyncCallback(std::bind(&SurfaceFlinger::getVsyncPeriod, this));

    mAppConnectionHandle =
            mScheduler->createConnection("app", mPhaseOffsets->getCurrentAppOffset(),
                                         resyncCallback,
                                         impl::EventThread::InterceptVSyncsCallback());
    mSfConnectionHandle = mScheduler->createConnection("sf", mPhaseOffsets->getCurrentSfOffset(),
                                                       resyncCallback, [this](nsecs_t timestamp) {
                                                           mInterceptor->saveVSyncEvent(timestamp);
                                                       });
    //把sf时钟的回调数据与mEventQueue的looper线程联系在一起
    mEventQueue->setEventConnection(mScheduler->getEventConnection(mSfConnectionHandle));
    mVsyncModulator.setSchedulerAndHandles(mScheduler.get(), mAppConnectionHandle.get(),
                                           mSfConnectionHandle.get());

    mRegionSamplingThread =
            new RegionSamplingThread(*this, *mScheduler,
                                     RegionSamplingThread::EnvironmentTimingTunables());

    // Get a RenderEngine for the given display / config (can't fail)
    int32_t renderEngineFeature = 0;
    renderEngineFeature |= (useColorManagement ?
                            renderengine::RenderEngine::USE_COLOR_MANAGEMENT : 0);
    renderEngineFeature |= (useContextPriority ?
                            renderengine::RenderEngine::USE_HIGH_PRIORITY_CONTEXT : 0);
    renderEngineFeature |=
            (enable_protected_contents(false) ? renderengine::RenderEngine::ENABLE_PROTECTED_CONTEXT
                                              : 0);

    // TODO(b/77156734): We need to stop casting and use HAL types when possible.
    // Sending maxFrameBufferAcquiredBuffers as the cache size is tightly tuned to single-display.
    mCompositionEngine->setRenderEngine(
            renderengine::RenderEngine::create(static_cast<int32_t>(defaultCompositionPixelFormat),
                                               renderEngineFeature,
                                               maxFrameBufferAcquiredBuffers + mPartialComposeCacheSize));

    LOG_ALWAYS_FATAL_IF(mVrFlingerRequestsDisplay,
            "Starting with vr flinger active is not currently supported.");
    //通过HWC::impl:Composer创建android::impl::Composer实例
    mCompositionEngine->setHwComposer(getFactory().createHWComposer(getBE().mHwcServiceName));
    //向HWC::impl::Composer注册三个回调函数。
    mCompositionEngine->getHwComposer().registerCallback(this, getBE().mComposerSequenceId);
    // Process any initial hotplug and resulting display changes.
    //处理初始化时的热插拔消息。
    processDisplayHotplugEventsLocked();
    //获取显示设备的ID
    const auto display = getDefaultDisplayDeviceLocked();
    LOG_ALWAYS_FATAL_IF(!display, "Missing internal display after registering composer callback.");
    LOG_ALWAYS_FATAL_IF(!getHwComposer().isConnected(*display->getId()),
                        "Internal display is disconnected.");

    if (useVrFlinger) {
        auto vrFlingerRequestDisplayCallback = [this](bool requestDisplay) {
            // This callback is called from the vr flinger dispatch thread. We
            // need to call signalTransaction(), which requires holding
            // mStateLock when we're not on the main thread. Acquiring
            // mStateLock from the vr flinger dispatch thread might trigger a
            // deadlock in surface flinger (see b/66916578), so post a message
            // to be handled on the main thread instead.
            postMessageAsync(new LambdaMessage([=] {
                ALOGI("VR request display mode: requestDisplay=%d", requestDisplay);
                mVrFlingerRequestsDisplay = requestDisplay;
                signalTransaction();
            }));
        };
        mVrFlinger = dvr::VrFlinger::Create(getHwComposer().getComposer(),
                                            getHwComposer()
                                                    .fromPhysicalDisplayId(*display->getId())
                                                    .value_or(0),
                                            vrFlingerRequestDisplayCallback);
        if (!mVrFlinger) {
            ALOGE("Failed to start vrflinger");
        }
    }

    // initialize our drawing state
    mDrawingState = mCurrentState;

    // set initial conditions (e.g. unblank default device)
    //发送异步消息，初始化设备
    initializeDisplays();

    getRenderEngine().primeCache();

    // Inform native graphics APIs whether the present timestamp is supported:
    //创建启动动画线程
    const bool presentFenceReliable =
            !getHwComposer().hasCapability(HWC2::Capability::PresentFenceIsNotReliable);
    mStartPropertySetThread = getFactory().createStartPropertySetThread(presentFenceReliable);
    //启动开机动画线程
    if (mStartPropertySetThread->Start() != NO_ERROR) {
        ALOGE("Run StartPropertySetThread failed!");
    }
    //配置刷新了改变回调函数
    mScheduler->setChangeRefreshRateCallback(
            [this](RefreshRateType type, Scheduler::ConfigEvent event) {
                Mutex::Autolock lock(mStateLock);
                setRefreshRateTo(type, event);
            });
    //配置周期获取回调函数
    mScheduler->setGetVsyncPeriodCallback([this] {
        Mutex::Autolock lock(mStateLock);
        return getVsyncPeriod();
    });
    //保存当前刷新了参数
    mRefreshRateConfigs.populate(getHwComposer().getConfigs(*display->getId()));
    mRefreshRateStats.setConfigMode(getHwComposer().getActiveConfigIndex(*display->getId()));

    // obtain hwvsync period and initial vsync offset
    sfFrameInfo.intialSfVsyncOffset = ns2ms(mPhaseOffsets->getCurrentSfOffset());
    // ns transfer ms for float type
    sfFrameInfo.hwVsyncPeriod = getVsyncPeriod() / 1000000.0;
    ALOGV("Done initializing");
}</code></pre>
<p>代码有点长，我们慢慢看，</p>
<p><strong>mScheduler</strong></p>
<pre class=" language-c++"><code class="language-c++">    mScheduler =
            getFactory().createScheduler([this](bool enabled) { setPrimaryVsyncEnabled(enabled); },
                                         mRefreshRateConfigs);
    auto resyncCallback =
            mScheduler->makeResyncCallback(std::bind(&SurfaceFlinger::getVsyncPeriod, this));

    mAppConnectionHandle =
            mScheduler->createConnection("app", mPhaseOffsets->getCurrentAppOffset(),
                                         resyncCallback,
                                         impl::EventThread::InterceptVSyncsCallback());
    mSfConnectionHandle = mScheduler->createConnection("sf", mPhaseOffsets->getCurrentSfOffset(),
                                                       resyncCallback, [this](nsecs_t timestamp) {
                                                           mInterceptor->saveVSyncEvent(timestamp);
                                                       });</code></pre>
<p>创建Scheduler实例，两个入参：</p>
<ol>
<li>lamda定义的回调函数[this](bool enabled) { setPrimaryVsyncEnabled(enabled);函数实现是SurfaceFlinger控制Vsync信号的开关。也就是SurfaceFlinger的Vsync信号使能是由Schedule控制的。</li>
<li>刷新率配置变量的地址，Scheduler内部操作的mRefreshRateConfigs变量就是SurfaceFlinger的mRefreshRateConfigs。</li>
</ol>
<p>使用Scheduler::makeResyncCallback函数构造一个回调函数，回调的是SurfaceFlinger实例对象的getVsyncPeriod函数。</p>
<p>使用CreateConnection函数创建app和sf时钟信号。app信号用于管理app的消息处理。sf信号用来管理SurfaceFlinger内部的消息处理。创建过程如下：</p>
<pre class=" language-c++"><code class="language-c++">sp<Scheduler::ConnectionHandle> Scheduler::createConnection(
        const char* connectionName, int64_t phaseOffsetNs, ResyncCallback resyncCallback,
        impl::EventThread::InterceptVSyncsCallback interceptCallback) {
    const int64_t id = sNextId++;
    ALOGV("Creating a connection handle with ID: %" PRId64 "\n", id);

    std::unique_ptr<EventThread> eventThread =
            makeEventThread(connectionName, mPrimaryDispSync.get(), phaseOffsetNs,
                            std::move(interceptCallback));

    auto eventThreadConnection =
            createConnectionInternal(eventThread.get(), std::move(resyncCallback));
    mConnections.emplace(id,
                         std::make_unique<Connection>(new ConnectionHandle(id),
                                                      eventThreadConnection,
                                                      std::move(eventThread)));
    return mConnections[id]->handle;
}

std::unique_ptr<EventThread> Scheduler::makeEventThread(
        const char* connectionName, DispSync* dispSync, int64_t phaseOffsetNs,
        impl::EventThread::InterceptVSyncsCallback interceptCallback) {
    std::unique_ptr<VSyncSource> eventThreadSource =
            std::make_unique<DispSyncSource>(dispSync, phaseOffsetNs, true, connectionName);
    return std::make_unique<impl::EventThread>(std::move(eventThreadSource),
                                               std::move(interceptCallback), connectionName);
}

sp<EventThreadConnection> Scheduler::createConnectionInternal(EventThread* eventThread,
                                                              ResyncCallback&& resyncCallback) {
    return eventThread->createEventConnection(std::move(resyncCallback));
}</code></pre>
<p>首先通过makeEventThread创建eventThread实例，实例创建需要三个参数，connectionName,initerceptCallback,eventThreadSource。</p>
<ul>
<li><p>先是通过mPrimaryDispSync创建VSyncSource类的实例eventThreadSource。mPrimaryDispSync变量在Scheduler的构造函数中初始化，是一个android::impl::DispSync类。</p>
</li>
<li><p>创建android::impl::EventThread类实例，同时传入构造函数。</p>
</li>
</ul>
<p>接着通过createConnectionInternal函数把EventThread和SurfaceFlinger函数的回调getVsyncPeriod链接起来。</p>
<p>所以在整个场景关系图如下所示：</p>
<pre class="mermaid">graph LR
Shecdule[Scheduler::mConnections]--&gt;Connect[appconnect]
Connect--&gt;id[connectionHandle::id]
Connect--&gt;EvenctTc[EventThreadConnection eventThreadConnection]
Connect--&gt;ET[android::impl::EventThread eventThread]
ET--&gt;|create|EvenctTc
EvenctTc--&gt;|resyncCallback|F[surfaceFlinger::getVsyncPeriod]
ET--&gt;VsyncSource[VsyncSource::eventThreadSource]
DispVsync[android::impl::DispSync mPrimaryDispSync]--&gt;VsyncSource
ET--&gt;|mInterceptVSyncsCallback|ETetc[impl::EventThread::InterceptVSyncsCallback]

Shecdule--&gt;Connect1[sfconnect]
Connect1--&gt;id1[connectionHandle::id]
Connect1--&gt;EvenctTc1[EventThreadConnection eventThreadConnection]
Connect1--&gt;ET1[android::impl::EventThread eventThread]
ET1--&gt;|create|EvenctTc1
EvenctTc1--&gt;|resyncCallback|F1[surfaceFlinger::getVsyncPeriod]
ET1--&gt;VsyncSource1[VsyncSource::eventThreadSource]
DispVsync[android::impl::DispSync mPrimaryDispSync]--&gt;VsyncSource1
ET1--&gt;|mInterceptVSyncsCallback|ETetc1[Scheduler mInterceptor.saveVSyncEvent]


EvenctTc1--&gt;|setEventConnnect|EvenctTc1SFMQ[sfMessageQueue]
SFVM[VSyncModulator]--&gt;|mScheduler|Shecdule
SFVM--&gt;|mAppConnectionHandle|id
SFVM--&gt;|mSfConnectionHandle|id1</pre>

<pre class="mermaid">graph LR
SF[surfaceFlinger]--&gt;|mScheduler|Schedule[android::Schedule]
SF--&gt;|mAppConnectionHandle|appConnectionHandle[Scheduler::ConnectionHandle]
SF--&gt;|msfConnectionHandle|sfConnectionHandle[Scheduler::ConnectionHandle]
SF--&gt;|mEventQueue|SFEvConnect[sfEventThreadConnect]

VSyncModulator--&gt;|mSchedule|Schedule
VSyncModulator--&gt;|mAppConnectionHandle|appConnectionHandle
VSyncModulator--&gt;|mSfConnectionHandle|sfConnectionHandle
SF--&gt;|mVsyncModulator|VSyncModulator</pre>



<h2 id="surfaceFlinger运行通路"><a href="#surfaceFlinger运行通路" class="headerlink" title="surfaceFlinger运行通路"></a>surfaceFlinger运行通路</h2><p>surfaceFlinger的主要作用有三个：向app侧传递app-Vsync信号；向app侧和HWC提供surface layer；根据sf-Vsync节奏合成surface layer。其中app-Vsync和sf-Vsync是SF传递的时钟信号，本节主要介绍的内容。surface layer是上下层的数据流，数据流的传递后续章节结合app侧和HWC侧介绍。</p>
<h3 id="app-Vsync信号注册和回调"><a href="#app-Vsync信号注册和回调" class="headerlink" title="app-Vsync信号注册和回调"></a>app-Vsync信号注册和回调</h3><p>application的activity在java层经过一系列流程创建完成之后，通过DisplayerEventListener与native的SF进行app-VSync的通信，主要通信流程如下所示：</p>
<pre class="mermaid">sequenceDiagram
BpDisplayerListener-&gt;&gt;BnDisplayerListener:gui:bitube
BnDisplayerListener-&gt;&gt;DisplayEventReceiver:new
DisplayEventReceiver-&gt;&gt;surfaceFlinger:createDisplayEventConnect
surfaceFlinger-&gt;&gt;Scheduler:createConnectionInternal
Scheduler-&gt;&gt;EventThreadConnection:new

EventThreadConnection-&gt;&gt;EventThread:OnfirstRef
EventThread-&gt;&gt;connection:registerDisplayEventConnection
loop app-Vsync
    DispVsync-&gt;&gt;EventThread:onVsync
    EventThread-&gt;&gt;EventThread:notify_all
end    
loop threadmain
    EventThread-&gt;&gt;EventThread:waite notifyed
    EventThread-&gt;&gt;connection:connection
    connection-&gt;&gt;EventThreadConnection:post
    EventThreadConnection-&gt;&gt;DisplayEventReceiver:sedEvents
    DisplayEventReceiver-&gt;&gt;BpDisplayerListener:gui::bitube:sendObjects
end</pre>

<p>BpDisplayerListener是WMS(windowManagerServer)的一个的与native接口的类，app-Vsync消息处理其实真正对应的类有三个，EventThreadConnection，EventThread，DispVsync。一个activity的一个layer或surface注册一个ETC（EventThreadConnection），所有的 ETC保存在EventThread的Vector中。DispVsync负责向EventThread发送Vsync到来信号。简化流程如下</p>
<pre class="mermaid">graph LR

DispEventReceiver--&gt;|注册app-Vsync监听|vectorEventThreadConnection

DispVsync--&gt;|appVsync信号|EventThread
EventThread--&gt;|调用OnVsync处理|vectorEventThreadConnection  

vectorEventThreadConnection --&gt;EventThreadConnection1
EventThreadConnection1--&gt;|向java层发app-Vsync消息|app1
vectorEventThreadConnection --&gt;EventThreadConnection2
EventThreadConnection2--&gt;|向java层发app-Vsync消息|app2
vectorEventThreadConnection --&gt;EventThreadConnection3
EventThreadConnection3--&gt;|向java层发app-Vsync消息|app3
vectorEventThreadConnection --&gt;EventThreadConnection4
EventThreadConnection4--&gt;|向java层发app-Vsync消息|app4</pre>

<h3 id="sf-Vsync信号注册和回调"><a href="#sf-Vsync信号注册和回调" class="headerlink" title="sf-Vsync信号注册和回调"></a>sf-Vsync信号注册和回调</h3><h4 id="代码调用流程"><a href="#代码调用流程" class="headerlink" title="代码调用流程"></a>代码调用流程</h4><p>sf-Vsync的时钟产生和消息处理通路与app-Vsync消息的产生和处理通路类似，不同的是sf-Vsync消息对应的是一个EventThreadConnection，EventThreadConnection再调用MessageQueue去处理surface合成。主要通信流程如下：</p>
<pre class="mermaid">sequenceDiagram 
surface-&gt;&gt;surfaceFlinger:register VectorSurface
surfaceFlinger-&gt;&gt;Scheduler:CreateConnection
Scheduler-&gt;&gt;EventThread:new
Scheduler-&gt;&gt;EventThreadConnection:new
EventThreadConnection-&gt;&gt;EventThread:registe
EventThreadConnection-&gt;&gt;MessageQueue:registe
MessageQueue-&gt;&gt;'Loop':new
MessageQueue-&gt;&gt;handler:new
loop sf-Vsync
    DispVsync-&gt;&gt;EventThread:onVsync
    EventThread-&gt;&gt;EventThread:notify_all
end 
loop threadmain
    EventThread-&gt;&gt;EventThread:waite notifyed
    EventThread-&gt;&gt;connection:connection
    connection-&gt;&gt;EventThreadConnection:post
    EventThreadConnection-&gt;&gt;DisplayEventReceiver:sedEvents
    DisplayEventReceiver-&gt;&gt;MessageQueue:gui::bitube:sendObjects
end
MessageQueue-&gt;&gt;handler:dispatchInvalidate
handler-&gt;&gt;'Loop':sendMessage INVALIDATE
'Loop'-&gt;&gt;handler:handlerMessage INVALIDATE
handler-&gt;&gt;surfaceFlinger:OnMessageReceived INVALIDATE
surfaceFlinger-&gt;&gt;surfaceFlinger:handlerSurfaceCompose VectorSurface
surfaceFlinger-&gt;&gt;MessageQueue:sendMessage REFERSH
MessageQueue-&gt;&gt;'Loop':sendMessage REFERSH
'Loop'-&gt;&gt;handler:handlerMessage REFERSH
handler-&gt;&gt;surfaceFlinger:OnMessageReceived REFERSH
surfaceFlinger--&gt;&gt;HWC:composition</pre>

<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p>sf-Vsync是SurfaceFlinger的内部时钟，用于处理surface合并事件，简单理解sf-Vsync的通路如下：</p>
<pre class="mermaid">graph TB
DispVsync--&gt;|1 sfVsync信号|EventThread
EventThread--&gt;|2 调用OnVsync处理|vectorEventThreadConnection  
surface--&gt;|注册layer监听|surfaceFlinger
vectorEventThreadConnection --&gt;|3 gui::bitupe|Looper
Looper--&gt;|4 callback::cb_eventReceiver|MessageQueue
MessageQueue--&gt;|5 调用loop<br>发送sfVsync/REFERSH到来消息|Looper
Looper--&gt;|6 handler调用handlerMessage<br>处理loop的消息|Handler
Handler--&gt;|7 调用sf.OnMessageReceived<br>响应sfVsync/REFERSH消息|surfaceFlinger
surfaceFlinger--&gt;|8 根据surface合并结果<br>确定是否刷新|MessageQueue
surfaceFlinger--&gt;|9 渲染|ESGL
surfaceFlinger--&gt;|10 fench/surface|HWC
ESGL--&gt;|11 release fench|HWC</pre>

<p>surface注册到surfaceFlinger之后，会保存到一个队列中。在sf-Vsync到来后，会处理保存的surfaces，根据处理结果判断是否需要合并surface触发刷新操作。在刷新操作中会合并surface，同时调用GPU执行合并操作，同时生成新的fench信号给HWC。</p>
<h2 id="创建Activity和注册surface流程"><a href="#创建Activity和注册surface流程" class="headerlink" title="创建Activity和注册surface流程"></a>创建Activity和注册surface流程</h2><h3 id="Activity的启动流程"><a href="#Activity的启动流程" class="headerlink" title="Activity的启动流程"></a>Activity的启动流程</h3><p>转载自:<a href="https://www.jianshu.com/p/9ecea420eb52" target="_blank" rel="noopener">3分钟看懂Activity启动流程</a></p>
<p><img src="1869462-1ee9c9600c8ac2cd.webp" alt="Activity启动流程"></p>
<p>Android中，一个应用程序的开始可以说就是从<strong>ActivityThread.java</strong>中的main()方法开始的。都是学过Java的人，想必也都知道Java的程序入口就是main()方法。从这点而言，我们可以把它想成是一个Java程序（注意，不是说Android是个Java程序哦）去理解。</p>
<p>从上图可以看到，main()方法中主要做的事情有：</p>
<ol>
<li><p>初始化主线程的Looper、主Handler。并使主线程进入等待接收Message消息的无限循环状态。</p>
</li>
<li><p>调用attach()方法，主要就是为了发送出初始化Application的消息。</p>
</li>
<li><p>创建Application的消息是如何发送的呢？</p>
<p>上面提到过，ActivityThread的attach()方法最终的目的是发送出一条创建Application的消息——H.BIND_APPLICATION，到主线程的主Handler中。</p>
</li>
</ol>
<h4 id="一切从main-方法开始"><a href="#一切从main-方法开始" class="headerlink" title="一切从main()方法开始"></a>一切从main()方法开始</h4><p>Android中，一个应用程序的开始可以说就是从<strong>ActivityThread.java</strong>中的main()方法开始的。都是学过Java的人，想必也都知道Java的程序入口就是main()方法。从这点而言，我们可以把它想成是一个Java程序（注意，不是说Android是个Java程序哦）去理解。</p>
<p><img src="1869462-882b8e0470adf85a.webp" alt="img"></p>
<p>从上图可以看到，main()方法中主要做的事情有：</p>
<ol>
<li>初始化主线程的Looper、主Handler。并使主线程进入等待接收Message消息的无限循环状态。关于Android的Handler机制，可以参考一下我上面提到的文章：<br> <a href="https://www.jianshu.com/p/8862bd2b6a29" target="_blank" rel="noopener">【惊天秘密！从Thread开始，揭露Android线程通讯的诡计和主线程的阴谋】http://www.jianshu.com/p/8862bd2b6a29</a><br> 下面是main()方法中比较关键的代码：</li>
</ol>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    Looper<span class="token punctuation">.</span><span class="token function">prepareMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment" spellcheck="true">//初始化Looper</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ActivityThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ActivityThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//实例化一个ActivityThread</span>
    thread<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这个方法最后就是为了发送出创建Application的消息</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
    Looper<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//主线程进入无限循环状态，等待接收消息</span>
<span class="token punctuation">}</span></code></pre>
<p>2.调用attach()方法，主要就是为了发送出初始化Application的消息。这个流程说长不长，说短不短。下文会再捋一捋。</p>
<h4 id="创建Application的消息是如何发送的呢？"><a href="#创建Application的消息是如何发送的呢？" class="headerlink" title="创建Application的消息是如何发送的呢？"></a>创建Application的消息是如何发送的呢？</h4><p>上面提到过，ActivityThread的attach()方法最终的目的是发送出一条创建Application的消息——H.BIND_APPLICATION，到主线程的主Handler中。那我们来看看attach()方法干了啥。<br> attach()关键代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attach</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> system<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">final</span> IActivityManager mgr <span class="token operator">=</span> ActivityManagerNative<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token comment" spellcheck="true">//获得IActivityManager实例，下面会看看它是个啥</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        mgr<span class="token punctuation">.</span><span class="token function">attachApplication</span><span class="token punctuation">(</span>mAppThread<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token comment" spellcheck="true">//看见没？关键啊。mAppThread这个参数下面也会说一下</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RemoteException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> ex<span class="token punctuation">.</span><span class="token function">rethrowFromSystemServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>莫慌莫慌，下面看看上面出现的两个对象是个啥。</p>
<h4 id="IActivityManager-mgr是个啥？"><a href="#IActivityManager-mgr是个啥？" class="headerlink" title="IActivityManager mgr是个啥？"></a>IActivityManager mgr是个啥？</h4><p>从上图也可以看到，IActivityManager是一个接口，当我们调用<code>ActivityManagerNative.getDefault()</code>获得的实际是一个代理类的实例——<strong>ActivityManagerProxy</strong>，这个东西实现了IActivityManager接口。打开源码你会发现，<strong>ActivityManagerProxy</strong>是ActivityManagerNative的一个内部类。可以看出，Android团队在设计的过程中是实践了<strong>最小惊异原则</strong>的，就是把相关的东西尽量放在一起。那么既然是个代理类，它究竟代理了谁？代码里看看喽。<br> 下面这个代码稍微有点绕啊！老哥，稳住！</p>
<ol>
<li>先看ActivityManagerProxy的构造函数：</li>
</ol>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token function">ActivityManagerProxy</span><span class="token punctuation">(</span>IBinder remote<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mRemote <span class="token operator">=</span> remote<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这个构造函数非常的简单。首先它需要一个IBinder参数，然后赋值给<strong>mRemote</strong>变量。这个<strong>mRemote</strong>显然是ActivityManagerProxy的成员变量，对它的操作是由ActivityManagerProxy来代理间接进行的。这样设计的好处是保护了mRemote，并且能够在操作mRemote前执行一些别的事务，并且我们是以IActivityManager的身份来进行这些操作的！这就非常巧妙了。</p>
<ol>
<li>那么这个构造函数是在那调用的呢？</li>
</ol>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">static</span> <span class="token keyword">public</span> IActivityManager <span class="token function">asInterface</span><span class="token punctuation">(</span>IBinder obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    IActivityManager <span class="token keyword">in</span> <span class="token operator">=</span>
        <span class="token punctuation">(</span>IActivityManager<span class="token punctuation">)</span>obj<span class="token punctuation">.</span><span class="token function">queryLocalInterface</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//先检查一下有没有</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">in</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">in</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ActivityManagerProxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这个地方调用了构造函数</span>
<span class="token punctuation">}</span></code></pre>
<p>上面这个方法是ActivityManagerNative中的一个静态方法，它会调用到ActivityManagerProxy的构造方法。然而，这个静态方法也需要一个IBinder作为参数!老夫被绕晕了。但是不怕，咱们继续往找！</p>
<ol>
<li>getDefault()获取到的静态常量gDefault</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton<span class="token operator">&lt;</span>IActivityManager<span class="token operator">></span> gDefault <span class="token operator">=</span> 
  <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token operator">&lt;</span>IActivityManager<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">protected</span> IActivityManager <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       IBinder b <span class="token operator">=</span> ServiceManager<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span><span class="token string">"activity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment" spellcheck="true">//重点啊！IBinder实例就是在这里获得的。</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        IActivityManager am <span class="token operator">=</span> <span class="token function">asInterface</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//调用了上面的方法。</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span> am<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>这是ActivityManagerNative的静态常量，它是一个单例。在其中终于获得了前面一直在用的IBinder实例。</p>
<pre class=" language-bash"><code class="language-bash">IBinder b <span class="token operator">=</span> ServiceManager.getService<span class="token punctuation">(</span><span class="token string">"activity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>试着在上图中找到对应位置。</p>
<p>这里是通过<strong>ServiceManager</strong>获取到<strong>IBinder</strong>实例的。如果你以前了解<strong>AIDL</strong>通讯流程的话。这可能比较好理解一点，这只是通过另一种方式获取<strong>IBinder</strong>实例罢了。获取<strong>IBinder</strong>的目的就是为了通过这个<strong>IBinder</strong>和<strong>ActivityManager</strong>进行通讯，进而<strong>ActivityManager</strong>会调度发送<strong>H.BIND_APPLICATION</strong>即初始化Application的Message消息。如果之前没接触过<strong>Binder</strong>机制的话，只需知道这个目的就行了。我后面会写一篇专门介绍Android中Binder机制的文章。</p>
<ol>
<li>再来看看attachApplication(mAppThread)方法。</li>
</ol>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attachApplication</span><span class="token punctuation">(</span>IApplicationThread app<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  mRemote<span class="token punctuation">.</span><span class="token function">transact</span><span class="token punctuation">(</span>ATTACH_APPLICATION_TRANSACTION<span class="token punctuation">,</span> data<span class="token punctuation">,</span> reply<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>这个方法我在上图中也体现出来了。</p>
<p>这个方法中上面这一句是关键。调用了IBinder实例的tansact()方法，并且把参数app(这个参数稍后就会提到)放到了data中，最终传递给ActivityManager。</p>
<p>现在，我们已经基本知道了IActivityManager是个什么东东了。其实最重要的就是它的一个实现类<strong>ActivityManagerProxy</strong>，它主要代理了内核中与<strong>ActivityManager</strong>通讯的<strong>Binder</strong>实例。下面再看看<strong>ApplicationThread mAppThread</strong>。</p>
<h4 id="ApplicationThread-mAppThread又是个啥？"><a href="#ApplicationThread-mAppThread又是个啥？" class="headerlink" title="ApplicationThread mAppThread又是个啥？"></a>ApplicationThread mAppThread又是个啥？</h4><ol>
<li>在ActivityThread的成员变量中，你能够发现：</li>
</ol>
<pre class=" language-dart"><code class="language-dart"><span class="token keyword">final</span> ApplicationThread mAppThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ApplicationThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>ApplicationThread是作为ActivityThread中的一个常量出现的。这表明系统不希望这个变量中途被修改，可见这个变量具有特定而十分重要的作用。</p>
<ol>
<li>我们看看他是啥。</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationThread</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationThreadNative</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>ApplicationThread是ActivityThread中的一个内部类，为什么没有单独出来写在别的地方呢？我觉得这也是对最小惊异原则的实践。因为ApplicationThread是专门真对这里使用的对象。</p>
<ol>
<li>它继承自ApplicationThreadNative，我们再看看它是个啥。</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationThreadNative</span> <span class="token keyword">extends</span> <span class="token class-name">Binder</span> 
    <span class="token keyword">implements</span> <span class="token class-name">IApplicationThread</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">//无参构造函数</span>
    <span class="token keyword">public</span> <span class="token function">ApplicationThreadNative</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//这是Binder的</span>
        <span class="token function">attachInterface</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>那么很明显，ApplicationThread最终也是一个Binder！同时，由于实现了IApplicationThread接口，所以它也是一个IApplicationThread。以上这系对应关系你都可以在上图中找到。</p>
<p>我们在ActivityThread中看到的ApplicationThread使用的构造函数是无参的，所以看上面无参构造函数都干了啥！</p>
<p>Binder的attachInterface(IInterface owner, String descriptor)方法没什么特别的，就是赋值了。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attachInterface</span><span class="token punctuation">(</span>IInterface owner<span class="token punctuation">,</span> String descriptor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mOwner <span class="token operator">=</span> owner<span class="token punctuation">;</span>
    mDescriptor <span class="token operator">=</span> descriptor<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>4.那么IApplicationThread又是啥？老铁，走着！我们继续挖。</p>
<pre class=" language-dart"><code class="language-dart">public interface <span class="token class-name">IApplicationThread</span> <span class="token keyword">extends</span> <span class="token class-name">IInterface</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    String descriptor <span class="token operator">=</span> <span class="token string">"android.app.IApplicationThread"</span><span class="token punctuation">;</span> 
    <span class="token comment" spellcheck="true">//留意下这个参数</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>好吧，这在上图中没有，挖的有点什么了。但是学习嘛，咱就看看喽。</p>
<p>IApplicationThread是继承了IInterface的一个接口，我们需要关注一下里面的descriptor参数。后面会用它，它是一个标识，查询的时候很重要。</p>
<p>好，我们终于知道attach()方法中出现的两个对象是啥了。ApplicationThread作为IApplicationThread的一个实例，承担了最后发送Activity生命周期、及其它一些消息的任务。也就是说，前面绕了一大圈，最后还是回到这个地方来发送消息。我擦！</p>
<p>也许你会想，既然在ActivityThread中我们已经创建出了ApllicationThread的了，为什么还要绕这么弯路？，当然是为了让系统根据情况来控制这个过程喽，不然为什么要把ApplicationThread传到ActivityManager中呢？</p>
<h4 id="ActivityManagerService调度发送初始化消息"><a href="#ActivityManagerService调度发送初始化消息" class="headerlink" title="ActivityManagerService调度发送初始化消息"></a>ActivityManagerService调度发送初始化消息</h4><p>经过上面的辗转，ApplicationThread终于到了ActivityManagerService中了。请在上图中找到对应位置！</p>
<p>从上图中可以看到，ActivityManagerService中有一这样的方法：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">attachApplicationLocked</span><span class="token punctuation">(</span>IApplicationThread thread
<span class="token punctuation">,</span> <span class="token keyword">int</span> pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    thread<span class="token punctuation">.</span><span class="token function">bindApplication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//注意啦！</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>ApplicationThread以IApplicationThread的身份到了ActivityManagerService中，经过一系列的操作，最终被调用了自己的bindApplication()方法，发出初始化Applicationd的消息。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">bindApplication</span><span class="token punctuation">(</span>String processName<span class="token punctuation">,</span> 
    ApplicationInfo appInfo<span class="token punctuation">,</span>
    List<span class="token operator">&lt;</span>ProviderInfo<span class="token operator">></span> providers<span class="token punctuation">,</span> 
    ComponentName instrumentationName<span class="token punctuation">,</span>
    ProfilerInfo profilerInfo<span class="token punctuation">,</span> 
    Bundle instrumentationArgs<span class="token punctuation">,</span>
    IInstrumentationWatcher instrumentationWatcher<span class="token punctuation">,</span>
    IUiAutomationConnection instrumentationUiConnection<span class="token punctuation">,</span> 
    <span class="token keyword">int</span> debugMode<span class="token punctuation">,</span>
    <span class="token keyword">boolean</span> enableBinderTracking<span class="token punctuation">,</span> 
    <span class="token keyword">boolean</span> trackAllocation<span class="token punctuation">,</span>
    <span class="token keyword">boolean</span> isRestrictedBackupMode<span class="token punctuation">,</span> 
    <span class="token keyword">boolean</span> persistent<span class="token punctuation">,</span> 
    Configuration config<span class="token punctuation">,</span>
    CompatibilityInfo compatInfo<span class="token punctuation">,</span> 
    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> IBinder<span class="token operator">></span> services<span class="token punctuation">,</span> 
    Bundle coreSettings<span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">sendMessage</span><span class="token punctuation">(</span>H<span class="token punctuation">.</span>BIND_APPLICATION<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>吓屎老纸！这么多参数。这明明很违反参数尽量要少的原则嘛！所以说，有的时候，开发过程中还是很难避免一些参数堆积的情况的。也不能一概而论。</p>
<p>但是，这个地方，我们只要知道最后发了一条<strong>H.BIND_APPLICATION</strong>消息，接着程序开始了。</p>
<h4 id="收到初始化消息之后的世界"><a href="#收到初始化消息之后的世界" class="headerlink" title="收到初始化消息之后的世界"></a>收到初始化消息之后的世界</h4><p>上面我们已经找到初始化Applicaitond的消息是在哪发送的了。现在，需要看一看收到消息后都发生了些什么。</p>
<p>现在上图的H下面找到第一个消息：<strong>H.BIND_APPLICATION</strong>。一旦接收到这个消息就开始创建Application了。这个过程是在handleBindApplication()中完成的。看看这个方法。在上图中可以看到对应的方法。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> void <span class="token function">handleBindApplication</span><span class="token punctuation">(</span>AppBindData <span class="token keyword">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
    mInstrumentation <span class="token operator">=</span> <span class="token punctuation">(</span>Instrumentation<span class="token punctuation">)</span>
        cl<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token punctuation">.</span>instrumentationName<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//通过反射初始化一个Instrumentation仪表。后面会介绍。</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
    Application app <span class="token operator">=</span> <span class="token keyword">data</span><span class="token punctuation">.</span>info<span class="token punctuation">.</span><span class="token function">makeApplication</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token punctuation">.</span>restrictedBackupMode<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//通过LoadedApp命令创建Application实例</span>
    mInitialApplication <span class="token operator">=</span> app<span class="token punctuation">;</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
    mInstrumentation<span class="token punctuation">.</span><span class="token function">callApplicationOnCreate</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//让仪器调用Application的onCreate()方法</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>handleBindApplication()是一个很长的方法，但是我为各位看官精选出了上面这几句代码。对于本篇的主题来说，他们是至关重要的。上面短短的代码中出现了几个新对象。下面我会一一道来。</p>
<h4 id="Instrumentation仪表，什么鬼？"><a href="#Instrumentation仪表，什么鬼？" class="headerlink" title="Instrumentation仪表，什么鬼？"></a>Instrumentation仪表，什么鬼？</h4><p>1.这个叫Instrumentation仪表的东西十分诡异，姑且翻译为仪器吧。字面上看不出任何它是干什么的线索。但是，我们可以打开文档看看喽。</p>
<blockquote>
<p>Instrumentation会在应用程序的任何代码运行之前被实例化，它能够允许你监视应用程序和系统的所有交互。</p>
</blockquote>
<p>大概就这个意思啦。</p>
<p>2.但是，从上面的代码我们可以看出，Instrumentation确实是在Application初始化之前就被创建了。那么它是如何实现监视应用程序和系统交互的呢？</p>
<p>打开这个类你可以发现，最终Apllication的创建，Activity的创建，以及生命周期都会经过这个对象去执行。简单点说，就是把这些操作包装了一层。通过操作Instrumentation进而实现上述的功能。</p>
<p>3.那么这样做究竟有什么好处呢？仔细想想。Instrumentation作为抽象，当我们约定好需要实现的功能之后，我们只需要给Instrumentation仪表添加这些抽象功能，然后调用就好。剩下的，不管怎么实现这些功能，都交给Instrumentation仪器的实现对象就好。啊！这是多态的运用。啊！这是依赖抽象，不依赖具体的实践。啊！这是上层提出需求，底层定义接口，即依赖倒置原则的践行。呵！抽象不过如此。</p>
<p>从代码中可以看到，这里实例化Instrumentation的方法是反射！而反射的ClassName是来自于从ActivityManagerService中传过来的Binder的。套路太深！就是为了隐藏具体的实现对象。但是这样耦合性会很低。</p>
<p>4.好了，不瞎扯了。既然在说Instrumentation，那就看看最后调的callApplicationOnCreate()方法。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callApplicationOnCreate</span><span class="token punctuation">(</span>Application app<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    app<span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>你没看错，它啥也没干。只是调用了一下Application的onCreate()方法。这就是为什么它能够起到监控的作用。</p>
<p>在上图中你能够看到Instrumentation，以及它的交互过程。</p>
<h4 id="LoadedApk就是data-info哦！"><a href="#LoadedApk就是data-info哦！" class="headerlink" title="LoadedApk就是data.info哦！"></a>LoadedApk就是data.info哦！</h4><p>关于它是怎么来的本篇就不说了，以后可能会介绍下。本篇就看流程就好。所以直接进去看它的makeApplication()干了啥，就把Application给创建了。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Application <span class="token function">makeApplication</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> forceDefaultAppClass<span class="token punctuation">,</span>
    Instrumentation instrumentation<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    String appClass <span class="token operator">=</span> mApplicationInfo<span class="token punctuation">.</span>className<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//Application的类名。明显是要用反射了。</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ContextImpl appContext <span class="token operator">=</span> ContextImpl<span class="token punctuation">.</span><span class="token function">createAppContext</span><span class="token punctuation">(</span>mActivityThread
        <span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//留意下Context</span>
    app <span class="token operator">=</span> mActivityThread<span class="token punctuation">.</span>mInstrumentation
        <span class="token punctuation">.</span><span class="token function">newApplication</span><span class="token punctuation">(</span> cl<span class="token punctuation">,</span> appClass<span class="token punctuation">,</span> appContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//通过仪表创建Application</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>在这个方法中，我们需要知道的就是，在取得Application的实际类名之后，最终的创建工作还是交由Instrumentation去完成，就像前面所说的一样。</p>
<p>值得留意的是，就像上图所标注的一样，当需要第二次获取Application时，同样只需要调用这个方法就好。“真是方便！”</p>
<h4 id="现在把目光移回Instrumentation"><a href="#现在把目光移回Instrumentation" class="headerlink" title="现在把目光移回Instrumentation"></a>现在把目光移回Instrumentation</h4><p>看看newApplication()中是如何完成Application的创建的。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">public</span> Application <span class="token function">newApplication</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz
    <span class="token punctuation">,</span> Context context<span class="token punctuation">)</span> <span class="token keyword">throws</span> InstantiationException
    <span class="token punctuation">,</span> IllegalAccessException
    <span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>
        Application app <span class="token operator">=</span> <span class="token punctuation">(</span>Application<span class="token punctuation">)</span>clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//反射创建，简单粗暴</span>
        app<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//关注下这里，Application被创建后第一个调用的方法。</span>
        <span class="token comment" spellcheck="true">//目的是为了绑定Context。</span>
        <span class="token keyword">return</span> app<span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>我的天，绕了这么多，这Application可算是创建出来了。快给自己一个小红花吧！</p>
<h4 id="LaunchActivity"><a href="#LaunchActivity" class="headerlink" title="LaunchActivity"></a>LaunchActivity</h4><p>当Application初始化完成后，系统会更具Manifests中的配置的启动Activity发送一个Intent去启动相应的Activity。这个过程本篇先不提，下次再说。主要看流程！</p>
<p>直接的，H就收到了一条LAUNCH_ACTIVITY的消息。然后开始初始化Activity之旅。收到消息后，真正处理是在ActivityThread中的handleLaunchActivity()中进行的。是不是迫不及待的想要知道发生了啥？快在上图中找到对应的步骤吧！</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handleLaunchActivity</span><span class="token punctuation">(</span>ActivityClientRecord r
    <span class="token punctuation">,</span> Intent customIntent
    <span class="token punctuation">,</span> String reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    Activity a <span class="token operator">=</span> <span class="token function">performLaunchActivity</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> customIntent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//妈蛋！又封装到另一个方法中创建了。</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">handleResumeActivity</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>token
        <span class="token punctuation">,</span> <span class="token keyword">false</span>
        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>isForward
        <span class="token punctuation">,</span><span class="token operator">!</span>r<span class="token punctuation">.</span>activity<span class="token punctuation">.</span>mFinished <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>r<span class="token punctuation">.</span>startsNotResumed
        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>lastProcessedSeq<span class="token punctuation">,</span> reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//Activity创建成功就往onResume()走了！</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>从上面的代码中可以看出…好吧，什么都看不出来！</p>
<p>再走一个方法。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">private</span> Activity <span class="token function">performLaunchActivity</span><span class="token punctuation">(</span>ActivityClientRecord r
    <span class="token punctuation">,</span> Intent customIntent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    activity <span class="token operator">=</span> mInstrumentation<span class="token punctuation">.</span><span class="token function">newActivity</span><span class="token punctuation">(</span>
         cl<span class="token punctuation">,</span> component<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//通过仪表来创建Activity</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
     Application app <span class="token operator">=</span> r<span class="token punctuation">.</span>packageInfo<span class="token punctuation">.</span><span class="token function">makeApplication</span><span class="token punctuation">(</span><span class="token boolean">false</span>
     <span class="token punctuation">,</span> mInstrumentation<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment" spellcheck="true">//前面说过，是在获取Application</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    activity<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>appContext
        <span class="token punctuation">,</span> <span class="token keyword">this</span>
        <span class="token punctuation">,</span> <span class="token function">getInstrumentation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>token
        <span class="token punctuation">,</span><span class="token punctuation">.</span>ident
        <span class="token punctuation">,</span> app
        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>intent
        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>activityInfo
        <span class="token punctuation">,</span> title
        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>parent
        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>embeddedID
        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>lastNonConfigurationInstances
        <span class="token punctuation">,</span> config
        <span class="token punctuation">,</span>r<span class="token punctuation">.</span>referrer
        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>voiceInteractor
        <span class="token punctuation">,</span> window<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//方法怪出现！</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">isPersistable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mInstrumentation<span class="token punctuation">.</span><span class="token function">callActivityOnCreate</span><span class="token punctuation">(</span>
          activity<span class="token punctuation">,</span> r<span class="token punctuation">.</span>state<span class="token punctuation">,</span> r<span class="token punctuation">.</span>persistentState<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        mInstrumentation<span class="token punctuation">.</span><span class="token function">callActivityOnCreate</span><span class="token punctuation">(</span>activity<span class="token punctuation">,</span> r<span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//根据是否可持久化选择onCreate()方法。</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>这个方法内容较多，我们一个个看。</p>
<pre class=" language-undefined"><code class="language-undefined">activity = mInstrumentation.newActivity(
         cl, component.getClassName(), r.intent);</code></pre>
<p>正如前面所说，Activity、Application的创建及生命周期都被承包给Instrumentation仪表了。所以由它来负责。看看Instrumentation干了啥。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Activity <span class="token function">newActivity</span><span class="token punctuation">(</span>ClassLoader cl<span class="token punctuation">,</span> String className<span class="token punctuation">,</span>
            Intent intent<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> InstantiationException
            <span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">,</span>
            ClassNotFoundException <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>Activity<span class="token punctuation">)</span>cl<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//真的没干啥。反射实例化Activity而已</span>
    <span class="token punctuation">}</span></code></pre>
<p>就是反射出一个Activity而已。</p>
<pre class=" language-bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">(</span>r.isPersistable<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>
        mInstrumentation.callActivityOnCreate<span class="token punctuation">(</span>
          activity, r.state, r.persistentState<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        mInstrumentation.callActivityOnCreate<span class="token punctuation">(</span>activity, r.state<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>根据是否可持久化选择Activity的onCreate()方法。同样是通过Instrumentation仪表来执行onCreate()的。它两分别对应的onCreate()方法为：</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token function">onCreate</span><span class="token punctuation">(</span>icicle<span class="token punctuation">,</span> persistentState<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//可获得持久化数据</span></code></pre>
<p>和</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token function">onCreate</span><span class="token punctuation">(</span>icicle<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//平时重写的最多的。</span></code></pre>
<p>中间两个方法留意一下就好，就不在解释的，感兴趣的点源码看看。</p>
<p>到此，Activity就跑起来了！怎么样？是不是并不复杂。</p>
<h3 id="surfaceFlinger创建surface"><a href="#surfaceFlinger创建surface" class="headerlink" title="surfaceFlinger创建surface"></a>surfaceFlinger创建surface</h3><p>对于window的创建，我们就从handleLaunchActivity开始，开始看源码吧：</p>
<pre class=" language-tsx"><code class="language-tsx">//ActivityThread
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    ``````
    //获取WindowManagerService的Binder引用(proxy端)。
    WindowManagerGlobal.initialize();
    //创建activity,调用attach方法，然后调用Activity的onCreate,onStart,onResotreInstanceState方法
    Activity a = performLaunchActivity(r, customIntent);
    if (a != null) {
        ``````
        //会调用Activity的onResume方法.
        handleResumeActivity(r.token, false, r.isForward,
                !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
        ``````
    }
}</code></pre>
<p>主要看 Activity a = performLaunchActivity(r, customIntent);方法，关注Activity的attach方法：</p>
<pre class=" language-jsx"><code class="language-jsx">inal <span class="token keyword">void</span> <span class="token function">attach</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> ActivityThread aThread<span class="token punctuation">,</span>
        Instrumentation instr<span class="token punctuation">,</span> IBinder token<span class="token punctuation">,</span> int ident<span class="token punctuation">,</span>
        Application application<span class="token punctuation">,</span> Intent intent<span class="token punctuation">,</span> ActivityInfo info<span class="token punctuation">,</span>
        CharSequence title<span class="token punctuation">,</span> Activity parent<span class="token punctuation">,</span> String id<span class="token punctuation">,</span>
        NonConfigurationInstances lastNonConfigurationInstances<span class="token punctuation">,</span>
        Configuration config<span class="token punctuation">,</span> String referrer<span class="token punctuation">,</span> IVoiceInteractor voiceInteractor<span class="token punctuation">,</span>
        Window window<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//绑定上下文</span>
        <span class="token function">attachBaseContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//创建Window, PhoneWindow是Window的唯一具体实现类</span>
        mWindow <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhoneWindow</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> window<span class="token punctuation">)</span><span class="token punctuation">;</span>
        mWindow<span class="token punctuation">.</span><span class="token function">setWindowControllerCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mWindow<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token template-string"><span class="token string">``</span></span><span class="token template-string"><span class="token string">``</span></span><span class="token template-string"><span class="token string">``</span></span>
        <span class="token comment" spellcheck="true">//设置WindowManager</span>
        mWindow<span class="token punctuation">.</span><span class="token function">setWindowManager</span><span class="token punctuation">(</span>
                <span class="token punctuation">(</span>WindowManager<span class="token punctuation">)</span>context<span class="token punctuation">.</span><span class="token function">getSystemService</span><span class="token punctuation">(</span>Context<span class="token punctuation">.</span>WINDOW_SERVICE<span class="token punctuation">)</span><span class="token punctuation">,</span>
                mToken<span class="token punctuation">,</span> mComponent<span class="token punctuation">.</span><span class="token function">flattenToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token punctuation">(</span>info<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> ActivityInfo<span class="token punctuation">.</span>FLAG_HARDWARE_ACCELERATED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>mParent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            mWindow<span class="token punctuation">.</span><span class="token function">setContainer</span><span class="token punctuation">(</span>mParent<span class="token punctuation">.</span><span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//创建完后通过getWindowManager就可以得到WindowManager实例</span>
        mWindowManager <span class="token operator">=</span> mWindow<span class="token punctuation">.</span><span class="token function">getWindowManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//其实它是WindowManagerImpl</span>
    <span class="token punctuation">}</span></code></pre>
<p>这里创建了一个PhoneWindow对象，并且实现了Window的Callback接口，这样activity就和window关联在了一起，并且通过callback能够接受key和touch事件。</p>
<p>此外，初始化且设置windowManager。每个 Activity 会有一个 WindowManager 对象，这个 mWindowManager 就是和 WindowManagerService 进行通信，也是 WindowManagerService 识别 View 具体属于那个 Activity 的关键，创建时传入 IBinder 类型的 mToken。</p>
<pre class=" language-css"><code class="language-css">mWindow<span class="token number">.</span><span class="token function">setWindowManager</span><span class="token punctuation">(</span><span class="token number">...</span>, mToken, <span class="token number">...</span>, <span class="token number">...</span><span class="token punctuation">)</span></code></pre>
<p>我们从window的setWindowManager方法出发，很容易找到WindowManager这个接口的具体的实现是WindowManagerImpl。</p>
<h4 id="window添加view过程"><a href="#window添加view过程" class="headerlink" title="window添加view过程"></a>window添加view过程</h4><p>我们前面知道PhoneWindow对View来说更多是扮演容器的角色，而真正完成把一个 View，作为窗口添加到 WMS 的过程是由 WindowManager 来完成的。而且从上面创建过程我们知道了WindowManager 的具体实现是 WindowManagerImpl。</p>
<p>那么我们继续来跟代码：</p>
<p>从上面handleLaunchActivity的代码中performLaunchActivity后面，有个handleResumeActivity，从名字也能看出，跟activity onResume相关。进去看看：</p>
<pre class=" language-dart"><code class="language-dart"><span class="token comment" spellcheck="true">//ActivityThread</span>
<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">handleResumeActivity</span><span class="token punctuation">(</span>IBinder token<span class="token punctuation">,</span>
            boolean clearHide<span class="token punctuation">,</span> boolean isForward<span class="token punctuation">,</span> boolean reallyResume<span class="token punctuation">,</span> int seq<span class="token punctuation">,</span> String reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//把activity数据记录更新到ActivityClientRecord</span>
        ActivityClientRecord r <span class="token operator">=</span> mActivities<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>
        r <span class="token operator">=</span> <span class="token function">performResumeActivity</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> clearHide<span class="token punctuation">,</span> reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>window <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>a<span class="token punctuation">.</span>mFinished <span class="token operator">&amp;&amp;</span> willBeVisible<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                r<span class="token punctuation">.</span>window <span class="token operator">=</span> r<span class="token punctuation">.</span>activity<span class="token punctuation">.</span><span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                View decor <span class="token operator">=</span> r<span class="token punctuation">.</span>window<span class="token punctuation">.</span><span class="token function">getDecorView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                decor<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>View<span class="token punctuation">.</span>INVISIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不可见</span>
                ViewManager wm <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">getWindowManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                WindowManager<span class="token punctuation">.</span>LayoutParams l <span class="token operator">=</span> r<span class="token punctuation">.</span>window<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                a<span class="token punctuation">.</span>mDecor <span class="token operator">=</span> decor<span class="token punctuation">;</span>
                l<span class="token punctuation">.</span>type <span class="token operator">=</span> WindowManager<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>TYPE_BASE_APPLICATION<span class="token punctuation">;</span>
             ``````
                <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>mVisibleFromClient <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>a<span class="token punctuation">.</span>mWindowAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    a<span class="token punctuation">.</span>mWindowAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    wm<span class="token punctuation">.</span><span class="token function">addView</span><span class="token punctuation">(</span>decor<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把decor添加到窗口上（划重点）</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
                <span class="token comment" spellcheck="true">//屏幕参数发生了改变</span>
                <span class="token function">performConfigurationChanged</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>activity<span class="token punctuation">,</span> r<span class="token punctuation">.</span>tmpConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>
                WindowManager<span class="token punctuation">.</span>LayoutParams l <span class="token operator">=</span> r<span class="token punctuation">.</span>window<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>activity<span class="token punctuation">.</span>mVisibleFromClient<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        ViewManager wm <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">getWindowManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        View decor <span class="token operator">=</span> r<span class="token punctuation">.</span>window<span class="token punctuation">.</span><span class="token function">getDecorView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        wm<span class="token punctuation">.</span><span class="token function">updateViewLayout</span><span class="token punctuation">(</span>decor<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//更新窗口状态</span>
                    <span class="token punctuation">}</span>
                ``````
                <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>activity<span class="token punctuation">.</span>mVisibleFromClient<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">//已经成功添加到窗口上了（绘制和事件接收），设置为可见</span>
                    r<span class="token punctuation">.</span>activity<span class="token punctuation">.</span><span class="token function">makeVisible</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">//通知ActivityManagerService，Activity完成Resumed</span>
             ActivityManagerNative<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">activityResumed</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span></code></pre>
<p>我们注意到这么几行代码：</p>
<pre class=" language-bash"><code class="language-bash">            <span class="token keyword">if</span> <span class="token punctuation">(</span>a.mVisibleFromClient <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>a.mWindowAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    a.mWindowAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    wm.addView<span class="token punctuation">(</span>decor, l<span class="token punctuation">)</span><span class="token punctuation">;</span>/
                <span class="token punctuation">}</span></code></pre>
<p>wm是activity getWindowManager()获取的，那不就是WindowManagerImpl的addView方法吗，追！</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//WindowManagerImpl</span>
@Override
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addView</span><span class="token punctuation">(</span>@NonNull View view<span class="token punctuation">,</span> @NonNull ViewGroup<span class="token punctuation">.</span>LayoutParams <span class="token keyword">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">applyDefaultToken</span><span class="token punctuation">(</span><span class="token keyword">params</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mGlobal<span class="token punctuation">.</span><span class="token function">addView</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> <span class="token keyword">params</span><span class="token punctuation">,</span> mContext<span class="token punctuation">.</span><span class="token function">getDisplay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mParentWindow<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>我们看到了又代理了一层：mGlobal， 它是谁？ 如果有印象的会记得讲window类型的时候带了一嘴的WindowManagerGlobal ，那这个WindowManagerImpl原来也是一个吃空饷的家伙！对于Window(或者可以说是View)的操作都是交由WindowManagerGlobal来处理，WindowManagerGlobal以工厂的形式向外提供自己的实例。这种工作模式是桥接模式，将所有的操作全部委托给WindowManagerGlobal来实现。</p>
<p>在WindowManagerImpl的全局变量中通过单例模式初始化了WindowManagerGlobal，也就是说一个进程就只有一个WindowManagerGlobal对象。那看看它：</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//WindowManagerGlobal</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addView</span><span class="token punctuation">(</span>View view<span class="token punctuation">,</span> ViewGroup<span class="token punctuation">.</span>LayoutParams <span class="token keyword">params</span><span class="token punctuation">,</span>
            Display display<span class="token punctuation">,</span> Window parentWindow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>view <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"view must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>display <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"display must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">params</span> instanceof <span class="token class-name">WindowManager<span class="token punctuation">.</span>LayoutParams</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Params must be WindowManager.LayoutParams"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        final WindowManager<span class="token punctuation">.</span>LayoutParams wparams <span class="token operator">=</span> <span class="token punctuation">(</span>WindowManager<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">)</span> <span class="token keyword">params</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>parentWindow <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//调整布局参数，并设置token</span>
            parentWindow<span class="token punctuation">.</span><span class="token function">adjustLayoutParamsForSubWindow</span><span class="token punctuation">(</span>wparams<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        ViewRootImpl root<span class="token punctuation">;</span>
        View panelParentView <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token function">synchronized</span> <span class="token punctuation">(</span>mLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">findViewLocked</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>mDyingViews<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">//如果待删除的view中有当前view，删除它</span>
                    <span class="token comment" spellcheck="true">// Don't wait for MSG_DIE to make it's way through root's queue.</span>
                    mRoots<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doDie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment" spellcheck="true">// The previous removeView() had not completed executing. Now it has.</span>
               <span class="token comment" spellcheck="true">//之前移除View并没有完成删除操作，现在正式删除该view</span>
            <span class="token punctuation">}</span>

            <span class="token comment" spellcheck="true">//如果这是一个子窗口个(popupWindow)，找到它的父窗口。</span>
            <span class="token comment" spellcheck="true">//最本质的作用是使用父窗口的token(viewRootImpl的W类，也就是IWindow)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>wparams<span class="token punctuation">.</span>type <span class="token operator">>=</span> WindowManager<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>FIRST_SUB_WINDOW <span class="token operator">&amp;&amp;</span>
                    wparams<span class="token punctuation">.</span>type <span class="token operator">&lt;=</span> WindowManager<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>LAST_SUB_WINDOW<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                final <span class="token keyword">int</span> count <span class="token operator">=</span> mViews<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>mRoots<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>mWindow<span class="token punctuation">.</span><span class="token function">asBinder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> wparams<span class="token punctuation">.</span>token<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">//在源码中token一般代表的是Binder对象，作用于IPC进程间数据通讯。并且它也包含着此次通讯所需要的信息，</span>
                    <span class="token comment" spellcheck="true">//在ViewRootImpl里，token用来表示mWindow(W类，即IWindow)，并且在WmS中只有符合要求的token才能让</span>
                    <span class="token comment" spellcheck="true">//Window正常显示.</span>
                        panelParentView <span class="token operator">=</span> mViews<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">//创建ViewRootImpl，并且将view与之绑定</span>
            root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ViewRootImpl</span><span class="token punctuation">(</span>view<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> display<span class="token punctuation">)</span><span class="token punctuation">;</span>
            view<span class="token punctuation">.</span><span class="token function">setLayoutParams</span><span class="token punctuation">(</span>wparams<span class="token punctuation">)</span><span class="token punctuation">;</span>
            mViews<span class="token punctuation">.</span><span class="token keyword">add</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将当前view添加到mViews集合中，mViews存储所有Window对应的View</span>
            mRoots<span class="token punctuation">.</span><span class="token keyword">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将当前ViewRootImpl添加到mRoots集合中，mRoots存储所有Window对应的ViewRootImpl</span>
            mParams<span class="token punctuation">.</span><span class="token keyword">add</span><span class="token punctuation">(</span>wparams<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将当前window的params添加到mParams集合中，存储所有Window对应的布局参数</span>
        <span class="token punctuation">}</span>
          ``````
            <span class="token comment" spellcheck="true">//通过ViewRootImpl的setView方法，完成view的绘制流程，并添加到window上。</span>
            root<span class="token punctuation">.</span><span class="token function">setView</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> wparams<span class="token punctuation">,</span> panelParentView<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>最最重要的是：root.setView(view, wparams, panelParentView); 一方面触发绘制流程，一方面把view添加到window上。</p>
<p>讲setView之前先普及下WindowManager与WindowManagerService binder IPC的两个接口：</p>
<p>IWindowSession: 应用程序向WMS请求功能<br>实现类：Session<br>IWindow：WMS向客户端反馈它想确认的信息<br>实现类：W</p>
<p><img src="2828107-ded3c74e738dbb7e.webp" alt="img"></p>
<p>下面看看ViewRootImpl的setView：</p>
<pre class=" language-tsx"><code class="language-tsx">//ViewRootImpl
  public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
                int res;
                 //在 Window add之前调用，确保 UI 布局绘制完成 --> measure , layout , draw
                requestLayout();//View的绘制流程
                if ((mWindowAttributes.inputFeatures
                        & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                    //创建InputChannel
                    mInputChannel = new InputChannel();
                }
                try {
                    //通过WindowSession进行IPC调用，将View添加到Window上
                    //mWindow即W类，用来接收WmS信息
                    //同时通过InputChannel接收触摸事件回调
                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);
                }
                ``````
                    //处理触摸事件回调
                    mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,
                            Looper.myLooper());
                ``````
    }</code></pre>
<p>在ViewRootImpl的setView()方法里，</p>
<p>1.执行requestLayout()方法完成view的绘制流程（之后会讲）<br>2.通过WindowSession将View和InputChannel添加到WmS中，从而将View添加到Window上并且接收触摸事件。这是一次IPC 过程。<br>那么接下来看看这个IPC过程</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//ViewRootImpl的setView方法中：</span>
mWindowSession<span class="token punctuation">.</span><span class="token function">addToDisplay</span><span class="token punctuation">(</span>mWindow<span class="token punctuation">,</span> mSeq<span class="token punctuation">,</span> mWindowAttributes<span class="token punctuation">,</span>
        <span class="token function">getHostVisibility</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mDisplay<span class="token punctuation">.</span><span class="token function">getDisplayId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        mAttachInfo<span class="token punctuation">.</span>mContentInsets<span class="token punctuation">,</span> mAttachInfo<span class="token punctuation">.</span>mStableInsets<span class="token punctuation">,</span>
        mAttachInfo<span class="token punctuation">.</span>mOutsets<span class="token punctuation">,</span> mInputChannel<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>mWindowSession：类型是interface IWindowSession</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//WindowManagerGlobal</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> IWindowSession <span class="token function">getWindowSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>WindowManagerGlobal<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sWindowSession <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                InputMethodManager imm <span class="token operator">=</span> InputMethodManager<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                IWindowManager windowManager <span class="token operator">=</span> <span class="token function">getWindowManagerService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                sWindowSession <span class="token operator">=</span> windowManager<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span>
                        <span class="token keyword">new</span> <span class="token class-name">IWindowSessionCallback<span class="token punctuation">.</span>Stub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token annotation punctuation">@Override</span>
                            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onAnimatorScaleChanged</span><span class="token punctuation">(</span><span class="token keyword">float</span> scale<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                ValueAnimator<span class="token punctuation">.</span><span class="token function">setDurationScale</span><span class="token punctuation">(</span>scale<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span><span class="token punctuation">,</span>
                        imm<span class="token punctuation">.</span><span class="token function">getClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> imm<span class="token punctuation">.</span><span class="token function">getInputContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RemoteException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> e<span class="token punctuation">.</span><span class="token function">rethrowFromSystemServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sWindowSession<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>我们看到了getWindowManagerService(); 获取了WMS , 那么再看下windowManager.openSession返回值就是sWindowSession</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> IWindowSession <span class="token function">openSession</span><span class="token punctuation">(</span>IWindowSessionCallback callback<span class="token punctuation">,</span> IInputMethodClient client<span class="token punctuation">,</span>
        IInputContext inputContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>client <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"null client"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inputContext <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"null inputContext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Session session <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Session</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> client<span class="token punctuation">,</span> inputContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> session<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>IWindowSession的真正实现类是Session，他是一个Binder. 那么Session的addToDisplay:</p>
<pre class=" language-dart"><code class="language-dart"><span class="token metadata symbol">@Override</span>
public int <span class="token function">addToDisplay</span><span class="token punctuation">(</span>IWindow window<span class="token punctuation">,</span> int seq<span class="token punctuation">,</span> WindowManager<span class="token punctuation">.</span>LayoutParams attrs<span class="token punctuation">,</span>
        int viewVisibility<span class="token punctuation">,</span> int displayId<span class="token punctuation">,</span> Rect outContentInsets<span class="token punctuation">,</span> Rect outStableInsets<span class="token punctuation">,</span>
        Rect outOutsets<span class="token punctuation">,</span> InputChannel outInputChannel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> mService<span class="token punctuation">.</span><span class="token function">addWindow</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> window<span class="token punctuation">,</span> seq<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> viewVisibility<span class="token punctuation">,</span> displayId<span class="token punctuation">,</span>
            outContentInsets<span class="token punctuation">,</span> outStableInsets<span class="token punctuation">,</span> outOutsets<span class="token punctuation">,</span> outInputChannel<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从这知道了，最终是WMS执行addWindow操作.</p>
<p>下面一张图总结下：</p>
<p><img src="2828107-e8bf87c5a8e3e509.webp" alt="img"></p>
<p>图出处：<a href="https://blog.csdn.net/freekiteyu/article/details/79408969" target="_blank" rel="noopener">https://blog.csdn.net/freekiteyu/article/details/79408969</a></p>
<p>WMS执行addWindow部分代码有点多，本篇就不铺开说了，不然篇幅就太长了，之后再说，看下如下的流程图：</p>
<p><img src="2828107-b61f6c575c591b99.webp" alt="img"></p>
<p>图出处：<a href="https://www.jianshu.com/p/effaff9ab9f2" target="_blank" rel="noopener">https://www.jianshu.com/p/effaff9ab9f2</a></p>
<p>总结起来：WMS中 addWindow流程就几点：<br>1.通过type和 token对window进行分类和验证，确保其有效性。<br>2.构造WindowState与Window一一对应。<br>3.通过token对window进行分组。<br>4.对window分配层级。</p>
<p>那么到这里，window添加view的过程就结束了。</p>
<p><strong>总结</strong>:<br>下面用一张图来总结下Activity、PhoneWindow、 DecorView 、WindowManagerGlobal 、ViewRootImpl 、Wms 以及WindowState之间的关系：</p>
<p><img src="2828107-490351404c329a15.webp" alt="img"></p>
<p>图出处：<a href="https://blog.csdn.net/qian520ao/article/details/78555397?locationNum=7&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/qian520ao/article/details/78555397?locationNum=7&amp;fps=1</a></p>
<p>Activity在attach的时候，创建了一个PhoneWindow对象，并且实现了Window的Callback接口，这样activity就和window绑定在了一起，通过setContentView，创建DecorView，并解析好视图树加载到DecorView的contentView部分，WindowManagerGlobal一个进程只有唯一一个，对当前进程内所有的视图进行统一管理，其中包括ViewRootImpl，它主要做两件事情，先触发view绘制流程，再通过IPC 把view添加到window上。</p>
<p>另外这是添加视图的方法执行时序图：</p>
<p><img src="2828107-3f93849f3f3f70c2.webp" alt="img"></p>
<p>图出处：<a href="https://blog.csdn.net/qian520ao/article/details/78555397?locationNum=7&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/qian520ao/article/details/78555397?locationNum=7&amp;fps=1</a></p>
<p>至于Window的删除和更新过程，举一反三，也是使用WindowManagerGlobal对ViewRootImpl的操作，最终也是通过Session的IPC跨进程通信通知到WmS。整个过程的本质都是同出一辙的。下一节接着讲DecorView布局的加载流程。</p>
<p>参考：<br><a href="https://blog.csdn.net/qian520ao/article/details/78555397?locationNum=7&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/qian520ao/article/details/78555397?locationNum=7&amp;fps=1</a><br><a href="https://www.jianshu.com/p/effaff9ab9f2" target="_blank" rel="noopener">https://www.jianshu.com/p/effaff9ab9f2</a><br><a href="https://blog.csdn.net/freekiteyu/article/details/79408969" target="_blank" rel="noopener">https://blog.csdn.net/freekiteyu/article/details/79408969</a></p>
<h4 id="native层创建surface"><a href="#native层创建surface" class="headerlink" title="native层创建surface"></a>native层创建surface</h4><p>前面讲到<strong>ViewRootImpl.setView()</strong>方法会向<strong>WindowManagerService</strong>请求添加一个<strong>Window</strong>,<strong>mWindowSession.addToDisplay()</strong>跨进程最终调用到了<strong>WindowManagerService.addWindow()</strong>:</p>
<blockquote>
<p>WindowManagerService.java</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">addWindow</span><span class="token punctuation">(</span>Session session<span class="token punctuation">,</span> IWindow client<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">//WindowState用来描述一个Window</span>
    <span class="token keyword">final</span> WindowState win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WindowState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> session<span class="token punctuation">,</span> client<span class="token punctuation">,</span> token<span class="token punctuation">,</span> parentWindow<span class="token punctuation">,</span>
                appOp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> seq<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> viewVisibility<span class="token punctuation">,</span> session<span class="token punctuation">.</span>mUid<span class="token punctuation">,</span>
                session<span class="token punctuation">.</span>mCanAddInternalSystemWindow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    win<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//会创建一个SurfaceSession</span>

    mWindowMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>client<span class="token punctuation">.</span><span class="token function">asBinder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> win<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//mWindowMap是WindowManagerService用来保存当前所有Window新的的集合</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    win<span class="token punctuation">.</span>mToken<span class="token punctuation">.</span><span class="token function">addWindow</span><span class="token punctuation">(</span>win<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//一个token下会有多个win state。 其实token与PhoneWindow是一一对应的。</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p><code>WindowState</code>是<code>WindowManagerService</code>用来描述应用程序的一个<code>Window</code>的对象。上面注释我标注了<code>win.attach()</code>,这个方法可以说是<code>Window</code>与<code>SurfaceFlinger</code>链接的起点,它最终会调用到<code>Session.windowAddedLocked()</code>:</p>
<blockquote>
<p>Session.java</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">windowAddedLocked</span><span class="token punctuation">(</span>String packageName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mSurfaceSession <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        mSurfaceSession <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SurfaceSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//SurfaceSession类的构造方法</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SurfaceSession</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> mNativeClient<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// SurfaceComposerClient*</span>

    <span class="token keyword">public</span> <span class="token function">SurfaceSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mNativeClient <span class="token operator">=</span> <span class="token function">nativeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span></code></pre>
<p>这里调用了native方法<code>nativeCreate()</code>，这个方法其实是返回了一个<code>SurfaceComposerClient指针</code>。那这个对象是怎么创建的呢？</p>
<h5 id="SurfaceComposerClient的创建"><a href="#SurfaceComposerClient的创建" class="headerlink" title="SurfaceComposerClient的创建"></a>SurfaceComposerClient的创建</h5><blockquote>
<p>android_view_SurfaceSession.cpp</p>
</blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">static</span> jlong <span class="token function">nativeCreate</span><span class="token punctuation">(</span>JNIEnv<span class="token operator">*</span> env<span class="token punctuation">,</span> jclass <span class="token class-name">clazz</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    SurfaceComposerClient<span class="token operator">*</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">SurfaceComposerClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//构造函数其实并没有做什么</span>
    client<span class="token operator">-</span><span class="token operator">></span><span class="token function">incStrong</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>nativeCreate<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>jlong<span class="token operator">></span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>即构造了一个<code>SurfaceComposerClient</code>对象。并返回它的指针。<strong>这个对象一个应用程序就有一个</strong>，它是应用程序与<code>SurfaceFlinger</code>沟通的桥梁，为什么这么说呢？在<code>SurfaceComposerClient指针</code>第一次使用时会调用下面这个方法:</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//这个方法在第一次使用SurfaceComposerClient的指针的时候会调用</span>
<span class="token keyword">void</span> SurfaceComposerClient<span class="token operator">::</span><span class="token function">onFirstRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sp<span class="token operator">&lt;</span>ISurfaceComposerClient<span class="token operator">></span> conn<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//sf 就是SurfaceFlinger</span>
    conn <span class="token operator">=</span> <span class="token punctuation">(</span>rootProducer <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">?</span> sf<span class="token operator">-</span><span class="token operator">></span><span class="token function">createScopedConnection</span><span class="token punctuation">(</span>rootProducer<span class="token punctuation">)</span> <span class="token operator">:</span>
            sf<span class="token operator">-</span><span class="token operator">></span><span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>即通过<code>SurfaceFlinger(它本身具有跨进程通信的能力)</code>创建了一个<code>ISurfaceComposerClient</code>对象:</p>
<blockquote>
<p>SurfaceFlinger.cpp</p>
</blockquote>
<pre class=" language-cpp"><code class="language-cpp">sp<span class="token operator">&lt;</span>ISurfaceComposerClient<span class="token operator">></span> SurfaceFlinger<span class="token operator">::</span><span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">initClient</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Client</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//initClient这个方法其实并没有做什么，</span>
<span class="token punctuation">}</span></code></pre>
<p>即构造了一个<code>Client</code>对象，<code>Client</code>实现了<code>ISurfaceComposerClient</code>接口。是一个可以跨进程通信的aidl对象。即<code>SurfaceComposerClient</code>可以通过它来和<code>SurfaceFlinger</code>通信。除此之外它还可以创建<code>Surface</code>，并且维护一个应用程序的所有<code>Layer(下文会分析到它是什么)</code>。<strong>它是一个十分重要的对象</strong>，我们先来看一下它的组成,它所涉及的其他东西在下文分析中都会讲到:</p>
<blockquote>
<p>Client.h</p>
</blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token operator">:</span> <span class="token keyword">public</span> BnSurfaceComposerClient
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">attachLayer</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>IBinder<span class="token operator">></span><span class="token operator">&amp;</span> handle<span class="token punctuation">,</span> <span class="token keyword">const</span> sp<span class="token operator">&lt;</span>Layer<span class="token operator">></span><span class="token operator">&amp;</span> layer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">detachLayer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Layer<span class="token operator">*</span> layer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token comment" spellcheck="true">// ISurfaceComposerClient interface。   gbp很重要，它维护这一个应用程序的渲染 Buffer队列</span>
    <span class="token keyword">virtual</span> status_t <span class="token function">createSurface</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>sp<span class="token operator">&lt;</span>IBinder<span class="token operator">></span><span class="token operator">*</span> handle<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">></span><span class="token operator">*</span> gbp<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">virtual</span> status_t <span class="token function">destroySurface</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>IBinder<span class="token operator">></span><span class="token operator">&amp;</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span> 

    <span class="token comment" spellcheck="true">//跨进程通信方法</span>
    <span class="token keyword">virtual</span> status_t <span class="token function">onTransact</span><span class="token punctuation">(</span>uint32_t code<span class="token punctuation">,</span> <span class="token keyword">const</span> Parcel<span class="token operator">&amp;</span> data<span class="token punctuation">,</span> Parcel<span class="token operator">*</span> reply<span class="token punctuation">,</span> uint32_t flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token comment" spellcheck="true">// constant</span>
    sp<span class="token operator">&lt;</span>SurfaceFlinger<span class="token operator">></span> mFlinger<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// protected by mLock</span>
    DefaultKeyedVector<span class="token operator">&lt;</span> wp<span class="token operator">&lt;</span>IBinder<span class="token operator">></span><span class="token punctuation">,</span> wp<span class="token operator">&lt;</span>Layer<span class="token operator">></span> <span class="token operator">></span> mLayers<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 一个应用程序的所有Layer</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>经过上面这一顿源码分析，我们大概知道了<code>ViewRootImpl.setView()</code>所引发的主要操作:</p>
<ol>
<li><code>WindowManagerService</code>创建了一个<code>WindowState</code>。用来表示客户端的一个<code>Window</code> </li>
<li><code>WindowManagerService</code>创建了一个<code>SurfaceSession</code>,<code>SurfaceSession</code>会与<code>SurfaceFlinger</code>构建链接，创建了一个<code>SurfaceComposerClient</code>对象，一个应用程序只具有一个这个对象。</li>
<li><code>SurfaceComposerClient</code>创建了一个<code>Client</code>, 这个对象十分重要，它维护这应用程序的渲染核心数据，并负责与<code>SurfaceFlinger</code>通信。</li>
</ol>
<p>如下图:</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2934684-93945b637d846361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1008/format/webp" alt="img"></p>
<p>SurfaceComposerClient的创建.png</p>
<p><strong>经过上面的步骤，应用程序的ViewRootImpl已经被WindowManagerService识别，并且应用程序已经与SurfaceFlinger建立连接。即创建了SurfaceComposerClient和Client对象</strong></p>
<p>文章开始就已经说了<code>Surface</code>是<code>Window(ViewRootImpl)</code>的UI载体，那<code>Surface</code>是在哪里创建的呢？</p>
<h5 id="Surface的创建"><a href="#Surface的创建" class="headerlink" title="Surface的创建"></a>Surface的创建</h5><p>其实一个<code>ViewRootImpl</code>就对应一个<code>Surface</code>。这点可以通过<code>ViewRootImpl</code>的源码看出:</p>
<blockquote>
<p>ViewRootImpl.java</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> Surface mSurface <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Surface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>即<code>ViewRootImpl</code>在构造的时候就<code>new 了一个 Surface</code>。但其实这个新new的<code>Surface</code>并没有什么逻辑，它的构造函数是空的。那么<code>Surface</code>到底是在哪里创建的呢？</p>
<p><strong>触发Surface的创建操作</strong></p>
<p>我们还是回到<code>ViewRootImpl.setView()</code>来看一下:</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setView</span><span class="token punctuation">(</span>View view<span class="token punctuation">,</span> WindowManager<span class="token punctuation">.</span>LayoutParams attrs<span class="token punctuation">,</span> View panelParentView<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">requestLayout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//susion 请求layout。先添加到待渲染队列中  </span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    res <span class="token operator">=</span> mWindowSession<span class="token punctuation">.</span><span class="token function">addToDisplay</span><span class="token punctuation">(</span>mWindow<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//WindowManagerService会创建mWindow对应的WindowState</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>即在向<code>WindowManagerService</code>请求创建<code>WindowState</code>之前，调用了<code>requestLayout()</code>,这个方法会引起<code>ViewRootImpl</code>所管理的整个view tree的重新渲染。它最终会调用到<code>scheduleTraversals()</code>:</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">scheduleTraversals</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    mChoreographer<span class="token punctuation">.</span><span class="token function">postCallback</span><span class="token punctuation">(</span>Choreographer<span class="token punctuation">.</span>CALLBACK_TRAVERSAL<span class="token punctuation">,</span> mTraversalRunnable<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>对于<code>Choreographer</code>本文不做详细的分析，可以去参考 <a href="https://www.jianshu.com/p/996bca12eb1d" target="_blank" rel="noopener">Android Choreographer 源码分析</a>的分析来了解这个类。</p>
<p><code>scheduleTraversals()</code>会通过<code>Choreographer</code>来post一个<code>mTraversalRunnable</code>，<code>Choreographer</code>接收显示系统的时间脉冲(垂直同步信号-VSync信号，16ms发出一次)，在下一个frame渲染时控制执行这个<code>mTraversalRunnable</code>。</p>
<p>但是<code>mTraversalRunnable</code>的执行至少要在应用程序与<code>SurfaceFlinger</code>建立连接之后。这是因为渲染操作是由<code>SurfaceFlinger</code>负责调度了，如果应用程序还没有与<code>SurfaceFlinger</code>创建连接，那<code>SurfaceFlinger</code>当然不会渲染这个应用程序。所以在执行完<code>mWindowSession.addToDisplay(mWindow, ...)</code>之后，才会执行<code>mTraversalRunnable</code>:</p>
<blockquote>
<p>ViewRootImpl.java</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TraversalRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">doTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><code>doTraversal()</code>会调用到<code>ViewRootImpl.performTraversals()</code>,大部分同学可能知道这个方法是一个<code>view tree</code>的<code>measure/layout/draw</code>的控制方法:</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">performTraversals</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    finalView host <span class="token operator">=</span> mView<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//mView是一个Window的根View，对于Activity来说就是DecorView</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">relayoutWindow</span><span class="token punctuation">(</span><span class="token keyword">params</span><span class="token punctuation">,</span> viewVisibility<span class="token punctuation">,</span> insetsPending<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">performMeasure</span><span class="token punctuation">(</span>childWidthMeasureSpec<span class="token punctuation">,</span> childHeightMeasureSpec<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         
    <span class="token function">performLayout</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> mWidth<span class="token punctuation">,</span> mHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">performDraw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p><code>Surface</code>的具体创建就由<code>relayoutWindow(params, viewVisibility, insetsPending)</code>这个方法来完成的。这个方法会通过<code>IPC</code>调用到<code>WindowManagerService.relayoutWindow()</code>:</p>
<blockquote>
<p>ViewRootImpl.java</p>
</blockquote>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">relayoutWindow</span><span class="token punctuation">(</span>WindowManager<span class="token punctuation">.</span>LayoutParams <span class="token keyword">params</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> throws RemoteException <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">int</span> relayoutResult <span class="token operator">=</span> mWindowSession<span class="token punctuation">.</span><span class="token function">relayout</span><span class="token punctuation">(</span>mWindow<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> mSurface<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>上面我省略了<code>mWindowSession.relayout()</code>方法的很多参数，不过有一个十分重要的参数我没有省略，就是<code>mSurface</code>。前面已经分析了它就是一个空的<code>Surface</code>对象。其实:</p>
<p><strong>真正的Surface创建是由SurfaceControl完成的，应用程序ViewRootImpl的Surface只是一个指针，指向这个Surface</strong></p>
<p>下面就来看一下<code>SurfaceControl</code>是如何创建<code>Surface</code>的:</p>
<p><code>mWindowSession.relayout()</code>会调用到<code>WindowManagerService.relayoutWindow()</code>:</p>
<blockquote>
<p>WindowManagerService.java</p>
</blockquote>
<pre class=" language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//这里的outSurface其实就是ViewRootImpl中的那个Surface</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">relayoutWindow</span><span class="token punctuation">(</span>Session session<span class="token punctuation">,</span> IWindow client<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Surface outSurface<span class="token punctuation">)</span><span class="token punctuation">{</span> 
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    result <span class="token operator">=</span> <span class="token function">createSurfaceControl</span><span class="token punctuation">(</span>outSurface<span class="token punctuation">,</span> result<span class="token punctuation">,</span> win<span class="token punctuation">,</span> winAnimator<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">createSurfaceControl</span><span class="token punctuation">(</span>Surface outSurface<span class="token punctuation">,</span> <span class="token keyword">int</span> result<span class="token punctuation">,</span> WindowState win<span class="token punctuation">,</span>WindowStateAnimator winAnimator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    surfaceController <span class="token operator">=</span> winAnimator<span class="token punctuation">.</span><span class="token function">createSurfaceLocked</span><span class="token punctuation">(</span>win<span class="token punctuation">.</span>mAttrs<span class="token punctuation">.</span>type<span class="token punctuation">,</span> win<span class="token punctuation">.</span>mOwnerUid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    surfaceController<span class="token punctuation">.</span><span class="token function">getSurface</span><span class="token punctuation">(</span>outSurface<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><code>winAnimator.createSurfaceLocked</code>实际上是创建了一个<code>SurfaceControl</code>。即上面是先构造<code>SurfaceControl</code>，然后在构造<code>Surface</code>。</p>
<h5 id="SurfaceControl的创建"><a href="#SurfaceControl的创建" class="headerlink" title="SurfaceControl的创建"></a>SurfaceControl的创建</h5><p><code>winAnimator.createSurfaceLocked</code>其实是通过<code>SurfaceControl</code>的构造函数创建了一个<code>SurfaceControl</code>对象,这个对象的作用其实就是负责维护<code>Surface</code>,<code>Surface</code>其实也是由这个对象负责创建的，我们看一下这个对象的构造方法:</p>
<blockquote>
<p>SurfaceControl.java</p>
</blockquote>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">long</span> mNativeObject<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//成员指针变量，指向native创建的SurfaceControl</span>

<span class="token keyword">private</span> <span class="token function">SurfaceControl</span><span class="token punctuation">(</span>SurfaceSession session<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> format<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>
            SurfaceControl parent<span class="token punctuation">,</span> <span class="token keyword">int</span> windowType<span class="token punctuation">,</span> <span class="token keyword">int</span> ownerUid<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    mNativeObject <span class="token operator">=</span> <span class="token function">nativeCreate</span><span class="token punctuation">(</span>session<span class="token punctuation">,</span> name<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> flags<span class="token punctuation">,</span>
        parent <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> parent<span class="token punctuation">.</span>mNativeObject <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> windowType<span class="token punctuation">,</span> ownerUid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>即调用了<code>nativeCreate()</code>并返回一个<code>SurfaceControl</code>指针:</p>
<blockquote>
<p>android_view_SurfaceControl.cpp</p>
</blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">static</span> jlong <span class="token function">nativeCreate</span><span class="token punctuation">(</span>JNIEnv<span class="token operator">*</span> env<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//这个client其实就是前面创建的SurfaceComposerClinent</span>
    sp<span class="token operator">&lt;</span>SurfaceComposerClient<span class="token operator">></span> <span class="token function">client</span><span class="token punctuation">(</span><span class="token function">android_view_SurfaceSession_getClient</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> sessionObj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    sp<span class="token operator">&lt;</span>SurfaceControl<span class="token operator">></span> surface<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建成功之后，这个指针会指向新创建的SurfaceControl</span>
    status_t err <span class="token operator">=</span> client<span class="token operator">-</span><span class="token operator">></span><span class="token function">createSurfaceChecked</span><span class="token punctuation">(</span><span class="token function">String8</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> <span class="token operator">&amp;</span>surface<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> windowType<span class="token punctuation">,</span> ownerUid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>jlong<span class="token operator">></span><span class="token punctuation">(</span>surface<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回这个SurfaceControl的地址</span>
<span class="token punctuation">}</span></code></pre>
<p>即调用到<code>SurfaceComposerClient.createSurfaceChecked()</code>:</p>
<blockquote>
<p>SurfaceComposerClient.cpp</p>
</blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//outSurface会指向新创建的SurfaceControl</span>
status_t SurfaceComposerClient<span class="token operator">::</span><span class="token function">createSurfaceChecked</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>sp<span class="token operator">&lt;</span>SurfaceControl<span class="token operator">></span><span class="token operator">*</span> outSurface<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">></span> gbp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这个对象很重要</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    err <span class="token operator">=</span> mClient<span class="token operator">-</span><span class="token operator">></span><span class="token function">createSurface</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> parentHandle<span class="token punctuation">,</span> windowType<span class="token punctuation">,</span> ownerUid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>handle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>gbp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//SurfaceControl创建成功, 指针赋值</span>
        <span class="token operator">*</span>outSurface <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">SurfaceControl</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> handle<span class="token punctuation">,</span> gbp<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>上面这个方法实际上是调用<code>Client.createSurface()</code>来创建一个<code>Surface</code>。在创建时有一个很重要的参数<code>sp&lt;IGraphicBufferProducer&gt; gbp</code>,在下面源码分析中我们也要重点注意它。这是因为应用所渲染的每一帧，实际上都会添加到<code>IGraphicBufferProducer</code>中，来等待<code>SurfaceFlinger</code>的渲染。这个过程我们在下一篇文章中会分析，我们先继续来看一下<code>Surface</code>是如何被<code>Client</code>创建的:</p>
<blockquote>
<p>Client.cpp</p>
</blockquote>
<pre class=" language-cpp"><code class="language-cpp">status_t Client<span class="token operator">::</span><span class="token function">createSurface</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">//gbp 直接透传到了SurfaceFlinger</span>
    <span class="token keyword">return</span> mFlinger<span class="token operator">-</span><span class="token operator">></span><span class="token function">createLayer</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> windowType<span class="token punctuation">,</span> ownerUid<span class="token punctuation">,</span> handle<span class="token punctuation">,</span> gbp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>??? 不是说好的要创建<code>Surface</code>呢？怎么变成<code>mFlinger-&gt;createLayer()</code>? 额，我也不明白这个突然转变，不过我们只要知道:</p>
<p><strong>Surface在SurfaceFlinger中对应的实体其实是Layer</strong></p>
<p>我们继续看一下<code>mFlinger-&gt;createLayer()</code></p>
<blockquote>
<p>SurfaceFlinger.cpp</p>
</blockquote>
<pre class=" language-cpp"><code class="language-cpp">status_t SurfaceFlinger<span class="token operator">::</span><span class="token function">createLayer</span><span class="token punctuation">(</span><span class="token keyword">const</span> String8<span class="token operator">&amp;</span> name<span class="token punctuation">,</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>Client<span class="token operator">></span><span class="token operator">&amp;</span> client<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    status_t result <span class="token operator">=</span> NO_ERROR<span class="token punctuation">;</span>
    sp<span class="token operator">&lt;</span>Layer<span class="token operator">></span> layer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将要创建的layer</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> ISurfaceComposerClient<span class="token operator">::</span>eFXSurfaceMask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> ISurfaceComposerClient<span class="token operator">::</span>eFXSurfaceNormal<span class="token operator">:</span>
            result <span class="token operator">=</span> <span class="token function">createBufferLayer</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span>
                    uniqueName<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> format<span class="token punctuation">,</span>
                    handle<span class="token punctuation">,</span> gbp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>layer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意gbp，这时候还没有构造呢！</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//Layer 分为好几种，这里不全部列出</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    result <span class="token operator">=</span> <span class="token function">addClientLayer</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> <span class="token operator">*</span>handle<span class="token punctuation">,</span> <span class="token operator">*</span>gbp<span class="token punctuation">,</span> layer<span class="token punctuation">,</span> <span class="token operator">*</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这个layer和client相关联, 添加到Client的mLayers集合中。</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从<code>SurfaceFlinger.createLayer()</code>方法可以看出<code>Layer</code>分为好几种。我们这里只对普通的<code>BufferLayer</code>的创建做一下分析，看<code>createBufferLayer()</code>:</p>
<pre class=" language-cpp"><code class="language-cpp">status_t SurfaceFlinger<span class="token operator">::</span><span class="token function">createBufferLayer</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>Client<span class="token operator">></span><span class="token operator">&amp;</span> client<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> sp<span class="token operator">&lt;</span>Layer<span class="token operator">></span><span class="token operator">*</span> outLayer<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sp<span class="token operator">&lt;</span>BufferLayer<span class="token operator">></span> layer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">BufferLayer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> client<span class="token punctuation">,</span> name<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    status_t err <span class="token operator">=</span> layer<span class="token operator">-</span><span class="token operator">></span><span class="token function">setBuffers</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//设置layer的宽高</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>handle <span class="token operator">=</span> layer<span class="token operator">-</span><span class="token operator">></span><span class="token function">getHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建handle</span>
        <span class="token operator">*</span>gbp <span class="token operator">=</span> layer<span class="token operator">-</span><span class="token operator">></span><span class="token function">getProducer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建 gbp IGraphicBufferProducer</span>
        <span class="token operator">*</span>outLayer <span class="token operator">=</span> layer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把新建的layer的指针拷贝给outLayer,这样outLayer就指向了新建的BufferLayer</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>前面我说过<code>IGraphicBufferProducer(gbp)</code>是一个很重要的对象，它涉及到<code>SurfaceFlinger</code>的渲染逻辑，下面我们就看一下这个对象的创建逻辑:</p>
<h6 id="IGraphicBufferProducer-gbp-的创建"><a href="#IGraphicBufferProducer-gbp-的创建" class="headerlink" title="IGraphicBufferProducer(gbp)的创建"></a>IGraphicBufferProducer(gbp)的创建</h6><blockquote>
<p>BufferLayer.cpp</p>
</blockquote>
<pre class=" language-cpp"><code class="language-cpp">sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">></span> BufferLayer<span class="token operator">::</span><span class="token function">getProducer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> mProducer<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>即<code>mProducer</code>其实是<code>Layer</code>的成员变量，它的创建时机是<code>Layer</code>第一次被使用时:</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> BufferLayer<span class="token operator">::</span><span class="token function">onFirstRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    BufferQueue<span class="token operator">::</span><span class="token function">createBufferQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>producer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>consumer<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    mProducer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MonitoredProducer</span><span class="token punctuation">(</span>producer<span class="token punctuation">,</span> mFlinger<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>所以<code>mProducer</code>的实例是<code>MonitoredProducer</code>,但其实它只是一个装饰类，它实际功能都委托给构造它的参数<code>producer</code>:</p>
<blockquote>
<p>BufferQueue.cpp</p>
</blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> BufferQueue<span class="token operator">::</span><span class="token function">createBufferQueue</span><span class="token punctuation">(</span>sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">></span><span class="token operator">*</span> outProducer<span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">></span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">BufferQueueProducer</span><span class="token punctuation">(</span>core<span class="token punctuation">,</span> consumerIsSurfaceFlinger<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sp<span class="token operator">&lt;</span>IGraphicBufferConsumer<span class="token operator">></span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">BufferQueueConsumer</span><span class="token punctuation">(</span>core<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注意这个consumer</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token operator">*</span>outProducer <span class="token operator">=</span> producer<span class="token punctuation">;</span>
    <span class="token operator">*</span>outConsumer <span class="token operator">=</span> consumer<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>所以实际实现<code>mProducer</code>的工作的<code>queueProducer</code>是<code>BufferQueueProducer</code>。</p>
<p>所以构造一个<code>SurfaceControl</code>所做的工作就是创建了一个<code>SurfaceControl</code>,并让<code>SurfaceFlinger</code>创建了一个对应的<code>Layer</code>，<code>Layer</code>中有一个<code>IGraphicBufferProducer</code>,它的实例是<code>BufferQueueProducer</code>。</p>
<p>可以用下面这个图来描述<code>SurfaceControl</code>的创建过程:</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2934684-21fb8a495722870c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/889/format/webp" alt="img"></p>
<p>SurfaceControl的创建.png</p>
<h6 id="从SurfaceControl中获取Surface"><a href="#从SurfaceControl中获取Surface" class="headerlink" title="从SurfaceControl中获取Surface"></a>从SurfaceControl中获取Surface</h6><p>我们回看<code>WindowManagerService.createSurfaceControl()</code>， 来看一下java层的<code>Surface</code>对象到底是个什么:</p>
<blockquote>
<p>WindowManagerService.java</p>
</blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">createSurfaceControl</span><span class="token punctuation">(</span>Surface outSurface<span class="token punctuation">,</span> <span class="token keyword">int</span> result<span class="token punctuation">,</span> WindowState win<span class="token punctuation">,</span>WindowStateAnimator winAnimator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    surfaceController <span class="token operator">=</span> winAnimator<span class="token punctuation">.</span><span class="token function">createSurfaceLocked</span><span class="token punctuation">(</span>win<span class="token punctuation">.</span>mAttrs<span class="token punctuation">.</span>type<span class="token punctuation">,</span> win<span class="token punctuation">.</span>mOwnerUid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    surfaceController<span class="token punctuation">.</span><span class="token function">getSurface</span><span class="token punctuation">(</span>outSurface<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>上面我们已经了解了<code>winAnimator.createSurfaceLocked</code>的整个过程，我们看一下<code>surfaceController.getSurface(outSurface)</code>, <code>surfaceController</code>是<code>WindowSurfaceController</code>的实例:</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//WindowSurfaceController.java</span>
<span class="token keyword">void</span> <span class="token function">getSurface</span><span class="token punctuation">(</span>Surface outSurface<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    outSurface<span class="token punctuation">.</span><span class="token function">copyFrom</span><span class="token punctuation">(</span>mSurfaceControl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//Surface.java</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">copyFrom</span><span class="token punctuation">(</span>SurfaceControl other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">long</span> surfaceControlPtr <span class="token operator">=</span> other<span class="token punctuation">.</span>mNativeObject<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">long</span> newNativeObject <span class="token operator">=</span> <span class="token function">nativeGetFromSurfaceControl</span><span class="token punctuation">(</span>surfaceControlPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    mNativeObject <span class="token operator">=</span> ptr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// mNativeObject指向native创建的Surface</span>
<span class="token punctuation">}</span></code></pre>
<p>即<code>Surface.copyFrom()</code>方法调用<code>nativeGetFromSurfaceControl()</code>来获取一个指针，这个指针是根据前面创建的<code>SurfaceControl</code>的指针来寻找的，即传入的参数<code>surfaceControlPtr</code>:</p>
<blockquote>
<p>android_view_Surface.cpp</p>
</blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">static</span> jlong <span class="token function">nativeGetFromSurfaceControl</span><span class="token punctuation">(</span>JNIEnv<span class="token operator">*</span> env<span class="token punctuation">,</span> jclass <span class="token class-name">clazz</span><span class="token punctuation">,</span> jlong surfaceControlNativeObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sp<span class="token operator">&lt;</span>SurfaceControl<span class="token operator">></span> <span class="token function">ctrl</span><span class="token punctuation">(</span><span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>SurfaceControl <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>surfaceControlNativeObj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把java指针转化内native指针</span>
    sp<span class="token operator">&lt;</span>Surface<span class="token operator">></span> <span class="token function">surface</span><span class="token punctuation">(</span>ctrl<span class="token operator">-</span><span class="token operator">></span><span class="token function">getSurface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//直接构造一个Surface，指向 ctrl->getSurface()</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>surface <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        surface<span class="token operator">-</span><span class="token operator">></span><span class="token function">incStrong</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sRefBaseOwner<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//强引用</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>jlong<span class="token operator">></span><span class="token punctuation">(</span>surface<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这里的<code>ctrl</code>指向前面创建的<code>SurfaceControl</code>，继续追溯<code>ctrl-&gt;getSurface()</code>:</p>
<blockquote>
<p>SurfaceControl.cpp</p>
</blockquote>
<pre class=" language-cpp"><code class="language-cpp">sp<span class="token operator">&lt;</span>Surface<span class="token operator">></span> SurfaceControl<span class="token operator">::</span><span class="token function">getSurface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    Mutex<span class="token operator">::</span>Autolock <span class="token function">_l</span><span class="token punctuation">(</span>mLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mSurfaceData <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">generateSurfaceLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> mSurfaceData<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

sp<span class="token operator">&lt;</span>Surface<span class="token operator">></span> SurfaceControl<span class="token operator">::</span><span class="token function">generateSurfaceLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//这个mGraphicBufferProducer其实就是上面分析的BufferQueueProducer</span>
    mSurfaceData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Surface</span><span class="token punctuation">(</span>mGraphicBufferProducer<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">return</span> mSurfaceData<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>即直接new了一个<code>nativie的Surface</code>返回给java层，<code>java层的Surface</code>指向的就是<code>native层的Surface</code>。</p>
<p>所以<code>Surface</code>的实际创建可以用下图表示:</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2934684-6a4f3b80766d1547.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/586/format/webp" alt="img"></p>
<p>Surface的创建.png</p>
<p>经过上面这个图，也可以理解<code>SurfaceControl</code>为什么叫<code>SurfaceControl</code>了。</p>
<h2 id="app侧硬件加速绘制surface流程"><a href="#app侧硬件加速绘制surface流程" class="headerlink" title="app侧硬件加速绘制surface流程"></a>app侧硬件加速绘制surface流程</h2><p>Android4.0之后，系统默认开启硬件加速来渲染视图，通过GPU处理数据，OpenGL主要处理的任务有Surface的composition及图形图像的渲染，本篇文章简单说一下后半部分的模型，这部分对于理解View渲染也有不少帮助，也能更好的帮助理解GPU渲染玄学曲线。</p>
<p>不过这里有个概念要先弄清，OpenGL仅仅是提供标准的API及调用规则，在不同的硬件平台上有不同的实现，比如驱动等，这部分代码一般是不开源，本文主要基于Android libagl（6.0），它是Android中通过软件方法实现的一套OpenGL动态库，并结合Systrace真机上的调用栈，对比两者区别（GPU厂商提供的硬件实现的OpenGL），猜测libhgl（硬件OpenGL）的实现。对于Android APP而言，基于GPU的硬件加速绘制可以分为如下几个阶段：</p>
<ul>
<li>第一阶段：APP在UI线程构建OpenGL渲染需要的命令及数据</li>
<li>第二阶段：CPU将数据上传（共享或者拷贝）给GPU，PC上一般有显存一说，但是ARM这种嵌入式设备内存一般是GPU、CPU共享内存</li>
<li>第三阶段：通知GPU渲染，一般而言，真机不会阻塞等待GPU渲染结束，效率低，CPU通知结束后就返回继续执行其他任务，当然，理论上也可以阻塞执行，glFinish就能满足这样的需求（<strong>不同GPU厂商实现不同，Android源码自带的是软件实现的，只具有参考意义</strong>）（Fence机制辅助GPU CPU同步）</li>
<li>第四阶段：swapBuffers，并通知SurfaceFlinger图层合成</li>
<li>第五阶段：SurfaceFlinger开始合成图层，如果之前提交的GPU渲染任务没结束，则等待GPU渲染完成，再合成（Fence机制），合成依然是依赖GPU，不过这就是下一个任务了</li>
</ul>
<p>第一个阶段，其实主要做的就是构建DrawOp树（里面封装OpenGL渲染命令），同时，预处理分组一些相似命令，以便提高GPU处理效率，这个阶段主要是CPU在工作，不过这个阶段前期运行在UI线程，后期部分运行在RenderThread（渲染线程），第二个阶段主要运行在渲染线程，CPU将数据同步（共享）给GPU，之后，通知GPU进行渲染，不过这里需要注意的是，CPU一般不会阻塞等待GPU渲染完毕，而是通知结束后就返回，除非GPU非常繁忙，来不及响应CPU的请求，没有给CPU发送通知，CPU才会阻塞等待。CPU返回后，会直接将GraphicBuffer提交给SurfaceFlinger，告诉SurfaceFlinger进行合成，但是这个时候GPU可能并未完成图像的渲染，这个时候就牵扯到一个同步，Android中，这里用的是Fence机制，SurfaceFlinger合成前会查询这个Fence，如果GPU渲染没有结束，则等待GPU渲染结束，GPU结束后，会通知SurfaceFlinger进行合成，SF合成后，提交显示，如此完成图像的渲染显示，简单画下示意图：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1460468-b4cf44398e5d221c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>Android CPU GPU通信模型</p>
<p>之前已经简单分析过DrawOp树的构建，优化，本文主要是分析GPU如何完成OpenGL渲染，这个过程主要在Render线程，通过OpenGL API通知GPU处理渲染任务。</p>
<h3 id="Android-OpenGL环境的初始化"><a href="#Android-OpenGL环境的初始化" class="headerlink" title="Android OpenGL环境的初始化"></a>Android OpenGL环境的初始化</h3><p>一般在使用OpenGL的时候，首先需要获取OpenGL相应的配置，再为其构建渲染环境，比如必须创建OpenGL上下文(Context)，上下文可以看做是OpenGL的化身，没有上下文就没有OpenGL环境，同时还要构建一个用于绘图的画布GlSurface，在Android中抽象出来就是EglContext与EglSurface，示例如下：</p>
<pre class=" language-jsx"><code class="language-jsx">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">initGL</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        mEgl <span class="token operator">=</span> <span class="token punctuation">(</span>EGL10<span class="token punctuation">)</span> EGLContext<span class="token punctuation">.</span><span class="token function">getEGL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>获取display显示目标<span class="token operator">--</span><span class="token operator">></span>
        mEglDisplay <span class="token operator">=</span> mEgl<span class="token punctuation">.</span><span class="token function">eglGetDisplay</span><span class="token punctuation">(</span>EGL10<span class="token punctuation">.</span>EGL_DEFAULT_DISPLAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>构建配置<span class="token operator">--</span><span class="token operator">></span>
        mEglConfig <span class="token operator">=</span> <span class="token function">chooseEglConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>构建上下文<span class="token operator">--</span><span class="token operator">></span>
        mEglContext <span class="token operator">=</span> <span class="token function">createContext</span><span class="token punctuation">(</span>mEgl<span class="token punctuation">,</span> mEglDisplay<span class="token punctuation">,</span> mEglConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>构建绘图Surface<span class="token operator">--</span><span class="token operator">></span>
        mEglSurface <span class="token operator">=</span> mEgl<span class="token punctuation">.</span><span class="token function">eglCreateWindowSurface</span><span class="token punctuation">(</span>mEglDisplay<span class="token punctuation">,</span> mEglConfig<span class="token punctuation">,</span> mSurface<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span></code></pre>
<p>Android系统中，APP端如何为每个窗口配置OpenGL环境的，在一个窗口被添加到窗口的时候会调用其ViewRootImpl对象的setView：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setView</span><span class="token punctuation">(</span>View view<span class="token punctuation">,</span> WindowManager<span class="token punctuation">.</span>LayoutParams attrs<span class="token punctuation">,</span> View panelParentView<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                <span class="token function">enableHardwareAcceleration</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span></code></pre>
<p>setView会调用enableHardwareAcceleration，配置OpenGL的硬件加速环境：</p>
<pre class=" language-xml"><code class="language-xml">private void enableHardwareAcceleration(WindowManager.LayoutParams attrs) {
        mAttachInfo.mHardwareAccelerated = false;
        mAttachInfo.mHardwareAccelerationRequested = false;
            ...
        final boolean hardwareAccelerated =
                (attrs.flags &amp; WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED) != 0;

        if (hardwareAccelerated) {
        <span class="token comment" spellcheck="true">&lt;!--可以开启硬件加速 ，一般都是true--></span>
            if (!HardwareRenderer.isAvailable()) {
                return;
            }
                    ...
                <span class="token comment" spellcheck="true">&lt;!--创建硬件加速环境--></span>
                mAttachInfo.mHardwareRenderer = HardwareRenderer.create(mContext, translucent);
                if (mAttachInfo.mHardwareRenderer != null) {
                    mAttachInfo.mHardwareRenderer.setName(attrs.getTitle().toString());
                    mAttachInfo.mHardwareAccelerated =
                            mAttachInfo.mHardwareAccelerationRequested = true;
                }
            }
        }
    }</code></pre>
<p>Android中每个显示的Window（Activity、Dialog、PopupWindow等）都对应一个ViewRootImpl对象，也会对应一个AttachInfo对象，之后通过</p>
<pre class=" language-css"><code class="language-css">HardwareRenderer<span class="token number">.</span><span class="token function">create</span><span class="token punctuation">(</span>mContext, translucent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>创建的HardwareRenderer对象就被保存在ViewRootImpl的AttachInfo中，跟Window是一对一的关系，通过HardwareRenderer.create(mContext, translucent)创建硬件加速环境后，在需要draw绘制的时候，通过：</p>
<pre class=" language-css"><code class="language-css">    mAttachInfo<span class="token number">.</span>mHardwareRenderer<span class="token number">.</span><span class="token function">draw</span><span class="token punctuation">(</span>mView, mAttachInfo, this<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>进一步渲染。回过头，接着看APP如何初始化硬件加速环境：<strong>直观上说，主要是构建OpenGLContext、EglSurface、RenderThread(如果没启动的话)</strong>。</p>
<pre class=" language-xml"><code class="language-xml">static HardwareRenderer create(Context context, boolean translucent) {
    HardwareRenderer renderer = null;
    if (DisplayListCanvas.isAvailable()) {
        renderer = new ThreadedRenderer(context, translucent);
    }
    return renderer;
}

ThreadedRenderer(Context context, boolean translucent) {
    final TypedArray a = context.obtainStyledAttributes(null, R.styleable.Lighting, 0, 0);
    ...
    <span class="token comment" spellcheck="true">&lt;!--创建rootnode--></span>
    long rootNodePtr = nCreateRootRenderNode();
    mRootNode = RenderNode.adopt(rootNodePtr);
   <span class="token comment" spellcheck="true">&lt;!--创建native ThreadProxy--></span>
    mNativeProxy = nCreateProxy(translucent, rootNodePtr);
    <span class="token comment" spellcheck="true">&lt;!--初始化AssetAtlas,本文不分析--></span>
    ProcessInitializer.sInstance.init(context, mNativeProxy);
    ...
}</code></pre>
<p>之前分析过，nCreateRootRenderNode 为ViewRootimpl创建一个root RenderNode，UI线程通过递归mRootNode，可以构建ViewTree所有的OpenGL绘制命令及数据，nCreateProxy会为当前widow创建一个ThreadProxy ，ThreadProxy则主要用来向RenderThread线程提交一些OpenGL相关任务，比如初始化，绘制、更新等：</p>
<pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">ANDROID_API</span> RenderProxy <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ANDROID_API <span class="token function">RenderProxy</span><span class="token punctuation">(</span><span class="token keyword">bool</span> translucent<span class="token punctuation">,</span> RenderNode<span class="token operator">*</span> rootNode<span class="token punctuation">,</span> IContextFactory<span class="token operator">*</span> contextFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ANDROID_API <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">RenderProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ANDROID_API <span class="token keyword">bool</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>ANativeWindow<span class="token operator">></span><span class="token operator">&amp;</span> window<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ANDROID_API <span class="token keyword">int</span> <span class="token function">syncAndDrawFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ANDROID_API DeferredLayerUpdater<span class="token operator">*</span> <span class="token function">createTextureLayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ANDROID_API <span class="token keyword">void</span> <span class="token function">buildLayer</span><span class="token punctuation">(</span>RenderNode<span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ANDROID_API <span class="token keyword">bool</span> <span class="token function">copyLayerInto</span><span class="token punctuation">(</span>DeferredLayerUpdater<span class="token operator">*</span> layer<span class="token punctuation">,</span> SkBitmap<span class="token operator">&amp;</span> bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ANDROID_API <span class="token keyword">void</span> <span class="token function">fence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">destroyContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">post</span><span class="token punctuation">(</span>RenderTask<span class="token operator">*</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">postAndWait</span><span class="token punctuation">(</span>MethodInvokeRenderTask<span class="token operator">*</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>RenderProxy的在创建之初会做什么？其实主要两件事，第一：如果RenderThread未启动，则启动它，第二：向RenderThread提交第一个Task–为当前窗口创建CanvasContext，CanvasContext有点EglContext的意味，所有的绘制命令都会通过CanvasContext进行中转：</p>
<pre class=" language-xml"><code class="language-xml">RenderProxy::RenderProxy(bool translucent, RenderNode* rootRenderNode, IContextFactory* contextFactory)
        : mRenderThread(RenderThread::getInstance())
        , mContext(nullptr) {
     <span class="token comment" spellcheck="true">&lt;!--创建CanvasContext--></span>
    SETUP_TASK(createContext);
    args->translucent = translucent;
    args->rootRenderNode = rootRenderNode;
    args->thread = &amp;mRenderThread;
    args->contextFactory = contextFactory;
    mContext = (CanvasContext*) postAndWait(task);
    <span class="token comment" spellcheck="true">&lt;!--初始化DrawFrameTask--></span>
    mDrawFrameTask.setContext(&amp;mRenderThread, mContext);
}</code></pre>
<p>从其构造函数中可以看出，OpenGL Render线程是一个单例，同一个进程只有一个RenderThread，RenderProxy 通过mRenderThread引用该单例，将来需要提交任务的时候，直接通过该引用向RenderThread的Queue中插入消息，而RenderThread主要负责从Queue取出消息，并执行，比如将OpenGL命令issue提交给GPU，并通知GPU渲染。在Android Profile的CPU工具中可以清楚的看到该线程的存在（没有显示任务的进程是没有的：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1460468-265afedca9d749a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/509/format/webp" alt="img"></p>
<p>renderThread</p>
<p>简单看下RenderThread()这个单例线程的创建与启动，</p>
<pre class=" language-cpp"><code class="language-cpp">RenderThread<span class="token operator">::</span><span class="token function">RenderThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Singleton<span class="token operator">&lt;</span>RenderThread<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mNextWakeup</span><span class="token punctuation">(</span>LLONG_MAX<span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mDisplayEventReceiver</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mVsyncRequested</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mFrameCallbackTaskPending</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mFrameCallbackTask</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mRenderState</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mEglManager</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Properties<span class="token operator">::</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mFrameCallbackTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">DispatchFrameCallbacks</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mLooper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Looper</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token string">"RenderThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>RenderThread会维护一个MessageQuene，并通过loop的方式读取消息，执行，RenderThread在启动之前，会为OpenGL创建EglManager、RenderState、VSync信号接收器（这个主要为了动画）等OpenGL渲染需要工具组件，之后启动该线程进入loop：</p>
<pre class=" language-xml"><code class="language-xml">bool RenderThread::threadLoop() {

    <span class="token comment" spellcheck="true">&lt;!--初始化--></span>
    setpriority(PRIO_PROCESS, 0, PRIORITY_DISPLAY);
    initThreadLocals();

    int timeoutMillis = -1;
    for (;;) {
    <span class="token comment" spellcheck="true">&lt;!--等待消息队列不为空--></span>
        int result = mLooper->pollOnce(timeoutMillis);
        nsecs_t nextWakeup;
        // Process our queue, if we have anything
        <span class="token comment" spellcheck="true">&lt;!--获取消息并执行--></span>
        while (RenderTask* task = nextTask(&amp;nextWakeup)) {
            task->run();
        }
        ... 
    return false;}</code></pre>
<p>初始化，主要是创建EglContext中必须的一些组件，到这里其实都是工具的创建，基本上还没构建OpenGL需要的任何实质性的东西</p>
<pre class=" language-xml"><code class="language-xml">     void RenderThread::initThreadLocals() {
    sp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>IBinder</span><span class="token punctuation">></span></span> dtoken(SurfaceComposerClient::getBuiltInDisplay(
            ISurfaceComposer::eDisplayIdMain));
    status_t status = SurfaceComposerClient::getDisplayInfo(dtoken, &amp;mDisplayInfo);
    nsecs_t frameIntervalNanos = static_cast<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nsecs_t</span><span class="token punctuation">></span></span>(1000000000 / mDisplayInfo.fps);
    mTimeLord.setFrameInterval(frameIntervalNanos);
    <span class="token comment" spellcheck="true">&lt;!--初始化vsync接收器--></span>
    initializeDisplayEventReceiver();
    <span class="token comment" spellcheck="true">&lt;!--管家--></span>
    mEglManager = new EglManager(*this);
    <span class="token comment" spellcheck="true">&lt;!--状态机--></span>
    mRenderState = new RenderState(*this);
    <span class="token comment" spellcheck="true">&lt;!--debug分析工具--></span>
    mJankTracker = new JankTracker(frameIntervalNanos);
}</code></pre>
<p>Android5.0之后，有些动画是可以完全在RenderThread完成的，这个时候render渲染线程需要接受Vsync，等信号到来后，回调RenderThread::displayEventReceiverCallback，计算当前动画状态，最后调用doFrame绘制当前动画帧（不详述），有时间可以看下Vsync机制</p>
<pre class=" language-php"><code class="language-php">void RenderThread<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">initializeDisplayEventReceiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mDisplayEventReceiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DisplayEventReceiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    status_t status <span class="token operator">=</span> mDisplayEventReceiver<span class="token operator">-</span><span class="token operator">></span><span class="token function">initCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mLooper<span class="token operator">-</span><span class="token operator">></span><span class="token function">addFd</span><span class="token punctuation">(</span>mDisplayEventReceiver<span class="token operator">-</span><span class="token operator">></span><span class="token function">getFd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
            Looper<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">EVENT_INPUT</span><span class="token punctuation">,</span> RenderThread<span class="token punctuation">:</span><span class="token punctuation">:</span>displayEventReceiverCallback<span class="token punctuation">,</span> this<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>其次RenderThread需要new一个EglManager及RenderState，两者跟上面的DisplayEventReceiver都从属RenderThread，因此在一个进程中，也是单例的</p>
<pre class=" language-cpp"><code class="language-cpp">EglManager<span class="token operator">::</span><span class="token function">EglManager</span><span class="token punctuation">(</span>RenderThread<span class="token operator">&amp;</span> thread<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">mRenderThread</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mEglDisplay</span><span class="token punctuation">(</span>EGL_NO_DISPLAY<span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mEglConfig</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mEglContext</span><span class="token punctuation">(</span>EGL_NO_CONTEXT<span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mPBufferSurface</span><span class="token punctuation">(</span>EGL_NO_SURFACE<span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mAllowPreserveBuffer</span><span class="token punctuation">(</span><span class="token function">load_dirty_regions_property</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mCurrentSurface</span><span class="token punctuation">(</span>EGL_NO_SURFACE<span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mAtlasMap</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mAtlasMapSize</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mCanSetPreserveBuffer <span class="token operator">=</span> mAllowPreserveBuffer<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>EglManager主要作用是管理OpenGL上下文，比如创建EglSurface、指定当前操作的Surface、swapBuffers等，主要负责场景及节点的管理工作：</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">EglManager</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment" spellcheck="true">// Returns true on success, false on failure</span>
    <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    EGLSurface <span class="token function">createSurface</span><span class="token punctuation">(</span>EGLNativeWindowType window<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">destroySurface</span><span class="token punctuation">(</span>EGLSurface surface<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">bool</span> <span class="token function">isCurrent</span><span class="token punctuation">(</span>EGLSurface surface<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> mCurrentSurface <span class="token operator">==</span> surface<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// Returns true if the current surface changed, false if it was already current</span>
    <span class="token keyword">bool</span> <span class="token function">makeCurrent</span><span class="token punctuation">(</span>EGLSurface surface<span class="token punctuation">,</span> EGLint<span class="token operator">*</span> errOut <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">beginFrame</span><span class="token punctuation">(</span>EGLSurface surface<span class="token punctuation">,</span> EGLint<span class="token operator">*</span> width<span class="token punctuation">,</span> EGLint<span class="token operator">*</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> <span class="token function">swapBuffers</span><span class="token punctuation">(</span>EGLSurface surface<span class="token punctuation">,</span> <span class="token keyword">const</span> SkRect<span class="token operator">&amp;</span> dirty<span class="token punctuation">,</span> EGLint width<span class="token punctuation">,</span> EGLint height<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Returns true iff the surface is now preserving buffers.</span>
    <span class="token keyword">bool</span> <span class="token function">setPreserveBuffer</span><span class="token punctuation">(</span>EGLSurface surface<span class="token punctuation">,</span> <span class="token keyword">bool</span> preserve<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">setTextureAtlas</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>GraphicBuffer<span class="token operator">></span><span class="token operator">&amp;</span> buffer<span class="token punctuation">,</span> int64_t<span class="token operator">*</span> map<span class="token punctuation">,</span> size_t mapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">fence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">RenderThread</span><span class="token punctuation">;</span>

    <span class="token function">EglManager</span><span class="token punctuation">(</span>RenderThread<span class="token operator">&amp;</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// EglContext is never destroyed, method is purposely not implemented</span>
    <span class="token operator">~</span><span class="token function">EglManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">createPBufferSurface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">loadConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">initAtlas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    RenderThread<span class="token operator">&amp;</span> mRenderThread<span class="token punctuation">;</span>
    EGLDisplay mEglDisplay<span class="token punctuation">;</span>
    EGLConfig mEglConfig<span class="token punctuation">;</span>
    EGLContext mEglContext<span class="token punctuation">;</span>
    EGLSurface mPBufferSurface<span class="token punctuation">;</span>
    <span class="token punctuation">,</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>而RenderState可以看做是OpenGL状态机的具体呈现，真正负责OpenGL的渲染状态的维护及渲染命令的issue</p>
<pre class=" language-php"><code class="language-php">RenderState<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">RenderState</span><span class="token punctuation">(</span>renderthread<span class="token punctuation">:</span><span class="token punctuation">:</span>RenderThread<span class="token operator">&amp;</span> thread<span class="token punctuation">)</span>
        <span class="token punctuation">:</span> <span class="token function">mRenderThread</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mViewportWidth</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mViewportHeight</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mFramebuffer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mThreadId <span class="token operator">=</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>在RenderProxy创建之初，插入到的第一条消息就是SETUP_TASK(createContext)，构建CanvasContext ,它可以看做OpenGL的Context及Surface的封装，</p>
<pre class=" language-php"><code class="language-php"><span class="token function">CREATE_BRIDGE4</span><span class="token punctuation">(</span>createContext<span class="token punctuation">,</span> RenderThread<span class="token operator">*</span> thread<span class="token punctuation">,</span> bool translucent<span class="token punctuation">,</span>
        RenderNode<span class="token operator">*</span> rootRenderNode<span class="token punctuation">,</span> IContextFactory<span class="token operator">*</span> contextFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CanvasContext</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token operator">-</span><span class="token operator">></span><span class="token property">thread</span><span class="token punctuation">,</span> args<span class="token operator">-</span><span class="token operator">></span><span class="token property">translucent</span><span class="token punctuation">,</span>
            args<span class="token operator">-</span><span class="token operator">></span><span class="token property">rootRenderNode</span><span class="token punctuation">,</span> args<span class="token operator">-</span><span class="token operator">></span><span class="token property">contextFactory</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>可以看到，CanvasContext同时握有RenderThread、EglManager、RootRenderNode等，它可以看做Android中OpenGL上下文，是上层渲染API的入口</p>
<pre class=" language-cpp"><code class="language-cpp">CanvasContext<span class="token operator">::</span><span class="token function">CanvasContext</span><span class="token punctuation">(</span>RenderThread<span class="token operator">&amp;</span> thread<span class="token punctuation">,</span> <span class="token keyword">bool</span> translucent<span class="token punctuation">,</span>
        RenderNode<span class="token operator">*</span> rootRenderNode<span class="token punctuation">,</span> IContextFactory<span class="token operator">*</span> contextFactory<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">mRenderThread</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mEglManager</span><span class="token punctuation">(</span>thread<span class="token punctuation">.</span><span class="token function">eglManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mOpaque</span><span class="token punctuation">(</span><span class="token operator">!</span>translucent<span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mAnimationContext</span><span class="token punctuation">(</span>contextFactory<span class="token operator">-</span><span class="token operator">></span><span class="token function">createAnimationContext</span><span class="token punctuation">(</span>mRenderThread<span class="token punctuation">.</span><span class="token function">timeLord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mRootRenderNode</span><span class="token punctuation">(</span>rootRenderNode<span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mJankTracker</span><span class="token punctuation">(</span>thread<span class="token punctuation">.</span><span class="token function">timeLord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">frameIntervalNanos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">mProfiler</span><span class="token punctuation">(</span>mFrames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mRenderThread<span class="token punctuation">.</span><span class="token function">renderState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerCanvasContext</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mProfiler<span class="token punctuation">.</span><span class="token function">setDensity</span><span class="token punctuation">(</span>mRenderThread<span class="token punctuation">.</span><span class="token function">mainDisplayInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>density<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>其实到这里初始化完成了一般，另一半是在draw的时候，进行的也就是ThreadRender的initialize，毕竟，如果不需要绘制，是不需要初始化OpenGL环境的，省的浪费资源：</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">performTraversals</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>mAttachInfo<span class="token punctuation">.</span>mHardwareRenderer <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">try</span> <span class="token punctuation">{</span>
                            hwInitialized <span class="token operator">=</span> mAttachInfo<span class="token punctuation">.</span>mHardwareRenderer<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span>mSurface<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这里的mSurface其实是已经被WMS填充处理过的一个Surface，它在native层对应一个ANativeWindow（其实就是个native的Surface），随着RenderProxy的initial的初始化，EglContext跟EglSurface会被进一步创建，需要注意的是这里的initialize任务是在Render线程，OpenGL的相关操作都必须在Render线程：</p>
<pre class=" language-dart"><code class="language-dart"><span class="token function">CREATE_BRIDGE2</span><span class="token punctuation">(</span>initialize<span class="token punctuation">,</span> CanvasContext<span class="token operator">*</span> context<span class="token punctuation">,</span> ANativeWindow<span class="token operator">*</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> args<span class="token operator">-</span><span class="token operator">></span>context<span class="token operator">-</span><span class="token operator">></span><span class="token function">initialize</span><span class="token punctuation">(</span>args<span class="token operator">-</span><span class="token operator">></span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool RenderProxy<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>ANativeWindow<span class="token operator">></span><span class="token operator">&amp;</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SETUP_TASK</span><span class="token punctuation">(</span>initialize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    args<span class="token operator">-</span><span class="token operator">></span>context <span class="token operator">=</span> mContext<span class="token punctuation">;</span>
    args<span class="token operator">-</span><span class="token operator">></span>window <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>bool<span class="token punctuation">)</span> <span class="token function">postAndWait</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool CanvasContext<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">initialize</span><span class="token punctuation">(</span>ANativeWindow<span class="token operator">*</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setSurface</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mCanvas<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    mCanvas <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OpenGLRenderer</span><span class="token punctuation">(</span>mRenderThread<span class="token punctuation">.</span><span class="token function">renderState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mCanvas<span class="token operator">-</span><span class="token operator">></span><span class="token function">initProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这里传入的ANativeWindow* window其实就是native的Surface，CanvasContext在初始化的时候，会通过setSurface为OpenGL创建E关联Con小text、EglSurface画布，同时会为当前窗口创建一个OpenGLRenderer，OpenGLRenderer主要用来处理之前构建的DrawOp，输出对应的OpenGL命令。</p>
<pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">void</span> CanvasContext<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">setSurface</span><span class="token punctuation">(</span>ANativeWindow<span class="token operator">*</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mNativeWindow <span class="token operator">=</span> window<span class="token punctuation">;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>创建EglSurface画布<span class="token operator">--</span><span class="token operator">></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mEglSurface <span class="token operator">=</span> mEglManager<span class="token punctuation">.</span><span class="token function">createSurface</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mEglSurface <span class="token operator">!=</span> EGL_NO_SURFACE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> bool preserveBuffer <span class="token operator">=</span> <span class="token punctuation">(</span>mSwapBehavior <span class="token operator">!=</span> kSwap_discardBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        mBufferPreserved <span class="token operator">=</span> mEglManager<span class="token punctuation">.</span><span class="token function">setPreserveBuffer</span><span class="token punctuation">(</span>mEglSurface<span class="token punctuation">,</span> preserveBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        mHaveNewSurface <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>绑定上下文<span class="token operator">--</span><span class="token operator">></span>
        <span class="token function">makeCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">}</span>

EGLSurface EglManager<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">createSurface</span><span class="token punctuation">(</span>EGLNativeWindowType window<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>构建EglContext<span class="token operator">--</span><span class="token operator">></span>
    <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>创建EglSurface<span class="token operator">--</span><span class="token operator">></span>
    EGLSurface surface <span class="token operator">=</span> <span class="token function">eglCreateWindowSurface</span><span class="token punctuation">(</span>mEglDisplay<span class="token punctuation">,</span> mEglConfig<span class="token punctuation">,</span> window<span class="token punctuation">,</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> surface<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> EglManager<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasEglContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

    mEglDisplay <span class="token operator">=</span> <span class="token function">eglGetDisplay</span><span class="token punctuation">(</span>EGL_DEFAULT_DISPLAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">loadConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">createPBufferSurface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">makeCurrent</span><span class="token punctuation">(</span>mPBufferSurface<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mRenderThread<span class="token punctuation">.</span><span class="token function">renderState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onGLContextCreated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">initAtlas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> EglManager<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    EGLint attribs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> EGL_CONTEXT_CLIENT_VERSION<span class="token punctuation">,</span> GLES_VERSION<span class="token punctuation">,</span> EGL_NONE <span class="token punctuation">}</span><span class="token punctuation">;</span>
    mEglContext <span class="token operator">=</span> <span class="token function">eglCreateContext</span><span class="token punctuation">(</span>mEglDisplay<span class="token punctuation">,</span> mEglConfig<span class="token punctuation">,</span> EGL_NO_CONTEXT<span class="token punctuation">,</span> attribs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">LOG_ALWAYS_FATAL_IF</span><span class="token punctuation">(</span>mEglContext <span class="token operator">==</span> EGL_NO_CONTEXT<span class="token punctuation">,</span>
        <span class="token string">"Failed to create context, error = %s"</span><span class="token punctuation">,</span> <span class="token function">egl_error_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>EglManager::initialize()之后EglContext、Config全都有了，之后通过eglCreateWindowSurface创建EglSurface,这里先调用eglApi.cpp 的eglCreateWindowSurface</p>
<pre class=" language-xml"><code class="language-xml">EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
                                    NativeWindowType window,
                                    const EGLint *attrib_list) {
        <span class="token comment" spellcheck="true">&lt;!--配置--></span>
        int result = native_window_api_connect(window, NATIVE_WINDOW_API_EGL);
        <span class="token comment" spellcheck="true">&lt;!--Android源码中，其实是调用egl.cpp的eglCreateWindowSurface，不过这一块软件模拟的跟真实硬件的应该差别不多--></span>    
        // Eglsurface里面是有Surface的引用的，同时swap的时候，是能通知consumer的
        EGLSurface surface = cnx->egl.eglCreateWindowSurface(
                iDpy, config, window, attrib_list);
        ... }</code></pre>
<blockquote>
<p>egl.cpp其实是软件模拟的GPU实现库，不过这里的eglCreateWindowSurface逻辑其实跟真实GPU平台的代码差别不大，因为只是抽象逻辑：</p>
</blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">static</span> EGLSurface <span class="token function">createWindowSurface</span><span class="token punctuation">(</span>EGLDisplay dpy<span class="token punctuation">,</span> EGLConfig config<span class="token punctuation">,</span>
        NativeWindowType window<span class="token punctuation">,</span> <span class="token keyword">const</span> EGLint<span class="token operator">*</span> <span class="token comment" spellcheck="true">/*attrib_list*/</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    egl_surface_t<span class="token operator">*</span> surface<span class="token punctuation">;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>其实返回的就是egl_window_surface_v2_t<span class="token operator">--</span><span class="token operator">></span>
    surface <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">egl_window_surface_v2_t</span><span class="token punctuation">(</span>dpy<span class="token punctuation">,</span> config<span class="token punctuation">,</span> depthFormat<span class="token punctuation">,</span>
            <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ANativeWindow<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token keyword">return</span> surface<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从上面代码可以看出，其实就是new了一个egl_window_surface_v2_t，它内部封装了一个ANativeWindow，由于EGLSurface是一个Void* 类型指针，因此egl_window_surface_v2_t型指针可以直接赋值给它，到这里初始化环境结束，OpenGL需要的渲染环境已经搭建完毕，等到View需要显示或者更新的时候，就会接着调用VieWrootImpl的draw去更新，注意这里，一个Render线程，默认一个EglContext，但是可以有多个EglSurface，用eglMakeCurrent切换绑定即可。也就是一个Window对应一个ViewRootImpl-&gt;一个AttachInfo-&gt;ThreadRender对象-&gt;ThreadProxy(RootRenderNode)-&gt;CanvasContext.cpp(DrawFrameTask、EglManager（<strong>单例复用</strong>）、EglSurface)-&gt;-&gt;RenderThread(<strong>单例复用</strong>)，对于APP而言，一般只会维持一个OpenGL渲染线程，当然，你也可以自己new一个独立的渲染线程，主动调用OpenGL API。简答类图如下</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1460468-6c1252ee03d0ef62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>image.png</p>
<p>上面工作结束后，OpenGL渲染环境就已经准备好，或者说RenderThread这个渲染线程已经配置好了渲染环境，接下来，UI线程像渲染线程发送渲染任务就行了。</p>
<h3 id="Android-OpenGL-GPU-渲染"><a href="#Android-OpenGL-GPU-渲染" class="headerlink" title="Android OpenGL GPU 渲染"></a>Android OpenGL GPU 渲染</h3><p>之前分析<a href="https://www.jianshu.com/p/40f660e17a73" target="_blank" rel="noopener">理解Android硬件加速的小白文</a>的时候，已经分析过，ViewRootImpl的draw是入口，会调用HardwareRender的draw，先构建DrawOp树，然后合并优化DrawOp，之后issue OpenGL命令到GPU，其中构建DrawOp的任务在UI线程，后面的任务都在Render线程</p>
<pre class=" language-xml"><code class="language-xml">@Override
void draw(View view, AttachInfo attachInfo, HardwareDrawCallbacks callbacks) {
   <span class="token comment" spellcheck="true">&lt;!--构建DrawOp Tree UI线程--></span>        
   updateRootDisplayList(view, callbacks);
   <span class="token comment" spellcheck="true">&lt;!--渲染 提交任务到render线程--></span>
    int syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);
    ...
}</code></pre>
<p>如上面代码所说updateRootDisplayList构建DrawOp树在UI线程，nSyncAndDrawFrame提交渲染任务到渲染线程，之前已经分析过构建流程，nSyncAndDrawFrame也简单分析了一些合并等操作，下面接着之前流程分析如何将OpenGL命令issue到GPU，这里有个同步问题，可能牵扯到UI线程的阻塞，先分析下同步</p>
<h4 id="SyncAndDrawFrame-同步"><a href="#SyncAndDrawFrame-同步" class="headerlink" title="SyncAndDrawFrame 同步"></a>SyncAndDrawFrame 同步</h4><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">static</span> int <span class="token function">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="token punctuation">(</span>JNIEnv<span class="token operator">*</span> env<span class="token punctuation">,</span> jobject clazz<span class="token punctuation">,</span>
        jlong proxyPtr<span class="token punctuation">,</span> jlongArray frameInfo<span class="token punctuation">,</span> jint frameInfoSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    RenderProxy<span class="token operator">*</span> proxy <span class="token operator">=</span> reinterpret_cast<span class="token operator">&lt;</span>RenderProxy<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>proxyPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    env<span class="token operator">-</span><span class="token operator">></span><span class="token function">GetLongArrayRegion</span><span class="token punctuation">(</span>frameInfo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> frameInfoSize<span class="token punctuation">,</span> proxy<span class="token operator">-</span><span class="token operator">></span><span class="token function">frameInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> proxy<span class="token operator">-</span><span class="token operator">></span><span class="token function">syncAndDrawFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

int DrawFrameTask<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">drawFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mSyncResult <span class="token operator">=</span> kSync_OK<span class="token punctuation">;</span>
    mSyncQueued <span class="token operator">=</span> <span class="token function">systemTime</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">postAndWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> mSyncResult<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> DrawFrameTask<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">postAndWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    AutoMutex <span class="token function">_lock</span><span class="token punctuation">(</span>mLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mRenderThread<span class="token operator">-</span><span class="token operator">></span><span class="token function">queue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>阻塞等待，同步资源<span class="token operator">--</span><span class="token operator">></span>
    mSignal<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>mLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> DrawFrameTask<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bool canUnblockUiThread<span class="token punctuation">;</span>
    bool canDrawThisFrame<span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        TreeInfo <span class="token function">info</span><span class="token punctuation">(</span>TreeInfo<span class="token punctuation">:</span><span class="token punctuation">:</span>MODE_FULL<span class="token punctuation">,</span> mRenderThread<span class="token operator">-</span><span class="token operator">></span><span class="token function">renderState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>同步操作，其实就是同步Java跟native中的构建DrawOp Tree、图层、图像资源<span class="token operator">--</span><span class="token operator">></span>
        canUnblockUiThread <span class="token operator">=</span> <span class="token function">syncFrameState</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
        canDrawThisFrame <span class="token operator">=</span> info<span class="token punctuation">.</span>out<span class="token punctuation">.</span>canDrawThisFrame<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// Grab a copy of everything we need</span>
    CanvasContext<span class="token operator">*</span> context <span class="token operator">=</span> mContext<span class="token punctuation">;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>如果同步完成，则可以返回<span class="token operator">--</span><span class="token operator">></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>canUnblockUiThread<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">unblockUiThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>绘制，提交OpenGL命令道GPU<span class="token operator">--</span><span class="token operator">></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">CC_LIKELY</span><span class="token punctuation">(</span>canDrawThisFrame<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        context<span class="token operator">-</span><span class="token operator">></span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>看看是否之前因为同步问题阻塞了UI线程，如果阻塞了，需要唤醒<span class="token operator">--</span><span class="token operator">></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>canUnblockUiThread<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">unblockUiThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>其实就是调用RenderProxy的syncAndDrawFrame，将DrawFrameTask插入RenderThread，并且阻塞等待RenderThread跟UI线程同步，如果同步成功，则UI线程唤醒，否则UI线程阻塞等待直到Render线程完成OpenGL命令的issue完毕。同步结束后，之后RenderThread才会开始处理GPU渲染相关工作，先看下同步：</p>
<pre class=" language-xml"><code class="language-xml">bool DrawFrameTask::syncFrameState(TreeInfo&amp; info) {
    int64_t vsync = mFrameInfo[static_cast<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>int</span><span class="token punctuation">></span></span>(FrameInfoIndex::Vsync)];
    mRenderThread->timeLord().vsyncReceived(vsync);
    mContext->makeCurrent();
    Caches::getInstance().textureCache.resetMarkInUse(mContext);

    <span class="token comment" spellcheck="true">&lt;!--关键点1，TextureView类处理，主要牵扯纹理--></span>
    for (size_t i = 0; i &lt; mLayers.size(); i++) {
        // 更新Layer 这里牵扯到图层数据的处理，可能还有拷贝，
        mContext->processLayerUpdate(mLayers[i].get());
    }
    mLayers.clear();
    <span class="token comment" spellcheck="true">&lt;!--关键点2 同步DrawOp Tree --></span>
    mContext->prepareTree(info, mFrameInfo, mSyncQueued);
     ...
    // If prepareTextures is false, we ran out of texture cache space
    return info.prepareTextures;
}</code></pre>
<p>当Window中的TextureView（目前只考虑系统API，好像就这么一个View，自定义除外）有更新时，需要从TextureView的SurfaceTexture中读取图形缓冲区，并且封装绑定成Open GL纹理，供GPU绘制使用，这里不详述，将来有机会分析TexutureView的时候再分析。第二步，是将UI线程中构建的DrawOpTree等信息同步到Render Thread中，因为之前通过ViewRootImpl再Java层调用构建的DisplayListData还没被真正赋值到RenderNode的mDisplayListData（最终用到的对象），只是被setStagingDisplayList暂存，因为中间可能有那种多次meausre、layout的，还有可能发生改变，暂存逻辑如下：</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">android_view_RenderNode_setDisplayListData</span><span class="token punctuation">(</span>JNIEnv<span class="token operator">*</span> env<span class="token punctuation">,</span>
        jobject clazz<span class="token punctuation">,</span> jlong renderNodePtr<span class="token punctuation">,</span> jlong newDataPtr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    RenderNode<span class="token operator">*</span> renderNode <span class="token operator">=</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>RenderNode<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>renderNodePtr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    DisplayListData<span class="token operator">*</span> newData <span class="token operator">=</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>DisplayListData<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>newDataPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    renderNode<span class="token operator">-</span><span class="token operator">></span><span class="token function">setStagingDisplayList</span><span class="token punctuation">(</span>newData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> RenderNode<span class="token operator">::</span><span class="token function">setStagingDisplayList</span><span class="token punctuation">(</span>DisplayListData<span class="token operator">*</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mNeedsDisplayListDataSync <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> mStagingDisplayListData<span class="token punctuation">;</span>
    mStagingDisplayListData <span class="token operator">=</span> data<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>View的DrawOpTree同步</p>
<pre class=" language-xml"><code class="language-xml">void CanvasContext::prepareTree(TreeInfo&amp; info, int64_t* uiFrameInfo, int64_t syncQueued) {
    mRenderThread.removeFrameCallback(this);

    if (!wasSkipped(mCurrentFrameInfo)) {
        mCurrentFrameInfo = &amp;mFrames.next();
    }

    <span class="token comment" spellcheck="true">&lt;!--同步Java层测绘信息到native，OpenGL玄学曲线的来源--></span>
    mCurrentFrameInfo->importUiThreadInfo(uiFrameInfo);
    mCurrentFrameInfo->set(FrameInfoIndex::SyncQueued) = syncQueued;
    <span class="token comment" spellcheck="true">&lt;!--一个计时节点--></span>
    mCurrentFrameInfo->markSyncStart();
        info.damageAccumulator = &amp;mDamageAccumulator;
    info.renderer = mCanvas;
    info.canvasContext = this;

    mAnimationContext->startFrame(info.mode);
    // mRootRenderNode递归遍历所有节点
    mRootRenderNode->prepareTree(info);
  ...</code></pre>
<p>通过递归遍历，mRootRenderNode可以检查所有的节点，</p>
<pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">void</span> RenderNode<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">prepareTree</span><span class="token punctuation">(</span>TreeInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bool functorsNeedLayer <span class="token operator">=</span> Properties<span class="token punctuation">:</span><span class="token punctuation">:</span>debugOverdraw<span class="token punctuation">;</span>
    <span class="token function">prepareTreeImpl</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> functorsNeedLayer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> RenderNode<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">prepareTreeImpl</span><span class="token punctuation">(</span>TreeInfo<span class="token operator">&amp;</span> info<span class="token punctuation">,</span> bool functorsNeedLayer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    info<span class="token punctuation">.</span>damageAccumulator<span class="token operator">-</span><span class="token operator">></span><span class="token function">pushTransform</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>info<span class="token punctuation">.</span>mode <span class="token operator">==</span> TreeInfo<span class="token punctuation">:</span><span class="token punctuation">:</span>MODE_FULL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 同步属性 </span>
        <span class="token function">pushStagingPropertiesChanges</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// layer</span>
    <span class="token function">prepareLayer</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> animatorDirtyMask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>同步DrawOpTree<span class="token operator">--</span><span class="token operator">></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>info<span class="token punctuation">.</span>mode <span class="token operator">==</span> TreeInfo<span class="token punctuation">:</span><span class="token punctuation">:</span>MODE_FULL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">pushStagingDisplayListChanges</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>递归处理子View<span class="token operator">--</span><span class="token operator">></span>
    <span class="token function">prepareSubTree</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> childFunctorsNeedLayer<span class="token punctuation">,</span> mDisplayListData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// push</span>
    <span class="token function">pushLayerUpdate</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
    info<span class="token punctuation">.</span>damageAccumulator<span class="token operator">-</span><span class="token operator">></span><span class="token function">popTransform</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>到这里同步的时候，基本就是最终结果，只要把mStagingDisplayListData赋值到mDisplayListData即可，</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> RenderNode<span class="token operator">::</span><span class="token function">pushStagingDisplayListChanges</span><span class="token punctuation">(</span>TreeInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mNeedsDisplayListDataSync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mNeedsDisplayListDataSync <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        mDisplayListData <span class="token operator">=</span> mStagingDisplayListData<span class="token punctuation">;</span>
        mStagingDisplayListData <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>mDisplayListData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mDisplayListData<span class="token operator">-</span><span class="token operator">></span>functors<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token punctuation">(</span><span class="token operator">*</span>mDisplayListData<span class="token operator">-</span><span class="token operator">></span>functors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DrawGlInfo<span class="token operator">::</span>kModeSync<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">damageSelf</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>之后通过递归遍历子View，便能够完成完成所有View的RenderNode的同步。</p>
<pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">void</span> RenderNode<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">prepareSubTree</span><span class="token punctuation">(</span>TreeInfo<span class="token operator">&amp;</span> info<span class="token punctuation">,</span> bool functorsNeedLayer<span class="token punctuation">,</span> DisplayListData<span class="token operator">*</span> subtree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>subtree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        TextureCache<span class="token operator">&amp;</span> cache <span class="token operator">=</span> Caches<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>textureCache<span class="token punctuation">;</span>
        info<span class="token punctuation">.</span>out<span class="token punctuation">.</span>hasFunctors <span class="token operator">|</span><span class="token operator">=</span> subtree<span class="token operator">-</span><span class="token operator">></span>functors<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>吧RenderNode用到的bitmap封装成纹理<span class="token operator">--</span><span class="token operator">></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> info<span class="token punctuation">.</span>prepareTextures <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> subtree<span class="token operator">-</span><span class="token operator">></span>bitmapResources<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            info<span class="token punctuation">.</span>prepareTextures <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">prefetchAndMarkInUse</span><span class="token punctuation">(</span>
                    info<span class="token punctuation">.</span>canvasContext<span class="token punctuation">,</span> subtree<span class="token operator">-</span><span class="token operator">></span>bitmapResources<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>递归子View<span class="token operator">--</span><span class="token operator">></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> subtree<span class="token operator">-</span><span class="token operator">></span><span class="token function">children</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">...</span>
            childNode<span class="token operator">-</span><span class="token operator">></span><span class="token function">prepareTreeImpl</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> childFunctorsNeedLayer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            info<span class="token punctuation">.</span>damageAccumulator<span class="token operator">-</span><span class="token operator">></span><span class="token function">popTransform</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>当DrawFrameTask::syncFrameState返回值(其实是TreeInfo的prepareTextures,这里主要是针对Bitmap的处理)为true时，表示同步完成，可以立刻唤醒UI线程，但是如果返回false，则就意UI中的数据没完全传输给GPU，这个情况下UI线程需要等待， 源码中有句注释 <strong>If prepareTextures is false, we ran out of texture cache space</strong>，其实就是说一个应用程序进程可以创建的Open GL纹理是有大小限制的，如果超出这个限制，纹理就会同步失败，看6.0代码，这个限制有Bitmap自身大小的限制，还有整体可用内存的限制，看代码中的限制</p>
<pre class=" language-php"><code class="language-php">Texture<span class="token operator">*</span> TextureCache<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getCachedTexture</span><span class="token punctuation">(</span><span class="token keyword">const</span> SkBitmap<span class="token operator">*</span> bitmap<span class="token punctuation">,</span> AtlasUsageType atlasUsageType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">CC_LIKELY</span><span class="token punctuation">(</span>mAssetAtlas <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> atlasUsageType <span class="token operator">==</span> AtlasUsageType<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">Use</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        AssetAtlas<span class="token punctuation">:</span><span class="token punctuation">:</span>Entry<span class="token operator">*</span> entry <span class="token operator">=</span> mAssetAtlas<span class="token operator">-</span><span class="token operator">></span><span class="token function">getEntry</span><span class="token punctuation">(</span>bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">CC_UNLIKELY</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> entry<span class="token operator">-</span><span class="token operator">></span><span class="token property">texture</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    Texture<span class="token operator">*</span> texture <span class="token operator">=</span> mCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">pixelRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getStableID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 没找到情况下</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>texture<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 判断单个限制</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">canMakeTextureFromBitmap</span><span class="token punctuation">(</span>bitmap<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">const</span> uint32_t size <span class="token operator">=</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">rowBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//</span>
        bool canCache <span class="token operator">=</span> size <span class="token operator">&lt;</span> mMaxSize<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// Don't even try to cache a bitmap that's bigger than the cache</span>
        <span class="token comment" spellcheck="true">// 剔除Lru算法中老的，不再用的，如果能够挪出空间，那就算成功，否则失败</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>canCache <span class="token operator">&amp;&amp;</span> mSize <span class="token operator">+</span> size <span class="token operator">></span> mMaxSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Texture<span class="token operator">*</span> oldest <span class="token operator">=</span> mCache<span class="token punctuation">.</span><span class="token function">peekOldestValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldest <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>oldest<span class="token operator">-</span><span class="token operator">></span><span class="token property">isInUse</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                mCache<span class="token punctuation">.</span><span class="token function">removeOldest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                canCache <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 如果能缓存，就新建一个Texture</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>canCache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            texture <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Texture</span><span class="token punctuation">(</span>Caches<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            texture<span class="token operator">-</span><span class="token operator">></span><span class="token property">bitmapSize</span> <span class="token operator">=</span> size<span class="token punctuation">;</span>
            <span class="token function">generateTexture</span><span class="token punctuation">(</span>bitmap<span class="token punctuation">,</span> texture<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            mSize <span class="token operator">+</span><span class="token operator">=</span> size<span class="token punctuation">;</span>
            <span class="token function">TEXTURE_LOGD</span><span class="token punctuation">(</span><span class="token string">"TextureCache::get: create texture(%p): name, size, mSize = %d, %d, %d"</span><span class="token punctuation">,</span>
                     bitmap<span class="token punctuation">,</span> texture<span class="token operator">-</span><span class="token operator">></span><span class="token property">id</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> mSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>mDebugEnabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">ALOGD</span><span class="token punctuation">(</span><span class="token string">"Texture created, size = %d"</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            mCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">pixelRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getStableID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> texture<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>texture<span class="token operator">-</span><span class="token operator">></span><span class="token property">isInUse</span> <span class="token operator">&amp;&amp;</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">getGenerationID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> texture<span class="token operator">-</span><span class="token operator">></span><span class="token property">generation</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// Texture was in the cache but is dirty, re-upload</span>
        <span class="token comment" spellcheck="true">// TODO: Re-adjust the cache size if the bitmap's dimensions have changed</span>
        <span class="token function">generateTexture</span><span class="token punctuation">(</span>bitmap<span class="token punctuation">,</span> texture<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> texture<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>先看单个Bitmap限制：</p>
<pre class=" language-rust"><code class="language-rust">bool TextureCache<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">canMakeTextureFromBitmap</span><span class="token punctuation">(</span><span class="token keyword">const</span> SkBitmap<span class="token operator">*</span> bitmap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>bitmap<span class="token punctuation">-></span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> mMaxTextureSize <span class="token operator">||</span> bitmap<span class="token punctuation">-></span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> mMaxTextureSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ALOGW</span><span class="token punctuation">(</span><span class="token string">"Bitmap too large to be uploaded into a texture (%dx%d, max=%dx%d)"</span><span class="token punctuation">,</span>
            bitmap<span class="token punctuation">-></span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bitmap<span class="token punctuation">-></span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mMaxTextureSize<span class="token punctuation">,</span> mMaxTextureSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>单个Bitmap大小限制基本上定义：</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> GL_MAX_TEXTURE_SIZE               0x0D33</span></code></pre>
<p>如果bitmap的宽高超过这个值，可能就会同步失败，再看第二个原因：超过能够Cache纹理总和上限：</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> DEFAULT_TEXTURE_CACHE_SIZE 24.0f 这里是24M</span></code></pre>
<p>如果空间足够，则直接新建一个Texture，如果不够，则根据Lru算法 ，剔除老的不再使用的Textrue，剔除后的空间如果够，则新建Texture，否则按失败处理，这里虽然说得是GPU Cache，其实还是在同一个内存中，<strong>归CPU管理的</strong>，<strong>不过由于对GPU不是太了解，不知道这个数值是不是跟GPU有关系</strong>，纹理在需要新建的前提下：</p>
<pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">void</span> TextureCache<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">generateTexture</span><span class="token punctuation">(</span><span class="token keyword">const</span> SkBitmap<span class="token operator">*</span> bitmap<span class="token punctuation">,</span> Texture<span class="token operator">*</span> texture<span class="token punctuation">,</span> bool regenerate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    SkAutoLockPixels <span class="token function">alp</span><span class="token punctuation">(</span><span class="token operator">*</span>bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>glGenTextures新建纹理<span class="token operator">--</span><span class="token operator">></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>regenerate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>texture<span class="token operator">-</span><span class="token operator">></span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    texture<span class="token operator">-</span><span class="token operator">></span>generation <span class="token operator">=</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">getGenerationID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    texture<span class="token operator">-</span><span class="token operator">></span>width <span class="token operator">=</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    texture<span class="token operator">-</span><span class="token operator">></span>height <span class="token operator">=</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>绑定纹理<span class="token operator">--</span><span class="token operator">></span>
    Caches<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">textureState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bindTexture</span><span class="token punctuation">(</span>texture<span class="token operator">-</span><span class="token operator">></span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">switch</span> <span class="token punctuation">(</span>bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">colorType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token keyword">case</span> kN32_SkColorType<span class="token punctuation">:</span>
     <span class="token comment" spellcheck="true">// 32位 RGBA 或者BGREA resize第一次都是true，因为一开始宽高肯定不一致</span>
        <span class="token function">uploadToTexture</span><span class="token punctuation">(</span>resize<span class="token punctuation">,</span> GL_RGBA<span class="token punctuation">,</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">rowBytesAsPixels</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">bytesPerPixel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                texture<span class="token operator">-</span><span class="token operator">></span>width<span class="token punctuation">,</span> texture<span class="token operator">-</span><span class="token operator">></span>height<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">getPixels</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span></code></pre>
<p>上面代码主要是新建纹理，然后为纹理绑定纹理图片资源，绑定资源代码如下：</p>
<pre class=" language-go"><code class="language-go">void TextureCache<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">uploadToTexture</span><span class="token punctuation">(</span><span class="token builtin">bool</span> resize<span class="token punctuation">,</span> GLenum format<span class="token punctuation">,</span> GLsizei stride<span class="token punctuation">,</span> GLsizei bpp<span class="token punctuation">,</span>
        GLsizei width<span class="token punctuation">,</span> GLsizei height<span class="token punctuation">,</span> GLenum <span class="token keyword">type</span><span class="token punctuation">,</span> <span class="token keyword">const</span> GLvoid <span class="token operator">*</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">glPixelStorei</span><span class="token punctuation">(</span>GL_UNPACK_ALIGNMENT<span class="token punctuation">,</span> bpp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token builtin">bool</span> useStride <span class="token operator">=</span> stride <span class="token operator">!=</span> width
            <span class="token operator">&amp;&amp;</span> Caches<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">extensions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasUnpackRowLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">...</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>resize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> format<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> format<span class="token punctuation">,</span> <span class="token keyword">type</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">glTexSubImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> format<span class="token punctuation">,</span> <span class="token keyword">type</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span></code></pre>
<p><strong>关键就是调用glTexImage2D将纹理图片跟纹理绑定，OpenGL的glTexImage2D一般会再次拷贝一次图片，之后，Bitmap就可以释放了，到这里就完成了纹理的上传这部分成功了，就算同步成功，UI线程可以不再阻塞</strong>。那么为什么同步失败的时候，CPU需要等待呢？我是这么理解的：如果说正常缓存了，调用glTexImage2D完成了一次数据的转移与备份，那么UI线程就不需要维持这份Bitmap对应的数据了，但是如果失败，没有为GPU生成备份，那就要保留这份数据，直到调用glTexImage2D为其生成备份。那为什么不把缓存调整很大呢？可能是在内存跟性能之间做的一个平衡，如果很大，可能同一时刻为GPU缓存的Bitmap太大，但是这个时候，GPU并没有用的到，可能是GPU太忙，来不及处理，那么这部分内存其实是浪费掉的，而且，这个时候CPU明显比GPU快了很多，可以适当让CPU等等，有的解析说防止Bitmap被修改，说实话，我也没太明白，只是个人理解，<strong>欢迎纠正</strong>，不过这里就算缓存失败，在issue提交OpenGL命令的时候，还是会再次upload Bitmap的，这大概也是UI阻塞的原因，这个时段对应的耗时如下：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1460468-73ba03209982131b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>OpenGL CPU跟GPU关系玄学曲线.jpg</p>
<h4 id="Render线程issue提交OpenGL渲染命令"><a href="#Render线程issue提交OpenGL渲染命令" class="headerlink" title="Render线程issue提交OpenGL渲染命令"></a>Render线程issue提交OpenGL渲染命令</h4><p>同步完成后，就可以处理之前的DrawOpTree，装换成标准的OpenGL API，提交OpenGL进行渲染，继续看DrawFrameTask的后半部分，主要是调用CanvasContext的draw，递归之前的DrawOpTree</p>
<pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">void</span> CanvasContext<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    EGLint width<span class="token punctuation">,</span> height<span class="token punctuation">;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>开始绘制，绑定EglSurface， 申请EglSurface需要的内存<span class="token operator">--</span><span class="token operator">></span>
    mEglManager<span class="token punctuation">.</span><span class="token function">beginFrame</span><span class="token punctuation">(</span>mEglSurface<span class="token punctuation">,</span> <span class="token operator">&amp;</span>width<span class="token punctuation">,</span> <span class="token operator">&amp;</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">...</span>
    Rect outBounds<span class="token punctuation">;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>递归调用OpenGLRender中的OpenGL API，绘制<span class="token operator">--</span><span class="token operator">></span>
    mCanvas<span class="token operator">-</span><span class="token operator">></span><span class="token function">drawRenderNode</span><span class="token punctuation">(</span>mRootRenderNode<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> outBounds<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bool drew <span class="token operator">=</span> mCanvas<span class="token operator">-</span><span class="token operator">></span><span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// Even if we decided to cancel the frame, from the perspective of jank</span>
    <span class="token comment" spellcheck="true">// metrics the frame was swapped at this point</span>
    mCurrentFrameInfo<span class="token operator">-</span><span class="token operator">></span><span class="token function">markSwapBuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>通知提交画布<span class="token operator">--</span><span class="token operator">></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>drew<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swapBuffers</span><span class="token punctuation">(</span>dirty<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   <span class="token operator">...</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li>第一步：mEglManager.beginFrame，其实是标记当前上下文，并且申请绘制内存，因为一个进程中可能存在多个window，也就是多个EglSurface，那么我们首先需要标记处理哪个，也就是用哪块画布绘画。之前<a href="https://www.jianshu.com/p/40f660e17a73" target="_blank" rel="noopener">理解Android硬件加速的小白文</a>说过，硬件加速场景会提前在SurfaceFlinger申请内存坑位，但是并未真正申请内存，这块内存是在真正绘制的时候才去申请，这里申请的内存是让GPU操作的内存，也是将来用来提交给SurfaceFlinger用来合成用的Layer数据；</li>
<li>第二步：递归issue OpenGL命令，提交给GPU绘制；</li>
<li>第三步：通过swapBuffers将绘制好的数据提交给SF去合成（<strong>其实GPU很可能并未完成渲染，但是可以提前释放Render线程，这里需要Fence机制保证同步</strong>）。不同的GPU实现不同，厂商不会将这部分开源，本文结合Android源码（软件实现的OpenGL）跟真机Systrace猜测实现。</li>
</ul>
<p>先看第一步，通过EglManager让Context绑定当前EglSurface，完成GPU绘制内存的申请</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> EglManager<span class="token operator">::</span><span class="token function">beginFrame</span><span class="token punctuation">(</span>EGLSurface surface<span class="token punctuation">,</span> EGLint<span class="token operator">*</span> width<span class="token punctuation">,</span> EGLint<span class="token operator">*</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token function">makeCurrent</span><span class="token punctuation">(</span>surface<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">eglBeginFrame</span><span class="token punctuation">(</span>mEglDisplay<span class="token punctuation">,</span> surface<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>makeCurrent都会向BnGraphicproducer申请一块内存，对于非自己编写的Render线程，基本都是向SurfaceFlinger申请，</p>
<pre class=" language-xml"><code class="language-xml">EGLBoolean eglMakeCurrent(  EGLDisplay dpy, EGLSurface draw,
                            EGLSurface read, EGLContext ctx)
{
    ogles_context_t* gl = (ogles_context_t*)ctx;
    if (makeCurrent(gl) == 0) {
        if (ctx) {
            egl_context_t* c = egl_context_t::context(ctx);
            egl_surface_t* d = (egl_surface_t*)draw;
            egl_surface_t* r = (egl_surface_t*)read;
            ...
            if (d) {
            <span class="token comment" spellcheck="true">&lt;!--牵扯到申请内存--></span>
                if (d->connect() == EGL_FALSE) {
                    return EGL_FALSE;
                }
                d->ctx = ctx;
                <span class="token comment" spellcheck="true">&lt;!--绑定--></span>
                d->bindDrawSurface(gl);
            }
           ...
    return setError(EGL_BAD_ACCESS, EGL_FALSE);
}</code></pre>
<p>如果是第一次的话，则需要调用egl_surface_t connect，其实就是调用之前创建的egl_window_surface_v2_t的connect，触发申请绘制内存：</p>
<pre class=" language-xml"><code class="language-xml">EGLBoolean egl_window_surface_v2_t::connect() 
{
     // dequeue a buffer
    int fenceFd = -1;
    <span class="token comment" spellcheck="true">&lt;!--调用nativeWindow的dequeueBuffer申请绘制内存,获取一个Fence--></span>
    if (nativeWindow->dequeueBuffer(nativeWindow, &amp;buffer,
            &amp;fenceFd) != NO_ERROR) {
        return setError(EGL_BAD_ALLOC, EGL_FALSE);
    }

    // wait for the buffer  等待申请的内存可用
    sp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Fence</span><span class="token punctuation">></span></span> fence(new Fence(fenceFd));
    ...
    return EGL_TRUE;
}</code></pre>
<p>上面的nativeWindow其实就是Surface:</p>
<pre class=" language-xml"><code class="language-xml">int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
        ...
    FrameEventHistoryDelta frameTimestamps;
    status_t result = mGraphicBufferProducer->dequeueBuffer(&amp;buf, &amp;fence, reqWidth, reqHeight,
                                                            reqFormat, reqUsage, &amp;mBufferAge,
                                                            enableFrameTimestamps ? &amp;frameTimestamps
                                                                                  : nullptr);
    ... 如果需要重新分配，则requestBuffer，请求分配
    if ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == nullptr) {
        <span class="token comment" spellcheck="true">&lt;!--请求分配--></span>
        result = mGraphicBufferProducer->requestBuffer(buf, &amp;gbuf);
       }
    ...</code></pre>
<p>简单说就是先申请内存坑位，如果该坑位的内存需要重新分配，则再申请分配匿名共享内存，<strong>这里分配的内存才是EglSurface(Surface)绘制所需内存（硬件加速）</strong>，接下来就可以通知OpenGL渲染绘制了。上面流程牵扯到一个Fence机制，其实就是一种协助生产者消费者的机制，主要作用是处理GPU跟CPU的同步上，先不谈。先走完流程，CanvasContext的mCanvas其实是OpenGLRenderer，接着看OpenGLRenderer的drawRenderNode：</p>
<pre class=" language-xml"><code class="language-xml">void OpenGLRenderer::drawRenderNode(RenderNode* renderNode, Rect&amp; dirty, int32_t replayFlags) {
    // All the usual checks and setup operations (quickReject, setupDraw, etc.)
    // will be performed by the display list itself
    if (renderNode &amp;&amp; renderNode->isRenderable()) {
        // compute 3d ordering
        <span class="token comment" spellcheck="true">&lt;!--计算Z顺序--></span>
        renderNode->computeOrdering();
        <span class="token comment" spellcheck="true">&lt;!--如果禁止合并Op直接绘制--></span>
        if (CC_UNLIKELY(Properties::drawDeferDisabled)) {
            startFrame();
            ReplayStateStruct replayStruct(*this, dirty, replayFlags);
            renderNode->replay(replayStruct, 0);
            return;
        }
       ...
        DeferredDisplayList deferredList(mState.currentClipRect(), avoidOverdraw);
        DeferStateStruct deferStruct(deferredList, *this, replayFlags);
        <span class="token comment" spellcheck="true">&lt;!--合并--></span>
        renderNode->defer(deferStruct, 0);
         <span class="token comment" spellcheck="true">&lt;!--处理文理图层--></span>
        flushLayers();
        <span class="token comment" spellcheck="true">&lt;!--设置视窗--></span>
        startFrame();
       <span class="token comment" spellcheck="true">&lt;!--flush，生成并提交OpenGL命令--></span>
        deferredList.flush(*this, dirty);
    } ...</code></pre>
<p>计算Z order跟合并DrawOp之前简单说过，不分析，这里只看flushLayers跟最终的issue OpenGL 命令（deferredList.flush，其实也是遍历每个DrawOp，调用自己的draw函数），flushLayers主要是处理TextureView，为了简化，先不考虑，假设不存在此类试图，那么只看flush即可，</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> DeferredDisplayList<span class="token operator">::</span><span class="token function">flush</span><span class="token punctuation">(</span>OpenGLRenderer<span class="token operator">&amp;</span> renderer<span class="token punctuation">,</span> Rect<span class="token operator">&amp;</span> dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">replayBatchList</span><span class="token punctuation">(</span>mBatches<span class="token punctuation">,</span> renderer<span class="token punctuation">,</span> dirty<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

 <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">replayBatchList</span><span class="token punctuation">(</span><span class="token keyword">const</span> Vector<span class="token operator">&lt;</span>Batch<span class="token operator">*</span><span class="token operator">></span><span class="token operator">&amp;</span> batchList<span class="token punctuation">,</span>
        OpenGLRenderer<span class="token operator">&amp;</span> renderer<span class="token punctuation">,</span> Rect<span class="token operator">&amp;</span> dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> batchList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>batchList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            batchList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">replay</span><span class="token punctuation">(</span>renderer<span class="token punctuation">,</span> dirty<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><img src="https:////upload-images.jianshu.io/upload_images/1460468-ff584edcad217367.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>DrawOp合并</p>
<pre class=" language-cpp"><code class="language-cpp">  <span class="token keyword">virtual</span> <span class="token keyword">void</span>  DrawBatch<span class="token operator">::</span><span class="token function">replay</span><span class="token punctuation">(</span>OpenGLRenderer<span class="token operator">&amp;</span> renderer<span class="token punctuation">,</span> Rect<span class="token operator">&amp;</span> dirty<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> override <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mOps<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            DrawOp<span class="token operator">*</span> op <span class="token operator">=</span> mOps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>op<span class="token punctuation">;</span>
            <span class="token keyword">const</span> DeferredDisplayState<span class="token operator">*</span> state <span class="token operator">=</span> mOps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>
            renderer<span class="token punctuation">.</span><span class="token function">restoreDisplayState</span><span class="token punctuation">(</span><span class="token operator">*</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
            op<span class="token operator">-</span><span class="token operator">></span><span class="token function">applyDraw</span><span class="token punctuation">(</span>renderer<span class="token punctuation">,</span> dirty<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre>
<p>递归每个合并后的Batch，接着处理Batch中每个DrawOp，调用其replay，以DrawPointsOp画点为例：</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">DrawPointsOp</span> <span class="token operator">:</span> <span class="token keyword">public</span> DrawLinesOp <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">DrawPointsOp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">float</span><span class="token operator">*</span> points<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> <span class="token keyword">const</span> SkPaint<span class="token operator">*</span> paint<span class="token punctuation">)</span>
            <span class="token operator">:</span> <span class="token function">DrawLinesOp</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> count<span class="token punctuation">,</span> paint<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">applyDraw</span><span class="token punctuation">(</span>OpenGLRenderer<span class="token operator">&amp;</span> renderer<span class="token punctuation">,</span> Rect<span class="token operator">&amp;</span> dirty<span class="token punctuation">)</span> override <span class="token punctuation">{</span>
        renderer<span class="token punctuation">.</span><span class="token function">drawPoints</span><span class="token punctuation">(</span>mPoints<span class="token punctuation">,</span> mCount<span class="token punctuation">,</span> mPaint<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre>
<p>最终调用OpenGLrender的drawPoints</p>
<pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">void</span> OpenGLRenderer<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">drawPoints</span><span class="token punctuation">(</span><span class="token keyword">const</span> float<span class="token operator">*</span> points<span class="token punctuation">,</span> int count<span class="token punctuation">,</span> <span class="token keyword">const</span> SkPaint<span class="token operator">*</span> paint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
     count <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span><span class="token number">0x1</span><span class="token punctuation">;</span> 
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>构建VertexBuffer<span class="token operator">--</span><span class="token operator">></span>
    VertexBuffer buffer<span class="token punctuation">;</span>
    PathTessellator<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">tessellatePoints</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> count<span class="token punctuation">,</span> paint<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token function">currentTransform</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token operator">...</span>    
    int displayFlags <span class="token operator">=</span> paint<span class="token operator">-</span><span class="token operator">></span><span class="token function">isAntiAlias</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> kVertexBuffer_Offset<span class="token punctuation">;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>使用buffer paint绘制 <span class="token operator">--</span><span class="token operator">></span>
    <span class="token function">drawVertexBuffer</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> paint<span class="token punctuation">,</span> displayFlags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mDirty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> OpenGLRenderer<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">drawVertexBuffer</span><span class="token punctuation">(</span>float translateX<span class="token punctuation">,</span> float translateY<span class="token punctuation">,</span>
        <span class="token keyword">const</span> VertexBuffer<span class="token operator">&amp;</span> vertexBuffer<span class="token punctuation">,</span> <span class="token keyword">const</span> SkPaint<span class="token operator">*</span> paint<span class="token punctuation">,</span> int displayFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">/</span><span class="token operator">...</span>
    Glop glop<span class="token punctuation">;</span>
    <span class="token function">GlopBuilder</span><span class="token punctuation">(</span>mRenderState<span class="token punctuation">,</span> mCaches<span class="token punctuation">,</span> <span class="token operator">&amp;</span>glop<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setRoundRectClipState</span><span class="token punctuation">(</span><span class="token function">currentSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>roundRectClipState<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setMeshVertexBuffer</span><span class="token punctuation">(</span>vertexBuffer<span class="token punctuation">,</span> shadowInterp<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setFillPaint</span><span class="token punctuation">(</span><span class="token operator">*</span>paint<span class="token punctuation">,</span> <span class="token function">currentSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>alpha<span class="token punctuation">)</span>
             <span class="token operator">...</span>
            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">renderGlop</span><span class="token punctuation">(</span>glop<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> OpenGLRenderer<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">renderGlop</span><span class="token punctuation">(</span><span class="token keyword">const</span> Glop<span class="token operator">&amp;</span> glop<span class="token punctuation">,</span> GlopRenderType type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token operator">...</span>
mRenderState<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>glop<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">...</span></code></pre>
<p>Vertex是OpenGL的基础概念，drawVertexBuffer调用RenderState的render，向GPU提交绘制命令（不会立即绘制，GPU也是由缓冲区的，除非手动glFinish或者glFlush，才会即刻渲染），RenderState可以看做OpenGL状态机的抽象，render函数实现如下</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> RenderState<span class="token operator">::</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token keyword">const</span> Glop<span class="token operator">&amp;</span> glop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> Glop<span class="token operator">::</span>Mesh<span class="token operator">&amp;</span> mesh <span class="token operator">=</span> glop<span class="token punctuation">.</span>mesh<span class="token punctuation">;</span>
    <span class="token keyword">const</span> Glop<span class="token operator">::</span>Mesh<span class="token operator">::</span>Vertices<span class="token operator">&amp;</span> vertices <span class="token operator">=</span> mesh<span class="token punctuation">.</span>vertices<span class="token punctuation">;</span>
    <span class="token keyword">const</span> Glop<span class="token operator">::</span>Mesh<span class="token operator">::</span>Indices<span class="token operator">&amp;</span> indices <span class="token operator">=</span> mesh<span class="token punctuation">.</span>indices<span class="token punctuation">;</span>
    <span class="token keyword">const</span> Glop<span class="token operator">::</span>Fill<span class="token operator">&amp;</span> fill <span class="token operator">=</span> glop<span class="token punctuation">.</span>fill<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ---------------------------------------------</span>
    <span class="token comment" spellcheck="true">// ---------- Program + uniform setup ----------</span>
    <span class="token comment" spellcheck="true">// ---------------------------------------------</span>
    mCaches<span class="token operator">-</span><span class="token operator">></span><span class="token function">setProgram</span><span class="token punctuation">(</span>fill<span class="token punctuation">.</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>fill<span class="token punctuation">.</span>colorEnabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fill<span class="token punctuation">.</span>program<span class="token operator">-</span><span class="token operator">></span><span class="token function">setColor</span><span class="token punctuation">(</span>fill<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    fill<span class="token punctuation">.</span>program<span class="token operator">-</span><span class="token operator">></span><span class="token function">set</span><span class="token punctuation">(</span>glop<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>ortho<span class="token punctuation">,</span>
            glop<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>modelView<span class="token punctuation">,</span>
            glop<span class="token punctuation">.</span>transform<span class="token punctuation">.</span><span class="token function">meshTransform</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            glop<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>transformFlags <span class="token operator">&amp;</span> TransformFlags<span class="token operator">::</span>OffsetByFudgeFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Color filter uniforms</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fill<span class="token punctuation">.</span>filterMode <span class="token operator">==</span> ProgramDescription<span class="token operator">::</span>kColorBlend<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> FloatColor<span class="token operator">&amp;</span> color <span class="token operator">=</span> fill<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>color<span class="token punctuation">;</span>
        <span class="token function">glUniform4f</span><span class="token punctuation">(</span>mCaches<span class="token operator">-</span><span class="token operator">></span><span class="token function">program</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getUniform</span><span class="token punctuation">(</span><span class="token string">"colorBlend"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                color<span class="token punctuation">.</span>r<span class="token punctuation">,</span> color<span class="token punctuation">.</span>g<span class="token punctuation">,</span> color<span class="token punctuation">.</span>b<span class="token punctuation">,</span> color<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
     <span class="token comment" spellcheck="true">// ---------- Mesh setup ----------</span>
    <span class="token comment" spellcheck="true">// vertices</span>
    <span class="token keyword">const</span> <span class="token keyword">bool</span> force <span class="token operator">=</span> <span class="token function">meshState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bindMeshBufferInternal</span><span class="token punctuation">(</span>vertices<span class="token punctuation">.</span>bufferObject<span class="token punctuation">)</span>
            <span class="token operator">||</span> <span class="token punctuation">(</span>vertices<span class="token punctuation">.</span>position <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">meshState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bindPositionVertexPointer</span><span class="token punctuation">(</span>force<span class="token punctuation">,</span> vertices<span class="token punctuation">.</span>position<span class="token punctuation">,</span> vertices<span class="token punctuation">.</span>stride<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// indices</span>
    <span class="token function">meshState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bindIndicesBufferInternal</span><span class="token punctuation">(</span>indices<span class="token punctuation">.</span>bufferObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">// ------------------------------------</span>
    <span class="token comment" spellcheck="true">// ---------- GL state setup ----------</span>
    <span class="token comment" spellcheck="true">// ------------------------------------</span>
    <span class="token function">blend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setFactors</span><span class="token punctuation">(</span>glop<span class="token punctuation">.</span>blend<span class="token punctuation">.</span>src<span class="token punctuation">,</span> glop<span class="token punctuation">.</span>blend<span class="token punctuation">.</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ------------------------------------</span>
    <span class="token comment" spellcheck="true">// ---------- Actual drawing ----------</span>
    <span class="token comment" spellcheck="true">// ------------------------------------</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>indices<span class="token punctuation">.</span>bufferObject <span class="token operator">==</span> <span class="token function">meshState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQuadListIBO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// Since the indexed quad list is of limited length, we loop over</span>
        <span class="token comment" spellcheck="true">// the glDrawXXX method while updating the vertex pointer</span>
        GLsizei elementsCount <span class="token operator">=</span> mesh<span class="token punctuation">.</span>elementCount<span class="token punctuation">;</span>
        <span class="token keyword">const</span> GLbyte<span class="token operator">*</span> vertexData <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> GLbyte<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>vertices<span class="token punctuation">.</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>elementsCount <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token function">glDrawElements</span><span class="token punctuation">(</span>mesh<span class="token punctuation">.</span>primitiveMode<span class="token punctuation">,</span> drawCount<span class="token punctuation">,</span> GL_UNSIGNED_SHORT<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            elementsCount <span class="token operator">-</span><span class="token operator">=</span> drawCount<span class="token punctuation">;</span>
            vertexData <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>drawCount <span class="token operator">/</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">*</span> vertices<span class="token punctuation">.</span>stride<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span>  
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>可以看到，经过一步步的设置，变换，预处理，最后都是要转换成glXXX函数，生成相应的OpenGL命令发送给GPU，通知GPU绘制，这里有两种处理方式，第一种是CPU阻塞等待GPU绘制结束后返回，再将绘制内容提交给SurfaceFlinger进行合成，第二种是CPU直接返回，然后提交给SurfaceFlinger合成，等到SurfaceFlinger合成的时候，如果还未绘制完毕，则需要阻塞等待GPU绘制完毕，软件实现的采用的是第一种，硬件实现的一般是第二种。需要注意：<strong>OpenGL绘制前各种准备包括传给GPU使用的内存都是CPU在APP的私有内存空间申请的，而GPU真正绘制到画布使用的提交给SurfaceFlinger的那块内存，是从匿名共享申请的内存，两者是不一样的</strong>，这一部分的耗时，其实就是CPU 将命令同步给GPU的耗时，在OpenGL玄学曲线中是：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1460468-e2af8168e37558d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>构建OpenGL命令.jpg</p>
<h4 id="Render线程swapBuffers提交图形缓冲区（加Fence机制）"><a href="#Render线程swapBuffers提交图形缓冲区（加Fence机制）" class="headerlink" title="Render线程swapBuffers提交图形缓冲区（加Fence机制）"></a>Render线程swapBuffers提交图形缓冲区（加Fence机制）</h4><p>在Android里，GraphicBuffer的同步主要借助Fence同步机制，它最大的特点是能够处理GPU、CPU、HWC间的同步。因为，GPU处理一般是异步的，当我们调用OpenGL API返回后，OpenGL命令并不是即刻被GPU执行的，而是被缓存在本地的GL命令缓冲区中，等缓冲区满的时候，才会真正通知GPU执行，而CPU可能完全不知道执行时机，除非CPU主动使用glFinish()强制刷新，阻塞等待这些命令执行完，但是，毫无疑问，这会使得CPU、GPU并行处理效率降低，至少，渲染线程是被阻塞在那里的；相对而言异步处理的效率要高一些，CPU提交命令后就返回，不等待GPU处理完，这样渲染线程被解放处理下一条消息，不过这个时候图形未被处理完毕的前提的下就被提交给SurfaceFlinger图形合成，那么SurfaceFlinger需要知道什么时候这个GraphicBuffer被GPU处理填充完毕，这个时候就是Fence机制发挥作用的地方，关于Fence不过多分析，毕竟牵扯信息也挺多，只简单画了示意图：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1460468-07cffa61dfbfffef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>Fence示意图.jpg</p>
<p>之前的命令被issue完毕后，CPU一般会发送最后一个命令给GPU，告诉GPU当前命令发送完毕，可以处理，GPU一般而言需要返回一个确认的指令，不过，这里并不代表执行完毕，仅仅是通知到而已，如果GPU比较忙，来不及回复通知，则CPU需要阻塞等待，CPU收到通知后，会唤起当前阻塞的Render线程，继续处理下一条消息，这个阶段是在swapBuffers中完成的，Google给的解释如下：</p>
<blockquote>
<p>Once Android finishes submitting all its display list to the GPU, the system issues one final command to tell the graphics driver that it’s done with the current frame. At this point, the driver can finally present the updated image to the screen.</p>
</blockquote>
<blockquote>
<p>It’s important to understand that the GPU executes work in parallel with the CPU. The Android system issues draw commands to the GPU, and then moves on to the next task. The GPU reads those draw commands from a queue and processes them.</p>
</blockquote>
<blockquote>
<p>In situations where the CPU issues commands faster than the GPU consumes them, the communications queue between the processors can become full. When this occurs, the CPU blocks, and waits until there is space in the queue to place the next command. This full-queue state arises often during the Swap Buffers stage, because at that point, a whole frame’s worth of commands have been submitted</p>
</blockquote>
<p>但看Android源码而言，软件实现的libagl可以看做同步的，不需要考虑Fence机制：</p>
<pre class=" language-php"><code class="language-php">EGLBoolean egl_window_surface_v2_t<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">swapBuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">// 其实就是queueBuffer，queueBuffer这里用的是-1</span>
    nativeWindow<span class="token operator">-</span><span class="token operator">></span><span class="token function">queueBuffer</span><span class="token punctuation">(</span>nativeWindow<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    buffer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// dequeue a new buffer</span>
    int fenceFd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 这里是为了什么，还是阻塞等待，难道是为了等待GPU处理完成吗？  </span>
    <span class="token comment" spellcheck="true">// buffer换buffer</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nativeWindow<span class="token operator">-</span><span class="token operator">></span><span class="token function">dequeueBuffer</span><span class="token punctuation">(</span>nativeWindow<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fenceFd<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NO_ERROR</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sp<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Fence</span><span class="token punctuation">></span></span></span> <span class="token function">fence</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Fence</span><span class="token punctuation">(</span>fenceFd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// fence->wait</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fence<span class="token operator">-</span><span class="token operator">></span><span class="token function">wait</span><span class="token punctuation">(</span>Fence<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">TIMEOUT_NEVER</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            nativeWindow<span class="token operator">-</span><span class="token operator">></span><span class="token function">cancelBuffer</span><span class="token punctuation">(</span>nativeWindow<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token function">setError</span><span class="token punctuation">(</span><span class="token constant">EGL_BAD_ALLOC</span><span class="token punctuation">,</span> <span class="token constant">EGL_FALSE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre>
<p>可以看到，源码中是先将Buffer提交给SurfaceFlinger，然后再申请一个Buffer用来处理下一次请求。并且这里queueBuffer传递的Fence是-1，也就在swapbuffer的时候，软件实现的OpenGL库是不需要Fence机制的（压根不需要考虑GPU、CPU同步）。<strong>queueBuffer会触发Layer回调，并向SurfaceFlinger发送消息，请求SurfaceFlinger执行，这里是一个异步过程，不会导致阻塞</strong>，回调入口在Layer的onFrameAvailable</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Layer<span class="token operator">::</span><span class="token function">onFrameAvailable</span><span class="token punctuation">(</span><span class="token keyword">const</span> BufferItem<span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span> 
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>queueBuffer后触发Layer的onFrameAvailable回调，
    mFlinger<span class="token operator">-</span><span class="token operator">></span><span class="token function">signalLayerUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>而dequeueBuffer在slot上限允许的前提下，也不会阻塞，按理说，不会怎么耗时，但是就模拟器效果而言，swapBuffers好像耗时比较严重(<strong>其中下图的黄色部分就是swapBuffers耗时</strong>)，这里不太理解，因为模拟器应该是同步的，应该不会牵扯缓冲区交换时也不会隐式将命令送去GPU执行，也不会阻塞等待，为什么耗时这么多呢，模拟器的（Genymotion 6.0），不知道是不是跟Genymotion有关系：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1460468-75a85c4674621374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/561/format/webp" alt="img"></p>
<p>image.png</p>
<p>再看一下Genymotion 的Systrace：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1460468-f6088f8ab2dc18ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>image.png</p>
<p>可以看到，Systace中的函数调用基本跟egl.cpp中基本一致，但是queue跟dequeue buffer为什么耗时这么久呢？有些不理解，希望有人能指点。而对于硬件真机，一般需要处理Fence，其egl_window_surface_v2_t::swapBuffers()应该会被重写，至少需要传递一个有效的Fence过去，</p>
<pre class=" language-php"><code class="language-php">    nativeWindow<span class="token operator">-</span><span class="token operator">></span><span class="token function">queueBuffer</span><span class="token punctuation">(</span>nativeWindow<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> fenceId（不应该再是<span class="token operator">-</span><span class="token number">1</span>）<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>也就是说，queueBuffer的fenceid不能再是-1了，因为需要一个有效的Fence处理GPU CPU同步，再再看下真机的Systrace（nexus5 6.0）</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1460468-f00b845c598e6103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>真机OpenGL渲染Systrace</p>
<p>可以看到真机函数的调用跟模拟器差别很大，比如dequeue、enqueue，具体可能要看各家的实现了，再看8.0的nexus6p：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1460468-98cbede7afa36a80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>nexus6p 8.0</p>
<p>一开始我以为，swapBuffers会在某个地方调用glFinish()或者glFlush，这个时候可能会阻塞，导致耗时增加，但是看源码说不通，因为好像也跟就不会在enqueue或者dequeue的时候直接触发，就算触发，也是异步的。一般，<strong>issue任务给驱动后，如果采用是双缓冲，在缓冲区交换操作会隐式将命令送去执行</strong>，这里猜想是不同厂商自己实现，但是看不到具体的代码，也不好确定，谁做rom的希望能指点下。 这段时间的耗时在GPU呈现曲线上如下，文档解释说是CPU等待GPU的时间，个人理解：是等待时间，但是不是等待GPU完成渲染的时间，仅仅是等待一个ACK类的信号，否则，就不存在CPU、GPU并行了：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1460468-b1f39419ace21d02.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>swapbuffer耗时.jpg</p>
<p>dequeueBuffer会阻塞导致耗时增加吗？应该也不会，关于swapbuffer这段时间的耗时有空再看了</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>UI线程构建OpenGL的DrawOpTree</li>
<li>Render线程负责DrawOpTree合并优化、数据的同步</li>
<li>Render线程负责将DrawOp转换成标准OpenGL命令，并isssue给GPU</li>
<li>Render线程通过swapbuffer通知GPU（待研究），同时完成向SurfaceFlinger画布数据的提交</li>
</ul>
<h2 id="surfaceflinger合成surface"><a href="#surfaceflinger合成surface" class="headerlink" title="surfaceflinger合成surface"></a>surfaceflinger合成surface</h2><h3 id="SurfaceFlinger合成消息"><a href="#SurfaceFlinger合成消息" class="headerlink" title="SurfaceFlinger合成消息"></a>SurfaceFlinger合成消息</h3><p>SurfaceFlinger合成图层依赖于Android的异步消息处理机制。</p>
<p>首先，它包含了一个MessageQueue对象（消息队列）用于处理各种异步消息，在onFirstRef()中对消息队列进行了初始化:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//SurfaceFlinger.cpp</span>
SurfaceFlinger<span class="token operator">::</span><span class="token function">onFirstRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    mEventQueue<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>分析一下MessageQueue的实现：</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//MessageQueue.cpp</span>
<span class="token keyword">void</span> MessageQueue<span class="token operator">::</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>SurfaceFlinger<span class="token operator">></span><span class="token operator">&amp;</span> flinger<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   mFlinger <span class="token operator">=</span> flinger<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存MessageQueue的拥有者SurfaceFlinger</span>
   mLooper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Looper</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建Looper对象</span>
   mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建Handler对象</span>
<span class="token punctuation">}</span></code></pre>
<p>调用Handler::handleMessage()处理INVALIDATE和REFRESH消息，并将其转发给SurfaceFlinger进行处理，调用onMessageReceived():</p>
<pre class=" language-php"><code class="language-php">void MessageQueue<span class="token punctuation">:</span><span class="token punctuation">:</span>Handler<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">handleMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> Message<span class="token operator">&amp;</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">switch</span> <span class="token punctuation">(</span>message<span class="token punctuation">.</span>what<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">case</span> <span class="token constant">INVALIDATE</span><span class="token punctuation">:</span>
           <span class="token function">android_atomic_and</span><span class="token punctuation">(</span><span class="token operator">~</span>eventMaskInvalidate<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mEventMask<span class="token punctuation">)</span><span class="token punctuation">;</span>
           mQueue<span class="token punctuation">.</span>mFlinger<span class="token operator">-</span><span class="token operator">></span><span class="token function">onMessageReceived</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>what<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">break</span><span class="token punctuation">;</span>
       <span class="token keyword">case</span> <span class="token constant">REFRESH</span><span class="token punctuation">:</span>
           <span class="token function">android_atomic_and</span><span class="token punctuation">(</span><span class="token operator">~</span>eventMaskRefresh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mEventMask<span class="token punctuation">)</span><span class="token punctuation">;</span>
           mQueue<span class="token punctuation">.</span>mFlinger<span class="token operator">-</span><span class="token operator">></span><span class="token function">onMessageReceived</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>what<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">break</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>  
<span class="token punctuation">}</span></code></pre>
<p>接下来看一下SurfaceFlinger对消息的处理：</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> SurfaceFlinger<span class="token operator">::</span><span class="token function">onMessageReceived</span><span class="token punctuation">(</span>int32_t what<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">ATRACE_CALL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">switch</span> <span class="token punctuation">(</span>what<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">case</span> MessageQueue<span class="token operator">::</span>INVALIDATE<span class="token operator">:</span> <span class="token punctuation">{</span>
           <span class="token keyword">bool</span> refreshNeeded <span class="token operator">=</span> <span class="token function">handleMessageTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           refreshNeeded <span class="token operator">|</span><span class="token operator">=</span> <span class="token function">handleMessageInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           refreshNeeded <span class="token operator">|</span><span class="token operator">=</span> mRepaintEverything<span class="token punctuation">;</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>refreshNeeded<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token comment" spellcheck="true">// Signal a refresh if a transaction modified the window state,</span>
               <span class="token comment" spellcheck="true">// a new buffer was latched, or if HWC has requested a full</span>
               <span class="token comment" spellcheck="true">// repaint</span>
               <span class="token function">signalRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
           <span class="token keyword">break</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">case</span> MessageQueue<span class="token operator">::</span>REFRESH<span class="token operator">:</span> <span class="token punctuation">{</span>
           <span class="token function">handleMessageRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">break</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>    
<span class="token punctuation">}</span></code></pre>
<p>SurfaceFlinger处理的消息分为两种：</p>
<p><strong>INVALIDATE消息</strong>：用于处理Layer或者display属性的变化以及Layer对应buffer的更新。</p>
<pre class=" language-undefined"><code class="language-undefined"> 1) Layer或者Display属性的更新通过调用handleMessageTransaction()处理;

 2) buffer的更新通过调用handleMessageInvalidate()处理。</code></pre>
<p>REFRESH消息：表示SurfaceFlinger需要进行一次合成操作(Refresh),通过handleMessageRefresh()实现；主要有三种情况:</p>
<pre class=" language-dart"><code class="language-dart"> <span class="token number">1</span><span class="token punctuation">)</span> Layer属性的变化导致window state发生变化<span class="token punctuation">;</span>

 <span class="token number">2</span><span class="token punctuation">)</span> Layer有新的buffer到来<span class="token punctuation">;</span>

 <span class="token number">3</span><span class="token punctuation">)</span> HWC请求进行一次repaint。</code></pre>
<p>如果这三种情况之一发生，则置refreshNeeded为true，调用signalRefresh()发出MessageQueue::REFRESH消息;</p>
<p>当VSync信号来之前，Layer或者display属性的变化会做本地保存，只有当VSync信号到来时，SurfaceFlinger才会通过INVALIDATE和REFRESH消息来做统一的合并渲染和输出的处理工作。</p>
<h3 id="handleMessageTransaction"><a href="#handleMessageTransaction" class="headerlink" title="handleMessageTransaction()"></a>handleMessageTransaction()</h3><p>处理之前对屏幕和应用程序窗口的改动。因这些改动很有可能会改变图层的可见区域，进而影响脏区域的计算。</p>
<pre class=" language-undefined"><code class="language-undefined">主要处理以下几个方面的transaction：

1）Layer属性的变化；
2）Layer的增加和减少；
3）Display属性的变化;
4）Display的增加和减少；</code></pre>
<h3 id="handleMessageInvalidate"><a href="#handleMessageInvalidate" class="headerlink" title="handleMessageInvalidate()"></a>handleMessageInvalidate()</h3><p>主要调用handlePageFlip()函数。这里Page Flip是指从BufferQueue中取下一个图形缓冲区内容，就好像是“翻页”一样。该函数主要是从各Layer对应的BufferQueue中拿图形缓冲区数据，并根据内容更新脏区域（注：脏区域是需要重绘的屏幕区域。）。并且把GraphicBuffer映射为OpenGL的texture 。</p>
<h3 id="handleMessageRefresh"><a href="#handleMessageRefresh" class="headerlink" title="handleMessageRefresh()"></a>handleMessageRefresh()</h3><p>合并和渲染输出。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> SurfaceFlinger<span class="token operator">::</span><span class="token function">handleMessageRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">preComposition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//合成前的准备</span>
    <span class="token function">rebuildLayerStacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//重建layer堆栈</span>
    <span class="token function">setUpHWComposer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//hwcomposer的设定</span>
    <span class="token function">doComposition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//正式的合成处理</span>
    <span class="token function">postComposition</span><span class="token punctuation">(</span>refreshStartTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//合成后期的处理</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="void-SurfaceFlinger-preComposition"><a href="#void-SurfaceFlinger-preComposition" class="headerlink" title="void SurfaceFlinger::preComposition()"></a>void SurfaceFlinger::preComposition()</h4><p>合成前准备工作。首先得到当前所有layer的集合，然后对所有的Layer调用其onPreComposition()检查是否需要ExtralInvalidate,如果需要就调用一次signalLayerUpdate(),即通过EventThread安排一次vsync。</p>
<h4 id="void-SurfaceFlinger-rebuildLayerStacks"><a href="#void-SurfaceFlinger-rebuildLayerStacks" class="headerlink" title="void SurfaceFlinger::rebuildLayerStacks()"></a>void SurfaceFlinger::rebuildLayerStacks()</h4><p>计算可见layer及它们的可见区域。首先每个layer都有一个layerStack来区别它属于哪个Display，系统的Display可能不止一个，所以需要逐个处理Display，根据所有layers的当前状态通过SurfaceFlinger::computeVisibleRegions方法计算各个Layer在当前display上的可见区域和脏区域等。最后把需要绘制的layer添加到layersSortedByZ中。</p>
<h4 id="void-SurfaceFlinger-setUpHWComposer"><a href="#void-SurfaceFlinger-setUpHWComposer" class="headerlink" title="void SurfaceFlinger::setUpHWComposer()"></a>void SurfaceFlinger::setUpHWComposer()</h4><p>为合成搭建环境。这个HWComposer并不是真正的Hal模块，而是surfaceflinger为管理HWComposer模块而设计的一个类，路径是：frameworks/native/service/surfaceflinger/displayhardware/。依次处理各个Display，构造WorkList，合成过程既可以有Hwc模块完成，也可以通过OpengGlEs来完成，具体用哪种方式是有prepare()中的compositionType来决定的。</p>
<h4 id="void-SurfaceFlinger-doComposition"><a href="#void-SurfaceFlinger-doComposition" class="headerlink" title="void SurfaceFlinger::doComposition()"></a>void SurfaceFlinger::doComposition()</h4><p>执行合成操作。执行openGl合成 or HWC合成。</p>
<h4 id="void-SurfaceFlinger-postComposition-refreshStartTime"><a href="#void-SurfaceFlinger-postComposition-refreshStartTime" class="headerlink" title="void SurfaceFlinger::postComposition(refreshStartTime)"></a>void SurfaceFlinger::postComposition(refreshStartTime)</h4><p>将图像传递到物理屏幕。</p>
<p>最后借用一张流程图做最后的总结：</p>
<p><img src="2828107-0e30a930e9023b31.webp" alt="img"></p>
<p>from Jeanboydev</p>
<p>参考：<br><a href="https://blog.csdn.net/jxt1234and2010/article/details/46057267" target="_blank" rel="noopener">https://blog.csdn.net/jxt1234and2010/article/details/46057267</a><br><a href="https://blog.csdn.net/freekiteyu/article/details/79483406" target="_blank" rel="noopener">https://blog.csdn.net/freekiteyu/article/details/79483406</a><br><a href="https://blog.csdn.net/u012878643/article/details/71104467" target="_blank" rel="noopener">https://blog.csdn.net/u012878643/article/details/71104467</a></p>
<h2 id="HWC消息合成通路"><a href="#HWC消息合成通路" class="headerlink" title="HWC消息合成通路"></a>HWC消息合成通路</h2><h3 id="HWC接收surface"><a href="#HWC接收surface" class="headerlink" title="HWC接收surface"></a>HWC接收surface</h3><p>[Todo]非公开内容，略</p>
<h3 id="HWC处理surface"><a href="#HWC处理surface" class="headerlink" title="HWC处理surface"></a>HWC处理surface</h3><p>[Todo]非公开内容，略</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论 </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'e7d8054ec8ee883bd926',
            clientSecret: '6592168627b00b0121c1ca6b4e90708550980e41',
            repo: 'hfutjcd.github.io',
            owner: 'hfutjcd',
            admin: ['hfutjcd'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'false',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2019-2029 Hunter
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    #post .pjax article .article-entry>ol, #post .pjax article .article-entry>ul, #post .pjax article>ol, #post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    #post .pjax article .article-entry li>ol, #post .pjax article .article-entry li>ul,#post .pjax article li>ol, #post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    #post .pjax article .article-entry>ol>li, #post .pjax article .article-entry>ul>li,#post .pjax article>ol>li, #post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    #post .pjax article .article-entry li>ol>li, #post .pjax article .article-entry li>ul>li,#post .pjax article li>ol>li, #post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.2;
        background: url("/img/article-list-background.jpg");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
