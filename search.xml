<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git 速查表</title>
      <link href="/2022/05/29/git-su-cha-biao/"/>
      <url>/2022/05/29/git-su-cha-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="git-速查表"><a href="#git-速查表" class="headerlink" title="git 速查表"></a>git 速查表</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="建仓"><a href="#建仓" class="headerlink" title="建仓"></a>建仓</h3><ol><li>git clone  url -b localbranch -o remotebranch</li><li>git init -b localbranch</li></ol><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ol><li>git log</li><li>git log -vv</li><li>git relog</li></ol><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><ol><li>git add</li><li>git commit –m “description”</li><li>git commit –am “add and commit”</li></ol><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ol><li><p>git branch -a newbranch  //创建但停留在当前分支</p></li><li><p>git checkout -a newbranch //创建并切换到新分子</p></li></ol><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="git大文件上传限制"><a href="#git大文件上传限制" class="headerlink" title="git大文件上传限制"></a>git大文件上传限制</h3><ul><li><p>问题: 用github管理远程仓库时，git push存在大文件限制，单个文件不能超过100MB，git push 时的pack不能超过2GB。</p></li><li><p>方案：</p><ul><li><p>根据git 提示，使用git lfs插件可以解决单个大文件超过100MB的限制。<br>1.下载并安装<a href="https://github.com/git-lfs/git-lfs/releases/download/v3.2.0/git-lfs-windows-v3.2.0.exe" target="_blank" rel="noopener">git-lfs-windows-v3.2.0.exe</a><br>2.在git bash中安装该插件</p><pre><code>git lfs install</code></pre><p>3.在自己的仓中添加对大文件的管理,比如管理pdf类型文件</p><pre><code>git lfs track "*.psd"</code></pre><p>4.上述命令生成配置文件”.gitattributes”,把改文件添加到git中管理起来。</p><pre><code>git add .gitattributes</code></pre><p>5.跟平时一样使用git就可以了。</p></li></ul></li><li><p>git push 单次不能超过2GB限制: 分多次提交和push。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git速查 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Camera D-PHY简介</title>
      <link href="/2022/01/19/camera-d-phy-jian-jie/"/>
      <url>/2022/01/19/camera-d-phy-jian-jie/</url>
      
        <content type="html"><![CDATA[<p><a href="https://deepinout.com/camera-terms/camera-dphy-intro.html" target="_blank" rel="noopener">转自</a>:<a href="https://deepinout.com/camera-terms/camera-dphy-intro.html" target="_blank" rel="noopener">https://deepinout.com/camera-terms/camera-dphy-intro.html</a></p><p>D-PHY中的PHY是物理层（Physical）的意思，那么D是什么意思呢？</p><p>在MIPI D-PHY的文档中有提到过，D-PHY的最初版本的设计目标是500Mbits/s，而D是罗马数字（拉丁文数字）中500 。</p><p>同理C和M分别是罗马数字中的100和1000，也就是C-PHY和M-PHY中C和M的意思了。</p><p>D-PHY是一种高速、低功耗的源同步物理层，由于采用了高功效设计，因此非常适合功耗大的电池供电设备使用。它里面同时包含了有助于实现高功效的高速模块和低功耗模块。载荷数据（图像数据）使用高速模块，控制和状态信息的发送（在照相机/显示器和应用处理器之间）使用的是低功耗模块（利用低频信号）。它具有在单个数据包脉冲中发送高速和低功耗数据的特殊能力。低功耗模块有助于节省功耗，高速模块则有助于实现高清晰度照片质量数据信号要求的较高带宽。</p><p>如下图所示，MIPI信号（HS模式下）相对于传统的TMDS信号、LVDS信号等，具有低电压摆幅，低功耗的优势。</p><p>MIPI低功耗</p><p>MIPI 传输模式<br>MIPI D-PHY协议定义了两种传输模式：高速模式（High Speed，HS）和低功耗模式（Low Power，LP），两种模式使用不同的传输电平和传输机制。HS模式和LP模式的电平如下图所示：</p><p>MIPI 传输模式</p><p>其中，HS模式下，为差分信号传输，信号电平在100mV~300mV（200mV的压摆）；</p><p>HS模式下，信号传输速度可达80Mbps<del>1Gbps（v1.0）或80Mbps</del>1.5Gbps（v1.1），采用源同步的传输方式，由主机（Master）设备向从机（Slave）设备提供DDR时钟。</p><p>LP模式下，为单端信号传输，信号电平在0~1.2V（1.2V压摆）。</p><p>LP模式下，信号传输速度为10Mbps，此时传输通道的差分线（HS模式下的）是两根独立的信号线。无论是HS模式还是LP模式，都采用LSB fisrt，MSB last的传输方式。</p><p>为什么要这样设计？我个人的理解是这样的：HS模式下，信号传输速度较快，较低的压摆有利于提升传输速度，同时降低功耗和EMI；那么为什么LP模式下不用HS的传输机制呢？是因为LP模式下，传输的信号速度较慢，较低的压摆不利于系统的稳定（此时可能会有比较严重的过冲，如果采用100mV~300mV的电平的话）。</p><p>一个完整的MIPI传输系统结构图如下：</p><p>完整的MIPI传输系统结构图</p><p>其中PHY Layer为物理层，如D-PHY，Low Level Protocol和Lane Management为中间层，如DSI和CSI，Application为应用层，可由软件或者硬件实现，以DSI系统为例，其中所有的命令需要符合MIPI的DCS（Display Command Set）规范。</p><p>D-PHY协议最多支持5个Lane（通道）（一个时钟Lane，4个数据Lane），最少需要两个Lane（一个时钟Lane，一个数据Lane）。</p><p>MIPI 传输模式</p><p>如上图所示，一个通用的Lane中包含LP-TX、LP-RX、HS-TX、HS-RX和LP-CD模块，所有收发模块均共用同一个差分线Dp，Dn（在LP模式下，为两根单独的信号线）。整个Lane通过PPI接口（PHY Protocol Interface）与系统的其他部分连接。</p><p>其中，LP-CD模块仅在存在于需要双向通信（Bidirectional）的系统中，对于不需要双向通信（Unidirectional）的系统，如CSI协议，则不需要LP-CD模块。显然，在Unidirectional系统中，主机（一般固定为Transmitter）则不需要RX模块，从机（一般固定为Receiver）则不需要TX模块。在需要双向通信的系统中，如DSI（当然，在特定的系统中，DSI也可以是Unidirectional的），一般只需要一个Data Lane具有双向收发的能力，其他的Data Lane和Clock Lane则可以根据实际需求，去除RX或者TX模块。需要注意的是，即使实在Unidirectional的系统中，Clock Lane也不需要反向传输，即当从机向主机发送数据时（反向传输），此时的DDR时钟仍然是由主机提供（HS模式下，LP模式下则不需要时钟）。</p><p>比较有意思的地方是，在LP模式下（包括Control Mode和Escape Mode），采用的是Spaced-One-Hot Coding机制。在该机制下，时钟可以从传输的数据中得以体现，因此不需要传输时钟。此时，用户可以根据实际需求，设置Clock Lane继续运行或者关闭以降低功耗。关于Spaced-One-Hot Coding会在后面的博文中详细介绍。【注】我们常听到的LPDT模式（Low-Power Data Transmission）和ULPS模式（Ultra-Low Power State）都是Escape Mode的一种。</p><p>综上所述，也就是说，D-PHY中一共有三种Lane，Unidirectional Clock Lane 、Unidirectional Data Lane以及Bi-directional Data Lane。</p><p>需要注意的是，D-PHY的Bidirectional通信是一种半双工的双向通信模式，同时，反向传输的速度只有正向传输的1/4。</p><p>MIPI D-PHY协议中规定了两种模式：LP模式和HS模式。其中HS模式只在高速数据传输中使用，而LP模式则同时包含控制模式（Control Mode）、低功耗数据传输模式（LPDT）和极低功耗模式（ULPS）。为了方便描述，D-PHY的协议文档中定义了Lane State的描述方式（标记符号），具体如下图所示：</p><p>D-PHY的协议文档中定义了Lane State的描述方式</p><p>同时规定了Lane Type的表述方式：</p><p>Lane Type的表述方式</p><p>举例来说，对于一个Unidirectional的系统来说，主机模块中的Data Lane至少需要包含HS-TX，LP-TX和CIL-MFXN；从机模块中的Data Lane则至少需要包含HS-RX、LP-RX和CIL-SFXN。对于一个支持反向HS模式通信的Bidirectional系统来说，主机模块中的Data Lane至少需要包含HS-TX、LP-TX、LP-RX、LP-CD和CIL-MFXY；而从机模块中的Data Lane则至少需要包含HS-RX、LP-RX、LP-TX、LP-CD和CIL-SFXY。当然，Bidirectional的通信系统也可以只支持LP的反向传输，而不支持HS的反向传输。</p><p>下面详细介绍一下，Control、High-Speed和Escape操作模式的进入和退出方式：</p><p>HS模式进入：LP11→LP01→LP00→SoT（Start of Transmission）；</p><p>HS模式退出：EoT（End of Transmission）→LP11；</p><p>Escape模式进入：LP11→LP10→LP00→LP01→LP00→Entry Code；</p><p>Escape模式退出：LP10→LP11；</p><p>TX端反转数据通信方向请求（Turnaround）：LP11→LP10→LP00→LP10→LP00；</p><p>随后，等待一段时间后，RX端接管，并切换为TX端发送：LP00→LP10→LP11，切换完成。如下图所示：</p><p>MIPI 传输模式</p><p>其中，Escape模式中的Entry Code有如下几种：</p><p>MIPI 传输模式</p><p>以一次HS传输过程（即HS Data Transmission Burst）为例：</p><p>MIPI 传输模式</p><p>使用示波器观察Data Lane得到的波形图如下所示：</p><p>示波器观察Data Lane得到的波形图</p><p>示波器观察Data Lane得到的波形图</p><p>示波器观察Data Lane得到的波形图</p><p>前一篇文章中提到了，在LPDT模式下，Date Lane的时钟可以关闭，换句话说，就是LPDT模式不需要时钟同步，或者说是LPDT是异步传输数据的。下面以一次LPDT传输为例，简要地介绍一下：</p><p>示波器观察Data Lane得到的波形图</p><p>从上图中，可以发现，只要Dp和Dn上有有效内容在传输，任意两个数据之间都至少插入了一个Space State（LP00），这就是所谓的Spaced-One-Hot Coding。显然，时钟信号可以从Dp和Dn信号中恢复出来，换一句话来说，此时的数据传输是Self-clocked的。</p><p>详细的状态（模式）转移图如下图所示：</p><p>状态（模式）转移图</p><p>其中，HS模式有时也被称为Busrt Mode，Low Power Mode包括Control Mode和Escape Mode。应当注意的是，Burst Mode和Escape Mode之间不可以直接来回切换，必须通过Control Mode进行中转，即：</p><p>Burst Mode↔Control Mode↔Escape Mode</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Camera </category>
          
      </categories>
      
      
        <tags>
            
            <tag> D-PHY </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCD/CMOS靶面尺寸规格说明</title>
      <link href="/2021/11/29/sensor-ba-mian-chi-cun-gui-ge-shuo-ming/"/>
      <url>/2021/11/29/sensor-ba-mian-chi-cun-gui-ge-shuo-ming/</url>
      
        <content type="html"><![CDATA[<p>转自：<a href="https://cloud.tencent.com/developer/article/1812677" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1812677</a></p> <iframe height="850" width="90%" src="https://cloud.tencent.com/developer/article/1812677" frameborder="0" allowfullscreen=""> </iframe><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> camera </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sensor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决cmder中vim退出后总是清屏</title>
      <link href="/2021/10/21/jie-jue-cmder-zhong-vim-tui-chu-hou-zong-shi-qing-ping/"/>
      <url>/2021/10/21/jie-jue-cmder-zhong-vim-tui-chu-hou-zong-shi-qing-ping/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>使用cmder中连接远程服务器，在用vim编辑或查看完文档退出后，屏幕总是清空，没有了之前的输入输出。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>vim等文档编辑工具退出后，屏幕执行清屏还是保留，是根据TERM变量判断的。<br>TERM取值：<br>‘待补充’</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>cmder在启动时，改值设置问cygwin，是清屏操作。<br>如果要保留屏幕历史记录，可以cmder/vendor/init.bat中修改xterm值，设置为 xterm或xterm-256color</p><pre><code>if not defined TERM set TERM=xterm-256color</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ndk-build脚本</title>
      <link href="/2021/07/30/ndk-build-jiao-ben/"/>
      <url>/2021/07/30/ndk-build-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h1 id="ndk-build脚本"><a href="#ndk-build脚本" class="headerlink" title="ndk-build脚本"></a>ndk-build脚本</h1><h2 id="ndk-build配置"><a href="#ndk-build配置" class="headerlink" title="ndk-build配置"></a>ndk-build配置</h2><p>ndk-build编译默认通过解析jni目录下的Android.mk和Application.mk两个文件获取编译行为。项目编译的关键就是配置好这两个文件。</p><h2 id="Android-mk"><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h2><p>脚本如下：</p><pre><code>#展示构建一个项目，项目结构如下；#64bitARM： demo.exe &lt;--share_lib_b.so &lt;--static_lib_c.a#                     &lt;--static_e.a#                 &lt;--prebuild_lib_d.so#32bitARM： demo.exe &lt;--share_lib_b.so &lt;--static_lib_c.a#                     &lt;--static_e.a#此变量用于指定当前文件的路径。必须在 Android.mk 文件开头定义此变量。LOCAL_PATH := $(call my-dir)$(info LOCAL_PATH=$(LOCAL_PATH))$(info PRODUCT_OUT=$(PRODUCT_OUT))$(info TARGET_COPY_OUT_VENDOR=$(TARGET_COPY_OUT_VENDOR))$(info TARGET_ARCH_ABI =$(TARGET_ARCH_ABI))#LOCAL_MODULE#此变量用于存储模块名称。指定的名称在所有模块名称中必须唯一，并且不得包含任何空格。您必须先定义该名称，#然后才能添加任何脚本（CLEAR_VARS 的脚本除外）。无需添加 lib 前缀或 .so 或 .a 文件扩展名；#构建系统会自动执行这些修改。在整个 Android.mk 和 Application.mk 文件中，请用未经修改的名称引用模块。LOCAL_MODULE := static_lib_c#LOCAL_SRC_FILES 源文件LOCAL_SRC_FILES := ../src/static_lib_c.cpp#LOCAL_INC_FILES 头文件LOCAL_INC_FILES := static_lib_c.h#头文件所在位置LOCAL_C_INCLUDES :=  $(LOCAL_PATH)/../inc# #编译C文件时的flag信息# LOCAL_CFLAGS := -DTEST=tureLOCAL_CPPFLAGS := -DTEST=false#编译CPP文件时的头文件信息#LOCAL_MULTILIB 将 build 配置为适用于 32 位/64 位架构，并替换全局 TARGET_PREFER_32_BIT 变量。#将 LOCAL_MULTILIB 设置为以下其中一项：#"both" 同时构建 32 位和 64 位架构。#"32" 仅构建 32 位架构。#"64" 仅构建 64 位架构。#"first" 仅构建第一个架构（在 32 位设备中构建 32 位架构，在 64 位设备中构建 64 位架构）。#默认为 ""。构建系统根据模块类和其他 LOCAL_ 变量（如 LOCAL_MODULE_TARGET_ARCH 和 LOCAL_32_BIT_ONLY）决定要构建哪种架构。LOCAL_MULTILIB = both#include 模块定义结束include $(BUILD_STATIC_LIBRARY)#清理变量，再定义一个static_lib_e.ainclude $(CLEAR_VARS)LOCAL_MODULE := static_lib_eLOCAL_SRC_FILES :=  ../src/static_lib_e.cppLOCAL_INC_FILES := static_lib_e.hLOCAL_C_INCLUDES :=  $(LOCAL_PATH)/../inc# LOCAL_CFLAGS := -DTEST=tureLOCAL_CPPFLAGS := -DTEST=falseLOCAL_MULTILIB := bothinclude $(BUILD_STATIC_LIBRARY)#清理变量，再定义一个share_lib_binclude $(CLEAR_VARS)LOCAL_MODULE := share_lib_bLOCAL_SRC_FILES :=  ../src/share_lib_b.cppLOCAL_INC_FILES := share_lib_b.hLOCAL_C_INCLUDES :=  $(LOCAL_PATH)/../incLOCAL_CPPFLAGS := -DTEST=falseLOCAL_STATIC_LIBRARIES := static_lib_cLOCAL_MULTILIB := bothinclude $(BUILD_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := prebuild_lib_d#LOCAL_MODULE_CLASS 将用于决定编译时的中间文件存放的位置,取值范围：ETC,STATIC_LIBRARIES,EXECUTABLES,FAKE,JAVA_LIBRARIES,SHARED_LIBRARIES,APPS#比如: SHARED_LIBRARIES, 通常#include()时会自动识别，不需要手动定义，一般在include $(BUILD_PREBUILT)时需要定义该变量，以便系统知道预编译文件类型。LOCAL_MODULE_CLASS := SHARED_LIBRARIES#LOCAL_MODULE_SUFFIX 生成模块的后缀，一般常见的模块都有默认后缀，可以不用定义，如 .so, .aLOCAL_MODULE_SUFFIX := .so#LOCAL_STRIP_MODULE意思是把so的一些调试信息去掉，符号表啊什么的，这些是debug用的，，stip之后把这些东西去掉，可以让so变小，，#通俗地讲就是一个debug版本，一个是release版本#6.0之后，系统里面强制要strip so库，，如果你的so已经strip过了，再次strip就会报错，所以需要在android mk文件中加上这一句，不让它strip。#通常在incluce$(BUILD_PREBUILT)时定义改变量。LOCAL_STRIP_MODULE := false#定义模块的拥有者，比如QCOM，sangsong，huaweiLOCAL_MODULE_OWNER := customLOCAL_MULTILIB      := 64#user eng tests optional#user: 指该模块只在user版本下才编译#eng: 指该模块只在eng版本下才编译#tests: 指该模块只在tests版本下才编译#optional:指该模块在所有版本下都编译#一般不编img时不用设置变量LOCAL_MODULE_TAGS   := optional#指定文件所在路径，在BUILD_PREBUILD模式下会拷贝该文件到目标路径下LOCAL_SRC_FILES     :=  $(LOCAL_PATH)/../prebuild_lib64/libprebuild_lib_d.so#目标路径地址LOCAL_MODULE_PATH   := $(PRODUCT_OUT)/$(TARGET_COPY_OUT_VENDOR)/lib64#是否为供应商专有模块，如果是，必须放在vendorVendor模块是特定于供应商的可执行文件或共享库（必须将这些模块安装到供应商分区中）。#在 Android.bp 文件中，供应商模块必须将 vendor 或 proprietary 属性设为 true。#在 Android.mk 文件中，供应商模块必须将 LOCAL_VENDOR_MODULE 或 LOCAL_PROPRIETARY_MODULE 设为 trueLOCAL_PROPRIETARY_MODULE := trueinclude $(BUILD_PREBUILT)include $(CLEAR_VARS)LOCAL_MODULE := demoLOCAL_SRC_FILES :=  ../src/demo.cppLOCAL_INC_FILES := demo.hLOCAL_C_INCLUDES :=  $(LOCAL_PATH)/../incLOCAL_CPPFLAGS := -DTEST=falseLOCAL_STATIC_LIBRARIES := static_lib_eLOCAL_SHARED_LIBRARIES := share_lib_bifeq ($(TARGET_ARCH_ABI),arm64-v8a)    LOCAL_SHARED_LIBRARIES += libaivideoendif$(info LOCAL_SHARED_LIBRARIES=$(LOCAL_SHARED_LIBRARIES))LOCAL_MULTILIB := bothinclude $(BUILD_EXECUTABLE)</code></pre><h2 id="Application-mk"><a href="#Application-mk" class="headerlink" title="Application.mk"></a>Application.mk</h2><p>脚本如下：</p><pre><code>#Application.mk是配置目标 ABI、工具链、发布/调试模式和 STL的文件，其中的配置参数可以参考网站#https://developer.android.com/ndk/guides/application_mk#app_ldflags#常用的基本配置如下:NDK_TOOLCHAIN_VERSION := clang#APP_PLATFORM 会声明构建此应用所面向的 Android API 级别，并对应于应用的 minSdkVersion。#如果未指定，ndk-build 将以 NDK 支持的最低 API 级别为目标。最新 NDK 支持的最低 API 级别总是足够低，可以支持几乎所有有效设备。指定版本过高可能存在低版本不支持的情况APP_PLATFORM := android-29# APP_ABI 默认情况下，NDK 构建系统会为所有非弃用 ABI 生成代码。您可以使用 APP_ABI 设置为特定 ABI 生成代码。表 1 显示了不同指令集的 APP_ABI 设置。#      指令集                            值#   32 位 ARMv7                   APP_ABI := armeabi-v7a#   64 位 ARMv8 (AArch64)          APP_ABI := arm64-v8a#   x86                              APP_ABI := x86#   x86-64                          APP_ABI := x86_64#所有支持的 ABI（默认）              APP_ABI := allAPP_ABI := arm64-v8a # armeabi-v7a#APP_STL 用于此应用的 C++ 标准库。#默认情况下使用 system STL。其他选项包括 c++_shared、c++_static 和 noneAPP_STL := c++_shared#APP_CPPFLAGS 要为项目中的所有 C++ 编译传递的标记。这些标记不会用于 C 代码APP_CPPFLAGS += -std=c++17 -fexceptions -frtti                #APP_LDFLAGS 关联可执行文件和共享库时要传递的标记。APP_LDFLAGS = -nodefaultlibs -lc -lm -ldl -lgcc</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ndk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndk-build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android常用编译指令</title>
      <link href="/2021/07/28/android-chang-yong-bian-yi-zhi-ling/"/>
      <url>/2021/07/28/android-chang-yong-bian-yi-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="android常用编译指令"><a href="#android常用编译指令" class="headerlink" title="android常用编译指令"></a>android常用编译指令</h1><h2 id="PRODUCT-COPY-FILES-和-BUILD-PREBUILT"><a href="#PRODUCT-COPY-FILES-和-BUILD-PREBUILT" class="headerlink" title="PRODUCT_COPY_FILES 和 BUILD_PREBUILT"></a>PRODUCT_COPY_FILES 和 BUILD_PREBUILT</h2><h3 id="PRODUCT-COPY-FILES"><a href="#PRODUCT-COPY-FILES" class="headerlink" title="PRODUCT_COPY_FILES"></a>PRODUCT_COPY_FILES</h3><p>PRODUCT_COPY_FILES变量主要用于执行编译前的一些拷贝操作，语法如下：</p><pre><code>PRODUCT_COPY_FILES += \    &lt;source file&gt;:&lt;dest file&gt;</code></pre><p>该变量在<a href="https://android.googlesource.com/platform/build/+/refs/heads/oreo-release/core/product.mk#301" target="_blank" rel="noopener">build/make/core/product.mk</a>脚本之后变为只读状态。<br>要修改该变量要在build/make/core/product.mk之前修改。<br>如果需要在build/make/core/product.mk之后添加拷贝可以用：</p><h3 id="BUILD-PREBUILT"><a href="#BUILD-PREBUILT" class="headerlink" title="BUILD_PREBUILT"></a>BUILD_PREBUILT</h3><p>BUILD_PREBUILT 把拷贝操作当成一个项目操作，语法如下：</p><pre><code>include $(CLEAR_VARS)LOCAL_MODULE        := libxxxLOCAL_MODULE_CLASS  := SHARED_LIBRARIESLOCAL_MODULE_SUFFIX := .soLOCAL_STRIP_MODULE  := falseLOCAL_MULTILIB      := 64LOCAL_MODULE_OWNER  := qcomLOCAL_MODULE_TAGS   := optionalLOCAL_SRC_FILES     := ./lib64/libxxx.soLOCAL_MODULE_PATH   := $(PRODUCT_OUT)/$(TARGET_COPY_OUT_VENDOR)/lib64LOCAL_PROPRIETARY_MODULE := trueinclude $(BUILD_PREBUILT)</code></pre><p>异同：<br>PRODUCT_COPY_FILES 和 BUILD_PREBUILT都可以执行拷贝操作，不同点在于PRODUCT_COPY_FILES的拷贝在生成<strong>img</strong>时会打包进去，BUILD_PREBUILT的拷贝不会被打包，需要在PRODUCT_PACKAGES中添加local才可以。<br>如下:</p><pre><code>PODUCT_PACKAGES += \          libxxx</code></pre><p>或者通过LOCAL_MODULE_TAGS变量在编译时动态控制。</p><h2 id="PODUCT-PACKAGES"><a href="#PODUCT-PACKAGES" class="headerlink" title="PODUCT_PACKAGES"></a>PODUCT_PACKAGES</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ndk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ndk-build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clangd安装</title>
      <link href="/2021/03/24/clangd-an-zhuang/"/>
      <url>/2021/03/24/clangd-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="ubuntu-安装-clangd"><a href="#ubuntu-安装-clangd" class="headerlink" title="ubuntu 安装 clangd"></a>ubuntu 安装 clangd</h1><h2 id="正常通过apt-get安装即可"><a href="#正常通过apt-get安装即可" class="headerlink" title="正常通过apt-get安装即可"></a>正常通过apt-get安装即可</h2><pre class=" language-shell"><code class="language-shell">sudo apt-get install clangd</code></pre><p>顺利的话，通过以上命令即可安装。</p><h2 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h2><h3 id="找不到源"><a href="#找不到源" class="headerlink" title="找不到源"></a>找不到源</h3><p>通常情况下如果你没有配置过专门的apt.source.list源的话，会报找不到安装包的问题。这时候需要配置源文件，<br>cat /etc/apt/apt.source.list<br>以ubuntu 16.04为例添加如下命令：(不同版本源不同，参考<a href="https://apt.llvm.org/" target="_blank" rel="noopener">https://apt.llvm.org/</a>)</p><pre class=" language-shell"><code class="language-shell">deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial maindeb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial main</code></pre><h3 id="找不到签名"><a href="#找不到签名" class="headerlink" title="找不到签名"></a>找不到签名</h3><p>添加源后，执行apt-get update可能汇报签名错误，如下</p><pre class=" language-shell"><code class="language-shell">The following signatures couldn't be verified because the public key is not available: NO_PUBKEY 15CF4D18AF4F7421</code></pre><p>需要继续添加签名文件<br>以old-stable 分支为例，执行</p><pre class=" language-shell"><code class="language-shell">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add -</code></pre><p>执行成功之后再次执行</p><pre class=" language-shell"><code class="language-shell">sudo apt-get updatesudo apt-get install clangd</code></pre><p>不出意外的话，应该可以安装成功。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编译工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clangd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oh-my-zsh终端</title>
      <link href="/2021/03/18/oh-my-zsh-zhong-duan/"/>
      <url>/2021/03/18/oh-my-zsh-zhong-duan/</url>
      
        <content type="html"><![CDATA[<p><em>主要转自：<a href="https://www.itshutong.com/articles/281/oh-my-zsh-the-best-shell-none，有部分修改" target="_blank" rel="noopener">https://www.itshutong.com/articles/281/oh-my-zsh-the-best-shell-none，有部分修改</a></em></p><p>命令行是程序员的最爱，默认的 bash shell 虽然功能已经很强大，但显得太朴素了，也不够智能，远远谈不上酷炫，虽然已经远远将 windows 的 cmd 甩开几百条街。但对于极客来说，bash 还是太弱了，长得也难看。</p><p><code>zsh</code> 的功能比bash强大很多，但配置过于复杂，起初只有极客才在用。后来，有个穷极无聊的程序员可能是实在看不下去广大猿友一直只能使用单调的bash, 于是他创建了一个名为 <code>oh-my-zsh</code> 的开源项目…</p><p>自此，只需要简单的安装配置，小白程序员们都可以用上高档大气上档次，狂拽炫酷吊炸天的 <a href="https://ohmyz.sh/" target="_blank" rel="noopener">oh-my-zsh</a></p><p><img src="https://image-1253761983.picgz.myqcloud.com/2019-08-18-124800.png" alt="img"></p><h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><p>以centos7为例：(mac也是类似的操作)</p><p>查看系统是否安装了zsh，如果没找到 <code>/bin/zsh</code> ，就需要先安装</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/shells /bin/sh/bin/bash/sbin/nologin/usr/bin/sh/usr/bin/bash/usr/sbin/nologin/bin/tcsh/bin/csh</code></pre><p>Bash</p><blockquote><p>centos7默认情况下没安装zsh</p></blockquote><p>用 <code>yum</code> 安装 <code>zsh</code></p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> yum -y <span class="token function">install</span> zsh</code></pre><p>Bash</p><p>安装成功</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/shells <span class="token operator">|</span> <span class="token function">grep</span> zsh/bin/zsh</code></pre><p>Bash</p><p>切换shell为zsh</p><pre class=" language-bash"><code class="language-bash">$ chsh -s /bin/zshChanging shell <span class="token keyword">for</span> root.Shell changed.</code></pre><p>Bash</p><p>退出，重启终端，可看到shell已切换成功</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$SHELL</span> /bin/zsh</code></pre><p>Bash</p><h2 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh my zsh"></a>安装 oh my zsh</h2><p>一行命令即可自动化安装</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">wget</span> https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - <span class="token operator">|</span> sh</code></pre><p>Bash</p><p>成功界面：</p><p><img src="https://image-1253761983.picgz.myqcloud.com/2019-06-14-031820.png" alt="img"></p><p>退出重新登入终端，即可看到oh-my-zsh已经生效</p><p>接下来只需简单的配置，就可以享受 <code>oh-my-zsh</code> 的强大</p><h2 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h2><p>oh-my-zsh有很多漂亮的主题:</p><p>在 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="noopener">主题列表</a> 中选择自己心宜的主题，安装很简单，打开配置文件 <code>~/.zhsrc</code> ，将 <code>ZSH_THEME</code> 值改为你所选的主题名称<br>主题文件在”.oh-my-zsh/themes”文件夹下，可自行查看支持的主题。<br>如：</p><pre class=" language-bash"><code class="language-bash">$ vim ~/.zshrc<span class="token comment" spellcheck="true"># 修改主题名称</span>ZSH_THEME<span class="token operator">=</span><span class="token string">"cloud"</span></code></pre><p>然后重新加载配置文件</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">source</span> ~/.zshrc</code></pre><blockquote><p>每次修改配置文件后，都需要再次加载配置文件才能生效</p></blockquote><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>oh-my-zsh默认安装了git插件，在git仓库中，会提示当前所在的分支。此外，还有大量优秀的插件，具体可查看 <a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins" target="_blank" rel="noopener">插件仓库</a>，以下只介绍几个我常用的插件</p><ul><li>extract</li></ul><p>linux下的压缩文件有多种格式，我总是忘记不同格式的解压命令，如果有一个通用的指令可以解压所有文件就好了，<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/extract" target="_blank" rel="noopener">extract</a> 插件就能解决此问题</p><p>现在不管是 <code>zip, tar.bz2, gz</code> 等格式的压缩文件，都只需要执行 <code>extract 文件名</code> 即可</p><ul><li>z</li></ul><p><a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/z" target="_blank" rel="noopener">z</a> 插件可以智能在历史的cd命令中智能地选择指令，如，我们在终端执行过<code>cd /usr/local/nginx/conf/vhost</code>，以后只需要执行<code>z vhost</code>即可，不必再去敲长串的命令了</p><blockquote><p>以上两个插件都是<code>oh-my-zsh</code>自带的，只需要在配置文件的plugins配置中加入插件名称即可，多个插件用空格隔开</p></blockquote><ul><li>zsh-autosuggestions</li></ul><p><a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">zsh-autosuggestions</a> 属于第三方插件，可以提示我们插入历史命令</p><p>如，我执行过 <code>php artisan ide-helper:generate</code> 指令，下次当我输入 <code>php</code> 时，就会自动提示指令，并且会随着我们的输入而实时地匹配最符合的历史指令，当所提示的指令符合我们的预期，只需要按右箭头即可补全</p><p><img src="https://image-1253761983.picgz.myqcloud.com/2019-06-14-035331.png" alt="img"></p><p><a href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md" target="_blank" rel="noopener">安装此插件的流程</a>：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/zsh-users/zsh-autosuggestions <span class="token variable">${ZSH_CUSTOM:-~/.oh-my-zsh/custom}</span>/plugins/zsh-autosuggestions</code></pre><p>Bash</p><p>在配置文件中中添加插件名称</p><p>综上，配置文件plugins的内容如下：</p><pre class=" language-bash"><code class="language-bash">plugins<span class="token operator">=</span><span class="token punctuation">(</span>  <span class="token function">git</span>  extract  z  zsh-autosuggestions<span class="token punctuation">)</span></code></pre><p>Bash</p><p>重新载入配置文件，即可生效</p><h2 id="卸载-Oh-My-Zsh"><a href="#卸载-Oh-My-Zsh" class="headerlink" title="卸载 Oh My Zsh"></a>卸载 Oh My Zsh</h2><p>终端输入 ：</p><pre class=" language-bash"><code class="language-bash">uninstall_oh_my_zshAre you sure you want to remove Oh My Zsh? <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span>  Y</code></pre><p>终端提示信息：</p><pre class=" language-bash"><code class="language-bash">Removing ~/.oh-my-zshLooking <span class="token keyword">for</span> original zsh config<span class="token punctuation">..</span>.Found ~/.zshrc.pre-oh-my-zsh -- Restoring to ~/.zshrcFound ~/.zshrc -- Renaming to ~/.zshrc.omz-uninstalled-20170820200007Your original zsh config was restored. Please restart your session.Thanks <span class="token keyword">for</span> trying out Oh My Zsh. It's been uninstalled.</code></pre><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><p>以下是可能遇到的小问题</p><h3 id="与vim的提示相冲突"><a href="#与vim的提示相冲突" class="headerlink" title="与vim的提示相冲突"></a>与vim的提示相冲突</h3><p>使用自动补全插件可能会与vim的提示功能相冲突，如会报以下错误：</p><pre class=" language-bash"><code class="language-bash">$ vim t_arguments:451: _vim_files: <span class="token keyword">function</span> definition <span class="token function">file</span> not found</code></pre><p>Bash</p><p>解决方法：将<code>~/.zcompdump*</code>删除即可</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">rm</span> -rf ~/.zcompdump*$ <span class="token function">exec</span> zsh</code></pre><p>Bash</p><h3 id="卡顿"><a href="#卡顿" class="headerlink" title="卡顿"></a>卡顿</h3><p>有时候执行 <code>cd</code> 会卡，这让人难以忍受。原因是 <code>oh-my-zsh</code> 在获取 git 信息，可以将 git 信息隐藏：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global oh-my-zsh.hide-status 1</code></pre><p>Bash</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于 <code>oh-my-zsh</code> 的功能，本文所涉及的仅是冰山一角，这些已经足够我平时使用了，极大提高了效率，相信我，一旦用过这个尤物，你再也不能忍受单调枯燥的 <code>bash</code> 了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bat脚本不弹窗执行</title>
      <link href="/2021/01/25/bat-jiao-ben-bu-dan-chuang-yun-xing/"/>
      <url>/2021/01/25/bat-jiao-ben-bu-dan-chuang-yun-xing/</url>
      
        <content type="html"><![CDATA[<p>目的：<br>  通过脚本执行一个长期服务的时候，不希望服务一直在前台运行，在点击脚本后，自动切到后台。<br>  以adbforward为例。</p><pre class=" language-shell"><code class="language-shell"> @echo offif "%1"=="h" goto beginstart mshta vbscript:createobject("wscript.shell").run("""%~nx0"" h",0)(window.close)&&exit:begin::以下为正常批处理命令，不可含有pause set/p等交互命令java -jar E:\tools\adbforward\windows\adb-forward-windows\adbportforward.jar server adblocation=E:\tools\adbforward\windowspause</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理经典网络</title>
      <link href="/2020/07/07/tu-xiang-chu-li-jing-dian-wang-luo/"/>
      <url>/2020/07/07/tu-xiang-chu-li-jing-dian-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="图像处理经典网络整理"><a href="#图像处理经典网络整理" class="headerlink" title="图像处理经典网络整理"></a>图像处理经典网络整理</h1><h2 id="图像分类网络"><a href="#图像分类网络" class="headerlink" title="图像分类网络"></a>图像分类网络</h2><ul><li>MobileNet-series </li><li>Resnet-series</li><li>Inception-series<h2 id="图像检测-分割类网络"><a href="#图像检测-分割类网络" class="headerlink" title="图像检测/分割类网络"></a>图像检测/分割类网络</h2></li><li>SSD-series</li><li>Unet</li><li>DeepLab V3+<h2 id="图像质量类"><a href="#图像质量类" class="headerlink" title="图像质量类"></a>图像质量类</h2></li><li>SID</li><li>EDSR</li><li>VDSR</li><li>SRGAN</li><li>FSRCNN</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu install android sdk ndk</title>
      <link href="/2020/06/08/ubuntu-install-android-sdk-ndk/"/>
      <url>/2020/06/08/ubuntu-install-android-sdk-ndk/</url>
      
        <content type="html"><![CDATA[<h1 id="sdk安装"><a href="#sdk安装" class="headerlink" title="sdk安装"></a>sdk安装</h1><h2 id="安装-android-sdk"><a href="#安装-android-sdk" class="headerlink" title="安装 android-sdk"></a>安装 android-sdk</h2><pre><code>sudo apt install android-sdk</code></pre><h2 id="下载cmdline-tool"><a href="#下载cmdline-tool" class="headerlink" title="下载cmdline-tool"></a>下载<a href="https://developer.android.com/studio/index.html#downloads" target="_blank" rel="noopener">cmdline-tool</a></h2><pre><code>wget https://dl.google.com/android/repository/commandlinetools-linux-6514223_latest.zipunzip commandlinetools-linux-6514223_latest.zip</code></pre><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><ul><li><p>在上步解压的zip文件到android-sdk路径”/usr/lib/android-sdk/“新建”mkdir cmdline-tools”，拷贝解压文件到“/usr/lib/android-sdk/cmdline-tools”</p></li><li><p>修改”~/.bashrc文件，增加以下内容，source ~/ .bashrc文件生效。</p></li><li><pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> ANDROID_SDK_ROOT<span class="token operator">=</span>/usr/lib/android-sdk<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PATH</span><span class="token keyword">:</span><span class="token variable">$NDK</span><span class="token keyword">:</span><span class="token variable">$ANDROID_SDK_ROOT</span>/cmdline-tools/tools/bin</code></pre></li></ul><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul><li>sdkmanager –version 输出版本号<h2 id="查看已安装和可用的平台"><a href="#查看已安装和可用的平台" class="headerlink" title="查看已安装和可用的平台"></a>查看已安装和可用的平台</h2><pre><code>sdkmanager --sdk_root=/usr/lib/android-sdk --proxy=http --proxy_host=xxx.xxx.com --proxy_port=8080  --list</code></pre>如果不需要代理，可以只用’sdkmanager –sdk_root=/usr/lib/android-sdk  –list’</li></ul><h2 id="下载编译平台"><a href="#下载编译平台" class="headerlink" title="下载编译平台"></a>下载编译平台</h2><pre><code>  sdkmanager --sdk_root=/usr/lib/android-sdk --proxy=http --proxy_host=xxx.xxx.com .com --proxy_port=8080  "platform-tools" "ndk;18.1.5063045" "platforms;android-29" </code></pre><h1 id="只需要ndk中的adb等工具可以只下载ndk文件，配置一下环境变量。"><a href="#只需要ndk中的adb等工具可以只下载ndk文件，配置一下环境变量。" class="headerlink" title="只需要ndk中的adb等工具可以只下载ndk文件，配置一下环境变量。"></a>只需要ndk中的adb等工具可以只下载ndk文件，配置一下环境变量。</h1><h2 id="下载-amp-解压"><a href="#下载-amp-解压" class="headerlink" title="下载&amp;解压"></a>下载&amp;解压</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> https://dl.google.com/android/repository/android-ndk-r20b-linux-x86_64.zip?hl<span class="token operator">=</span>zh_cnunzip android-ndk-r20b-linux-x86_64.zip?hl<span class="token operator">=</span>zh_cn</code></pre><h2 id="配置环境变量-bashrc文件"><a href="#配置环境变量-bashrc文件" class="headerlink" title="配置环境变量~/.bashrc文件"></a>配置环境变量~/.bashrc文件</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> NDK<span class="token operator">=</span>xxx/android-ndk-r20b<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PATH</span><span class="token keyword">:</span><span class="token variable">$NDK</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编译工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> sdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>build with Bazel</title>
      <link href="/2020/06/08/build-with-bazel/"/>
      <url>/2020/06/08/build-with-bazel/</url>
      
        <content type="html"><![CDATA[<h1 id="build-with-Bazel"><a href="#build-with-Bazel" class="headerlink" title="build with Bazel"></a>build with <a href="https://docs.bazel.build/versions/master/bazel-overview.html" target="_blank" rel="noopener">Bazel</a></h1><h2 id="what-is-Bazel"><a href="#what-is-Bazel" class="headerlink" title="what is Bazel?"></a>what is Bazel?</h2><p>What is Bazel?<br>Bazel is an open-source build and test tool similar to Make, Maven, and Gradle. It uses a human-readable, high-level build language. Bazel supports projects in multiple languages and builds outputs for multiple platforms. Bazel supports large codebases across multiple repositories, and large numbers of users.</p><h2 id="how-to-install-Bazel"><a href="#how-to-install-Bazel" class="headerlink" title="how to install Bazel?"></a>how to install Bazel?</h2><ul><li><p>安装编译bazel的依赖工具</p><pre class=" language-makefile"><code class="language-makefile">sudo apt-get install build-essential openjdk-8-jdk python zip unzip</code></pre></li><li><p>下载安装包：</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">wget https</span><span class="token punctuation">:</span>//github.com/bazelbuild/bazel/releases/download/3.2.0/bazel-3.2.0-dist.zip --no-check-certificate</code></pre></li><li><p>解压</p><pre class=" language-makefile"><code class="language-makefile"> unzip  bazel-3.2.0-dist.zip -d bazel-3.2.0-dist cd bazel-3.2.0-dist</code></pre></li><li><p>编译&amp;安装</p><pre class=" language-makefile"><code class="language-makefile">env EXTRA_BAZEL_ARGS<span class="token operator">=</span><span class="token string">"--host_javabase=@local_jdk//:jdk"</span> bash ./compile.shsudo cp output/bazel /usr/local/bin/</code></pre><ul><li>如果联网需要代理，需要使用cntlm配置代理，<pre><code>export http_proxy=http://127.0.0.1:xxxx</code></pre><h2 id="build-with-Bazel-1"><a href="#build-with-Bazel-1" class="headerlink" title="build with Bazel"></a>build with Bazel</h2>以<a href="https://github.com/tensorflow/tensorflow.git" target="_blank" rel="noopener">tensorflow lite</a>为例，clone 工程到本地目录。<br>配置工程目录下的configure文件，’./configure’。根据自己的硬件配置，开关相应的选项。<br>[操作引导]（<a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/lite/tools/benchmark）" target="_blank" rel="noopener">https://github.com/tensorflow/tensorflow/tree/master/tensorflow/lite/tools/benchmark）</a><pre><code>bazel build -c opt --config=android_arm64 tensorflow/lite/tools/benchmark:benchmark_model</code></pre></li><li>如果出现网站鉴权问题，可以配置bazel如下*<pre><code>alias bazel="bazel --host_jvm_args=-Djavax.net.ssl.trustStore='/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/security/cacerts' --host_jvm_args=-Djavax.net.ssl.trustStorePassword='changeit'"</code></pre>同时将对应需要鉴权的网站加入到cacerts文件，相关操作可以<a href="https://blog.csdn.net/wangjunjun2008/article/details/37662851" target="_blank" rel="noopener">参考</a></li></ul><h2 id="如何使用Bazel编译c-java-android"><a href="#如何使用Bazel编译c-java-android" class="headerlink" title="如何使用Bazel编译c++,java,android"></a>如何使用Bazel编译<a href="https://docs.bazel.build/versions/master/bazel-overview.html#how-do-i-get-started" target="_blank" rel="noopener">c++,java,android</a></h2></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编译工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bazel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>todo</title>
      <link href="/2020/06/08/todo/"/>
      <url>/2020/06/08/todo/</url>
      
        <content type="html"><![CDATA[<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><p><em>此列表记录需要做，还没做的事情</em></p><h2 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h2><h3 id="高效工作方法"><a href="#高效工作方法" class="headerlink" title="高效工作方法"></a>高效工作方法</h3><ul><li>5W2H法则</li><li>SWOT</li><li>PDCA</li><li>5W2H</li><li>SMART</li><li>WBS</li><li>时间管理</li><li>二八原则</li></ul><hr><h2 id="book"><a href="#book" class="headerlink" title="book"></a>book</h2><p>售梦人</p><hr><h2 id="moves"><a href="#moves" class="headerlink" title="moves"></a>moves</h2><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 待办 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建jupyter notebook 远程服务器</title>
      <link href="/2020/04/13/da-jian-jupyter-notebook-yuan-cheng-fu-wu-qi/"/>
      <url>/2020/04/13/da-jian-jupyter-notebook-yuan-cheng-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建jupyter远程服务器"><a href="#搭建jupyter远程服务器" class="headerlink" title="搭建jupyter远程服务器"></a>搭建jupyter远程服务器</h1><h2 id="购买云主机"><a href="#购买云主机" class="headerlink" title="购买云主机"></a>购买云主机</h2><ul><li><p>首先去华为云，阿里云，腾讯云，亚马逊云等任一云平台购买一台云主机，如果自己有接入外网的云主机也可以。</p></li><li><p>开通云主机上的jupyter远程端口，端口号可以随便设置，例如我设一个：1357<br><img src="1357.png" alt="image.png"></p><h2 id="搭建jupyter"><a href="#搭建jupyter" class="headerlink" title="搭建jupyter"></a>搭建jupyter</h2><h3 id="首先为安装conda"><a href="#首先为安装conda" class="headerlink" title="首先为安装conda"></a>首先为安装conda</h3><p>去下图网页复制linux python3.7 64bit对应的minconda链接。如果你的想安装在其它系统上或者想要Python2版本，可以复制对应链接。<br><img src="conda.png" alt="image.png"></p></li><li><p>登陆云主机，创建conda文件夹，用于安装conda和jupyter</p><pre class=" language-shell"><code class="language-shell">mkdir conda</code></pre></li><li><p>通过刚才复制的链接，下载minconda</p><pre class=" language-shell"><code class="language-shell">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</code></pre></li><li><p>下载完成后，是一个Miniconda3-latest-Linux-x86_64.sh文件，运行sh文件，</p><pre class=" language-shell"><code class="language-shell">bash Miniconda3-latest-Linux-x86_64.sh</code></pre><p>输出应该是如下的<br><img src="bash.png" alt="image.png"><br>内容很多，可以直接按enter键，显示license，比较长，可以直接按q键退出，<br>显示如下<br><img src="license.png" alt="image.png"><br>输入yes，显示如下<br><img src="path.png" alt="image.png"><br>提示安装的目录，第一个是默认的路径，第二个是我输入指定的路径。<br>系统会自动安装需要的工具，安装完后，会提示是否将环境初始化的工作放到.bashrc文件中，以后开机可以自动初始化。如下所示，输入yes<br><img src="init.png" alt="image.png"><br>安装完后，可以看到指定路径下多了一个指定的文件夹，例如我的是minconda3</p></li><li><p>运行.bashrc初始化环境。</p><pre class=" language-shell"><code class="language-shell">.~/.bashrc</code></pre></li><li><p>更新conda，也可以不更新，不过可能有些工具包更新了，建议更新一下</p><pre class=" language-shell"><code class="language-shell">conda upgrade conda</code></pre></li><li><p>安装好conda之后，就可以创建虚拟环境了，例如创建一个jupyter虚拟环境。</p><pre class=" language-shell"><code class="language-shell">conda create -n jupyter python=3.7 y</code></pre><p>创建后显示如下，<br><img src="jupyter.png" alt="image.png"><br>可以激活了，输入</p></li></ul><pre class=" language-shell"><code class="language-shell">conda activate jupyter</code></pre><p>激活环境后，在命令行前会有”(jupyter)”提示，显示jupyter已经激活了。可以通过<br>python –verison 和pip –verison查看python和pip的版本，应该是3.7和对应的pip版本号。</p><h3 id="安装jupyter"><a href="#安装jupyter" class="headerlink" title="安装jupyter"></a>安装jupyter</h3><p>在jupyter虚拟环境中，通过pip安装jupyter安装包。</p><pre class=" language-shell"><code class="language-shell">pip install jupyter</code></pre><p>安装完成后，查看jupyter版本：</p><pre class=" language-shell"><code class="language-shell">jupyter --verison</code></pre><p>在conda目录下创建一个jupyter目录：</p><pre class=" language-shell"><code class="language-shell">mkdir jupyter_homecd jupyter_home</code></pre><p>在jupyter_home目录下运行notebook：</p><pre class=" language-shell"><code class="language-shell">jupyter notebook</code></pre><p>显示如下：<br><img src="activate.png" alt="image.png"><br>此时可以通过localhost：8888访问jupyter，如果想要远程访问，还需要做一些额外的配置。<br>ctrl+c关闭jupyter。</p><h3 id="配置远程访问"><a href="#配置远程访问" class="headerlink" title="配置远程访问"></a>配置远程访问</h3><p>进入python环境，输入如下命令</p><pre class=" language-shell"><code class="language-shell">from IPython.lib import passwdpasswd()</code></pre><p>然后根据提示输入密码，验证密码，最后会打印一串sha1编码,拷贝sha1哪一行保存一下，留用。<br>如下图<br><img src="sha1.png" alt="image.png"><br>退出python编译模式，命令行输入</p><pre class=" language-shell"><code class="language-shell">jupyter notebook --generate-config</code></pre><p>显示如下：<br><img src="config.png" alt="image.png"><br>编辑生成的jupyter_notebook_config.py文件：<br>在文件开始添加如下内容：</p><pre><code>c.NotebookApp.allow_remote_access = Truec.NotebookApp.ip = "*"c.NotebookApp.open_browser = Falsec.NotebookApp.password = "sha1:xxxxxxxx"c.NotebookApp.port = 1357c.NotebookApp.notebook_dir = "/home/ubuntu/conda/jupyter_home"</code></pre><p>其中：<br>c.NotebookApp.ip = “*”  //允许访问jupyter的ip地址，*表示任意ip都可以访问<br>c.NotebookApp.open_browser = False //启动时不启动浏览器。<br>c.NotebookApp.password = “sha1:xxxxxxxx” //上一步中保存的sha1编码<br>c.NotebookApp.port = 1357  //计算云中打开的端口。<br>c.NotebookApp.notebook_dir = “/home/ubuntu/conda/jupyter_home” //jupyter文件的保存路径<br>保存，退出。<br>再次运行”jupyter notebook”，显示如下：<br><img src="last.png" alt="image.png"></p><p>在远程任意服务器输入“计算云公网ip：1357”即可访问jupyter，密码输入前面passwd那一步的密码即可。</p><p>参考：<a href="https://www.bilibili.com/video/BV1Mb41137jC?t=1767" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Mb41137jC?t=1767</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MTK NPU Dimensity 1000</title>
      <link href="/2020/04/06/mtk-npu-dimensity-1000/"/>
      <url>/2020/04/06/mtk-npu-dimensity-1000/</url>
      
        <content type="html"><![CDATA[<h1 id="A-3-4-to-13-3TOPS-W-3-6TOPS-Dual-Core-Deep-Learning-Accelerator-for-Versatile-AI-Applications-in-7nm-5G-Smartphone-SoC"><a href="#A-3-4-to-13-3TOPS-W-3-6TOPS-Dual-Core-Deep-Learning-Accelerator-for-Versatile-AI-Applications-in-7nm-5G-Smartphone-SoC" class="headerlink" title="A 3.4-to-13.3TOPS/W 3.6TOPS Dual-Core Deep-Learning Accelerator for Versatile AI Applications in 7nm 5G Smartphone SoC"></a><strong>A 3.4-to-13.3TOPS/W 3.6TOPS Dual-Core Deep-Learning Accelerator for Versatile AI Applications in 7nm 5G Smartphone SoC</strong></h1><p><a href="http://bbs.eetop.cn/forum.php?mod=attachment&amp;aid=NzUxNzA4fGZjNTJhNGRlfDE1ODQ0Mzc3MTR8MHw4NzU1Mzk%3D" target="_blank" rel="noopener"><em>论文出处 ISSCC2020-07_visuals.pdf</em></a></p><p>Dimensity 1000是MTK的首款真正的AI芯片，通过ISSCC论文PPT看了一下架构，在这里做一下记录：</p><h2 id="整体架构如下图所示"><a href="#整体架构如下图所示" class="headerlink" title="整体架构如下图所示"></a>整体架构如下图所示</h2><p><img src="image_20200317173924.png?v=1&amp;type=image&amp;token=V1:IBK0ES23HbSMI2BTMl0yjB6oZizOdEg3nRX3ZSDaJBw" alt=""></p><p>从图上看，Dimensity1000采用双DLA核，与业界的趋势一致，采用双核提高算力。两个DLA可以直接通信，不需要AP_MCU的参与，提高了通信速度。</p><p>每个DLA中有：</p><p>四个处理单元： CE， 1DE，2DE，CMDE。</p><p>两个L1 Buffer，一个L2 Buffer。</p><p>两个DMA: CBLD,SBDMA</p><p>下面详细的看一下每个单元的功能：</p><h2 id="主要的处理单元-Convolution-Engine（CE）"><a href="#主要的处理单元-Convolution-Engine（CE）" class="headerlink" title="主要的处理单元 Convolution Engine（CE）"></a>主要的处理单元 Convolution Engine（CE）</h2><p><img src="image_20200317180543.png?v=1&amp;type=image&amp;token=V1:AfQUlxkJOZRq6H-vcG9V-6Mm7SQJFQN7VR3EV0bbiN4" alt="">    </p><ol><li><p>Convolution Buffer Loader (CBLD)</p><p>一个4D DMA引擎，支持stride的模式，主要是从L2搬运数据到CB，也可以从SB搬运到CB（应该是为layer-fusion特性做的）。支持weight压缩。</p></li><li><p>convolution Buffers(CB)</p><p>每层输入数据的activation、weight。CB的大小对Data-reuse的性能影响较大，此处没有介绍具体大小。</p></li><li><p>CONV Data Dispatcher(CDD)</p><p>将CB的数据搬入CE，除了数据搬运，应该还支持数据格式转换。同时还有Register Banks，减少对CB的访问，一些固定或变动少的数据可以放到register中。</p></li><li><p>Convolution Engine(CE)</p><p>CE是DLA的主要网络计算单元，执行卷积计算，其中还有个小的AQU核作ASYMM-Q计算。提高了ASYMM-Q的性能。</p></li></ol><h2 id="非卷积处理器"><a href="#非卷积处理器" class="headerlink" title="非卷积处理器"></a>非卷积处理器</h2><p><img src="image_20200317181655.png?v=1&amp;type=image&amp;token=V1:B6yrkRnOEqhyhE0F0bxJStTqkSAB5Faf965_xGP06go" alt=""></p><ol><li><p>1D Engine</p><p>激活函数（ReLu,PReLu,…）</p><p>数学计算（乘，加）</p></li><li><p>2D Engine</p><p>Pooling函数（Avg,Max),这里看不懂与1D分开的优势在哪里。在1D和2D CU之间没有直连通道。2D操作需要额外进出一次L1。个人猜测是为了减少2D CU的寄存器数量，2D操作需要缓存数据，1D到2D的数据需要先缓存足够的数据才可以计算。减少2D CU的寄存器，那就要利用L1，也就没必要增加1D到2D CU的直连通道了。</p></li><li><p>L1 用于1D 2D数据交换</p></li><li><p>4D DMA数据传输，支持stride，外存和SB之间。一个双向DMA，输出计算结果，输入应该是1D,2D引擎的参数。</p></li></ol><h2 id="控制处理器"><a href="#控制处理器" class="headerlink" title="控制处理器"></a>控制处理器</h2><p><img src="image_20200317182434.png?v=1&amp;type=image&amp;token=V1:QVaTT62aonJeOg6-PHx-lEdqZz1hveH9bCUBb3Q98r8" alt=""></p><p>1.Common Engine 整个DLA的控制单元，控制各个核的运行，数据的同步等。</p><ol><li>加载代码</li><li>解码，发送指令到其他CE</li><li>处理数据依赖和资源冲突</li></ol><h2 id="简单网络计算流程"><a href="#简单网络计算流程" class="headerlink" title="简单网络计算流程"></a>简单网络计算流程</h2><p><img src="image_20200317182723.png?v=1&amp;type=image&amp;token=V1:KyWTwouEy4X8JgKWDczOY1WHdzBjsRwZlLqLtHyj-jI" alt=""></p><p>一个简单的卷积流程实例，主要表达通过减少外存访问见到latency，提高性能。</p><h2 id="数据复用"><a href="#数据复用" class="headerlink" title="数据复用"></a>数据复用</h2><p><img src="image_20200317183017.png?v=1&amp;type=image&amp;token=V1:QNZO0cEdaIdyKM8VGM2IyH8fxuMKS6Kbk_mFWRp7piY" alt=""></p><p>数据复用，CE规格： CU<strong>CUG</strong>Cores=32<strong>16</strong>2</p><p>数据复用可以减少50%的weight对CB的访问，减少16%的数据CB访问。（不太理解16%怎么算的）</p><h2 id="AQ-量化"><a href="#AQ-量化" class="headerlink" title="AQ 量化"></a>AQ 量化</h2><p><img src="image_20200317190626.png?v=1&amp;type=image&amp;token=V1:yaVWDIPmCgBtppOKaJsMjAOsdp7Cj3xVXP2Vn9BKOY0" alt=""></p><h2 id="权重压缩和跳零"><a href="#权重压缩和跳零" class="headerlink" title="权重压缩和跳零"></a>权重压缩和跳零</h2><p><img src="image_20200317190648.png?v=1&amp;type=image&amp;token=V1:zhmpoZ84k1-G-Fs1Zc7lnWqe03owPCkyvmmtNAO_wMc" alt=""></p><p>支持权值压缩和跳零，降低87%的带宽和71%的计算量。权重压缩是全网络支持。<strong>跳零只是在FC层支持</strong>。</p><h2 id="tile方式降低带宽"><a href="#tile方式降低带宽" class="headerlink" title="tile方式降低带宽"></a>tile方式降低带宽</h2><p><img src="image_20200317190716.png?v=1&amp;type=image&amp;token=V1:lDvIPqTzchephrtdJEm1uUDV8s0hwy98Eba06t1JtlI" alt=""></p><p>通过输出Tile方向降低带宽</p><p>​    C Chanel 优先，可以data复用，weight reload</p><p>​    X-Y Chanel 优先，可以weight复用，data reload。</p><p>​    可以指定优先方式，也可以编译自动搜索。</p><h2 id="layer-fusion-降低带宽"><a href="#layer-fusion-降低带宽" class="headerlink" title="layer fusion 降低带宽"></a>layer fusion 降低带宽</h2><p><img src="image_20200317190734.png?v=1&amp;type=image&amp;token=V1:IGvQCtukSIoQPGPHmlYe5dnfpXkdvDUK0hBJDKy0vaI" alt=""></p><p>多层融合降低带宽</p><p>先遍历层，利用网络中Featuremaps生命周期端的层。（看不懂，depthwise，pointwise）</p><p>DLA 本身支持两层融合</p><p>通过L2实现多层融合</p><h2 id="多核计算"><a href="#多核计算" class="headerlink" title="多核计算"></a>多核计算</h2><p><img src="image_20200317190807.png?v=1&amp;type=image&amp;token=V1:rs1xCvxjYH4xp4dmTHrFA5EU8_NTfIUv9ILq0x1KBkE" alt=""></p><p>多核合作方式</p><p>处理不同操作(按网络或层划分任务)</p><ol><li><p>批处理，每个核单独跑网络</p></li><li><p>按层划分每个核跑不同的层。</p></li></ol><p>相同操作（层内划分任务）</p><ol><li><p>数据并行，权值复用</p></li><li><p>数据复用，权值并行</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="image_20200317190835.png?v=1&amp;type=image&amp;token=V1:qziprjSAeusJWdfQlgPF0w9bYePF7LQxm-nNFH4zqvQ" alt=""></p><p><img src="image_20200317190939.png?v=1&amp;type=image&amp;token=V1:JAjlPMzYQA8uUUQfKRQjEqjXu1-TIC4t-AZMVkgn5Zs" alt=""></p><h2 id="性能功耗对比"><a href="#性能功耗对比" class="headerlink" title="性能功耗对比"></a>性能功耗对比</h2><p><img src="image_20200317190919.png?v=1&amp;type=image&amp;token=V1:bbhUVPMLbnUm0ZCiip0JXlOmI0oyQ-jnS9uMaG9z6-k" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> NPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MTK </tag>
            
            <tag> NPU </tag>
            
            <tag> Dimensity 1000 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是指令集</title>
      <link href="/2020/04/04/shi-me-shi-zhi-ling-ji/"/>
      <url>/2020/04/04/shi-me-shi-zhi-ling-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h1><h2 id="指令集的定义"><a href="#指令集的定义" class="headerlink" title="指令集的定义"></a>指令集的定义</h2><ul><li>l指令集架构（Instruction Set Architecture，缩写为ISA），又称指令集或指令集体系，是计算机体系结构中与程序设计有关的部分，包含了基本数据类型，指令集，寄存器，寻址模式，存储体系，中断，异常处理以及外部I/O等</li><li>简单的说，指令集是：<blockquote><p>指令的集合，而一条指令描述处理器的某一种功能<br>程序能够调用的处理器全部功能的集合<br>处理器功能的抽象模型<br>计算机软件与硬件的接口</p></blockquote></li></ul><p>思考：华为、三星、高通等公司都有自己研发的ARM架构处理器，为什么他们都被称为ARM架构处理器呢？<br>回答：因为他们都根据ARM（Adcanced RISC Machine）指令集进行开发，尽管硬件实现的方式不同，但是实现的指令功能一致，工具链一致，对软件表现出的接口一致。<br><img src="image_20200325180353.png?v=1&amp;type=image&amp;token=V1:Xefvf5KRq6MOhHaPzqG4PA3_2iXJuTc-4Wu0P3Ar7XQ" alt=""></p><h2 id="指令集的定义-1"><a href="#指令集的定义-1" class="headerlink" title="指令集的定义"></a>指令集的定义</h2><p>传统意义上，指令分为两种：</p><ul><li><p>精简指令集（Reduced Instruction Set Computer，RISC）</p><ul><li>单指令功能简单，执行速度快，编译效率高，仅能通过LD/ST来访问存储</li><li>如：ARM、MIPS、OpenRISC、RSIC-V、Sparc等</li></ul></li><li><p>复杂指令集（Complex Instruction Set Computer ，CISC）：</p><ul><li>单指令功能强大且复杂，指令周期长，可以直接操作存储器</li><li>如：X86<ul><li>Ascend AI处理器的指令集介乎RISC与CISC之间：</li></ul></li><li>标准指令类似于RISC</li><li>向量、矩阵、数据搬运指令类似于CISC<h2 id="指令与汇编语言"><a href="#指令与汇编语言" class="headerlink" title="指令与汇编语言"></a>指令与汇编语言</h2></li></ul></li><li><p>指令集举例：RISC指令</p></li><li><p><img src="image_20200325180648.png?" alt=""></p><h2 id="指令与汇编语言-1"><a href="#指令与汇编语言-1" class="headerlink" title="指令与汇编语言"></a>指令与汇编语言</h2></li><li><p>什么是汇编？</p><ul><li>从硬件角度看，指令只是二进制数字，称为机器码</li><li>汇编是指令的助记符，为了方便记忆</li><li>汇编是一种低级语言，没有脱离指令集<br>如下所示：<br><img src="image_20200325180826.png" alt=""></li></ul></li><li><p>低级语言与高级语言</p><ul><li>低级语言：没有脱离指令集，汇编语言</li><li>高级语言：脱离了指令集，如C语言</li></ul></li><li><p><img src="image_20200325180940.png" alt="">)<img src="image_20200325180935.png" alt=""></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指令集 </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 搭建的坑</title>
      <link href="/2020/03/27/hexo-da-jian-de-keng/"/>
      <url>/2020/03/27/hexo-da-jian-de-keng/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-搭建-使用中遇到的问题总结"><a href="#hexo-搭建-使用中遇到的问题总结" class="headerlink" title="hexo 搭建/使用中遇到的问题总结"></a>hexo 搭建/使用中遇到的问题总结</h1><h2 id="问题：github上重定向的域名在hexo-clean，hexo-g，hexo-d之后总是会被情况，需要重新设置。"><a href="#问题：github上重定向的域名在hexo-clean，hexo-g，hexo-d之后总是会被情况，需要重新设置。" class="headerlink" title="问题：github上重定向的域名在hexo clean，hexo g，hexo d之后总是会被情况，需要重新设置。"></a>问题：github上重定向的域名在hexo clean，hexo g，hexo d之后总是会被情况，需要重新设置。</h2><ul><li>解决方案</li></ul><blockquote><p>在本地blog的source目录下新建CNAME文件，文件中增加重定向的域名，例如 ‘blog.changdong.ltd’</p></blockquote><ul><li>原因</li></ul><blockquote><p>github重定向会在仓库根目录下创建一个CNAME的文件，内容就是重定向的文件名。在hexo重新生成public文件之后，hexo d操作会删除远程仓库里的CNAME文件，所以重定向就无效了。通过在本地source目录下创建一个一样的CNAME，在hexo g的过程中会在public文件中生成一个CNAME文件，hexo d到远程，就不会导致CNAME文件丢失了。</p></blockquote><h2 id="问题：hexo-g生成时，报SyntaxError-D-blog-node-modules-hexo-filter-github-emojis-emojis-json-Unexpected-end-of-JSON-input，"><a href="#问题：hexo-g生成时，报SyntaxError-D-blog-node-modules-hexo-filter-github-emojis-emojis-json-Unexpected-end-of-JSON-input，" class="headerlink" title="问题：hexo g生成时，报SyntaxError: D:\blog\node_modules\hexo-filter-github-emojis\emojis.json: Unexpected end of JSON input，"></a>问题：hexo g生成时，报SyntaxError: D:\blog\node_modules\hexo-filter-github-emojis\emojis.json: Unexpected end of JSON input，</h2><ul><li>解决方案</li></ul><blockquote><p>方法1： npm uninstall hexo-filter-github-emojis –no-save,然后npm install hexo-filter-github-emojis –save重装</p><p>方法2：  npm update hexo-filter-github-emojis –save   更新。</p></blockquote><ul><li>原因</li></ul><blockquote><p>可能是json文件损坏了。可以看一下，emojis.json是空的。怀疑是更新还是没有代理或网络，更新失败。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习android-显示系统</title>
      <link href="/2020/03/11/xue-xi-android-xian-shi-xi-tong/"/>
      <url>/2020/03/11/xue-xi-android-xian-shi-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="androidQ-surfaceflinger介绍"><a href="#androidQ-surfaceflinger介绍" class="headerlink" title="androidQ surfaceflinger介绍"></a>androidQ surfaceflinger介绍</h1><p>[toc]</p><p><em>surfaceflinger是android系统的一个重要后台服务，该服务跟随系统启动，由systemservice服务启动。主要负责android的显示控制任务，本文主要介绍androidQ(android 10)系统中的surfaceflinger服务。</em></p><hr><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>本文讲解的内容是Android4.1以后的系统机制，将从整体上分析Android图形显示系统的结构，不深入分析每一层内部的代码实现，更多的是使用流程图和结构图来让大家理解Android是如何绘制、合成图形并显示到屏幕上。</p><p>本文将从三个层次进行讲解，大致如下图：</p><p>可以理解为上层生产，下层消费模型。</p><p><img src="20170423222358983.png" alt="image"></p><p>可以理解为上层生产，下层消费模型。</p><p>其中每一层之间的数据传递是使用Buffer（图形缓冲区）作为载体：<br><img src="20170423222539614.png" alt="图形数据的载体"><br>这里的缓冲区，大家可以理解为带有宽高和像素密度的内存区块。</p><h3 id="从下层往上层理解"><a href="#从下层往上层理解" class="headerlink" title="从下层往上层理解"></a>从下层往上层理解</h3><h4 id="显示屏"><a href="#显示屏" class="headerlink" title="显示屏"></a>显示屏</h4><p>显示屏上的内容，是从硬件帧缓冲区读取的，大致读取过程为：从Buffer的起始地址开始，从上往下，从左往右扫描整个Buffer，将内容映射到显示屏上：<br><img src="20170423220626775.png" alt="屏幕与帧缓冲区关系图1"></p><p>当然，屏幕上的内容需要需要不断的更新，如果在同一个Buffer进行读取和写入（合成）操作，将会导致屏幕显示多帧内容。所以硬件层除了提供一个Buffer用于屏幕显示，还提供了一个Buffer用于后台的图形合成，也就是我们常说的双缓冲：<br><img src="20170423221054667.png" alt="屏幕与帧缓冲区关系图2"></p><p>上图中包含两个缓冲区：<br><strong>前缓冲区：</strong>用来显示内容到屏幕的帧缓冲区<br><strong>后缓冲区：</strong>用于后台合成下一帧图形的帧缓冲区</p><p>假设前一帧显示完毕，后一帧准备好了，屏幕将会开始读取下一帧的内容，也就是开始读取上图中的后缓冲区的内容：<br><img src="20170423223702548.png" alt="屏幕与帧缓冲区关系图途2"></p><p>此时，前后缓冲区进行一次角色互换，之前的后缓冲区变为前缓冲区，进行图形的显示，之前的前缓冲区则变为后缓冲区，进行图形的合成。</p><p>然而，理想很丰满，现实很骨感，上面假设“当前一帧显示完毕，后一帧准备好了”的情况，在现实中这两个事件并非同时完成。那么，屏幕扫描缓冲区的速度和系统合成帧的速度之间有什么关系呢，带着这个疑惑我们看看下面两个概念：</p><p><strong>屏幕刷新率（HZ）：</strong>代表屏幕在一秒内刷新屏幕的次数，Android手机一般为60HZ（也就是1秒刷新60帧，大约16.67毫秒刷新1帧）</p><p><strong>系统帧速率（FPS）：</strong>代表了系统在一秒内合成的帧数，该值的大小由系统算法和硬件决定。</p><p>我们用以下两个假设来分析两者的关系：</p><p>① 屏幕刷新速率比系统帧速率快<br>此时，在前缓冲区内容全部映射到屏幕上之后，后缓冲区尚未准备好下一帧，屏幕将无法读取下一帧，所以只能继续显示当前一帧的图形，造成一帧显示多次，也就是卡顿。</p><p>② 系统帧速率比屏幕刷新率快<br>此时，屏幕未完全把前缓冲区的一帧映射到屏幕，而系统已经在后缓冲区准备好了下一帧，并要求读取下一帧到屏幕，将会导致屏幕上半部分是上一帧的图形，而下半部分是下一帧的图形，造成屏幕上显示多帧，也就是屏幕撕裂。</p><p>上面两种情况，都会导致问题，根本原因就是两个缓冲区的操作速率不一致，解决办法就是让屏幕控制前后缓冲区的切换，让系统帧速率配合屏幕刷新率的节奏。</p><p>那么屏幕是如何控制这个节奏的呢？</p><p><strong>垂直同步（VSync）：</strong>当屏幕从缓冲区扫描完一帧到屏幕上之后，开始扫描下一帧之前，发出的一个同步信号，该信号用来切换前缓冲区和后缓冲区。</p><p>通过上面的分析可以看出，屏幕的显示节奏是固定的，操作系统需要配合屏幕的显示，在固定的时间内准备好下一帧，以供屏幕进行显示。两者通过VSync信号来实现同步。</p><p>关于屏幕这一块的知识点讲解到这，不再深入分析，接下来我们将会了解后缓冲区的图形合成者。</p><h4 id="SurfaceFlinger-图形合成者"><a href="#SurfaceFlinger-图形合成者" class="headerlink" title="SurfaceFlinger-图形合成者"></a>SurfaceFlinger-图形合成者</h4><p>如果说屏幕是消费者，那么SurfaceFlinger相对屏幕来说就是生产者，其具有如下特性：</p><ul><li>作为上层应用的消费者，硬件层的生产者。</li><li>负责图形的合成</li><li>和ActivityManagerService一样，是一个系统服务</li></ul><p>为了更好的理解SurfaceFlinger这个服务的工作内容，以及他是如何做到一个承上启下的作用，我们通过下面的这个界面分析：</p><p><img src="20170502235504168.png" alt="这里写图片描述"></p><p>界面很简单，拆开来看，包含微信、悬浮工具箱、通知栏、底部虚拟按键栏：</p><p><img src="20170502235325462.png" alt="界面对应的surface"></p><p>我们可以先这样理解上面这幅图，上层每一个界面，其实都对应SufaceFlinger里的一个Surface对象，上层将自己的内容绘制在对应的Surface内，接着，SufaceFlinger需要将所有上层对应的Surface内的图形进行合成，具体看下图：<br><img src="20170503000053286.png" alt="SurfaceFlinger合成过程"></p><p>没错，SurfaceFlinger就是将多个Surface里的内容进行合成，最后提交到屏幕的后缓冲区，等待屏幕的下一个垂直同步信号的到来，再显示到屏幕上。</p><p>我们会发现SufaceFlinger通过屏幕后缓冲区与屏幕建立联系。同时通过Surface与上层建立联系。从而起到一个承上启下的作用，是Android图形系统结构中的关键组成部分。</p><p>为了继续往上层讲，我们需要了解什么是Surface：</p><ul><li>对应上层的一个Window（对话框、Activity、状态栏）</li><li>作为上层图形绘制的画板</li><li>Canvas是画笔，上层通过调用Canvas的API向Surface上绘制图形</li><li>Surface内部存在多个缓冲区，形成一个BufferQueue</li></ul><p>如果说SurfaceFinger是图形的合成者，那么图形的提供者就是上层。文章一开始就提到，图形的传递是通过Buffer作为载体，Surface是对Buffer的进一步封装，也就是说Surface内部具有多个Buffer供上层使用，如何管理这些Buffer呢？请看下面这个模型：</p><p><img src="20170503094309913.png" alt="image"></p><p>Surface内部提供一个BufferQueue，与上层和SurfaceFlinger形成一个生产者消费者模型，上层对应Producer，SurfaceFlinger对应Consumer。三者通过Buffer产生联系，每个Buffer都有四种状态：</p><ul><li>Free：可被上层使用</li><li>Dequeued：出列，正在被上层使用</li><li>Queued：入列，已完成上层绘制，等待SurfaceFlinger合成</li><li>Acquired：被获取，SurfaceFlinger正持有该Buffer进行合成</li></ul><p>Buffer的一次转移过程大致为：</p><p>从BufferQueue转移到上层</p><ul><li>上层绘制完成再放回BufferQueue</li><li>接着SurfaceFlinger再拿去合成</li><li>最后又放回BufferQueue</li><li>如此循环，形成一个Buffer被循环使用的过程。</li></ul><p>关于SurfaceFlinger以及SurfaceFlinger与上层建立联系的Surface讲解完了，接下来看看上层是如何将图形绘制到Surface的Buffer中。</p><h4 id="上层绘图"><a href="#上层绘图" class="headerlink" title="上层绘图"></a>上层绘图</h4><p>上层绘图的大体流程见下图：<br><img src="20170503095551180.jpg" alt="上层绘图"></p><p>之前有说到，Surface里的Buffer作为上层的画板，Canvas作为画笔，通过调用Canvas的API完成图形的绘制，上层通过调用draw方法来调用Canvas的API，当然这里的draw方法并没有真正的将图形绘制到缓冲区，而是记录了一下绘制命令，具体需要了解DisplayList相关只是，后面会对其进行分析。</p><p>从流程上看:</p><ol><li>测量View的宽高（Measure）</li><li>设置View的宽高位置（Layout）</li><li>创建显示列表，并执行绘制（Draw）</li><li>生成多边形和纹理</li><li>对多边形和纹理进行栅格化操作</li></ol><p>从执行者的角度看：</p><ol><li>CPU：Measure，Layout，纹理和多边形生成，发送纹理和多边形到GPU</li><li>GPU：将CPU生成的纹理和多边形进行栅格化以及合成</li></ol><p>上面说的的纹理和多边形还有栅格化以及合成，这里不做具体的讲解，需要了解的是图形的绘制流程需要经过这些操作。从上面的分析可以看出，上层绘制图形时需要经过CPU计算，再经过GPU计算。</p><p>经过上面的分析，整个Android的图形绘制大体流程已经分析完成，接下来将会分析一些流程的具体实现，分析的内容包括：</p><ul><li>Android 4.1 加入的VSync信号同步到上层以及三缓冲</li><li>从上层往下层具体分析每一步流程</li></ul><h4 id="VSync以及三缓冲"><a href="#VSync以及三缓冲" class="headerlink" title="VSync以及三缓冲"></a>VSync以及三缓冲</h4><h5 id="Drawing-Without-VSync"><a href="#Drawing-Without-VSync" class="headerlink" title="Drawing Without VSync"></a>Drawing Without VSync</h5><p>从上面的讲解可以看出，整个绘制流程的节奏，分成两个生产者消费者模型，一个由屏幕和SurfaceFlinger构成，另一个由SurfaceFlinger和上层应用构成，具体流程可以用下图来描述：<br><img src="20170503115001960.jpg" alt="drawing without vsync"></p><p>其中：</p><ol><li>CPU和GPU代表上层的绘制执行者</li><li>Composite代表的是SurfaceFlinger对多个Surface的合成</li><li>Background Buffer和Front Buffer分别代表的是硬件帧缓冲区中的前缓冲和后缓冲</li><li>显示屏扫描完一帧之后，会发出VSync信号来切换并显示下一帧</li></ol><p>上面的流程中，存在一个问题，屏幕的VSync信号只是用来控制帧缓冲区的切换，并未控制上层的绘制节奏，也就是说上层的生产节奏和屏幕的显示节奏是脱离的：</p><p><img src="20170503120335778.png" alt="drawing without vsync"></p><p>上图中，横轴表示时间，纵轴表示Buffer的使用者，每个长方形表示Buffer的使用，长方形的宽度代表使用时长，VSync代表垂直同步信号，两个VSync信号之间间隔16.6ms。此图描述了Android在4.1系统版本之前，上层的绘图流程在没有VSync信号的时候，出现的绘制问题。</p><p>我们从时间为0开始看，当前屏幕显示第0帧，上层CPU开始计算第1帧的纹理，计算完成后，交由GPU进行栅格化。当下一个垂直同步信号到来，屏幕显示下一帧，这时候，上层CPU并未马上开始准备下一帧，而当CPU开始准备下一帧的时候已经太晚了，下一个VSync信号来临的时候，GPU未能绘制完第二帧的处理，导致屏幕再次显示上一帧，造成卡顿：</p><p><img src="20170503141658724.png" alt="drawing without vsync"></p><h5 id="Drawing-With-VSync"><a href="#Drawing-With-VSync" class="headerlink" title="Drawing With VSync"></a>Drawing With VSync</h5><p>因为上层不知道VSync信号已经发出，导致上层未能开始CPU的计算。google在Android 4.1系统中加入了上层接收垂直同步信号的逻辑，大致流程如下：<br><img src="20170503142142473.png" alt="draw with vsync"></p><p>也就是说，屏幕在显示完一帧后，发出的垂直同步除了通知帧缓冲区的切换之外，该消息还会发送到上层，通知上层开始绘制下一帧。</p><p>那么，上层是如何接受这个VSync消息的呢？</p><h6 id="Choreographer-VSync信号的上层接收者"><a href="#Choreographer-VSync信号的上层接收者" class="headerlink" title="Choreographer VSync信号的上层接收者"></a>Choreographer VSync信号的上层接收者</h6><p>Google为上层设计了一个Choreographer类，翻译成中文是“编舞者”，是希望通过它来控制上层的绘制（舞蹈）节奏。</p><p>首先看看Choreographer的类图：</p><p><img src="20170503143059916.png" alt="img"></p><p>可以发现，Choreographer需要向SurfaceFlinger来注册一个VSync信号的接收器DisplayEventReceiver。同时在Choreographer的内部维护了一个CallbackQueue，用来保存上层关心VSync信号的组件，包括ViewRootImpl，TextView，ValueAnimator等。</p><p>再看看上层接收VSync的时序图：</p><p><img src="20170503143510309.png" alt="上层接收VSync时序图"></p><p>知道了Choreographer是上层用来接收VSync的角色之后，我们需要进一步了解VSync信号是如何控制上层的绘制的：<br><img src="20170503143848832.png" alt="上层VSync与绘制相结合的时序图"></p><p>一般，上层需要绘制新的UI都是因为View的requestLayout或者是invalidate方法被调用触发的，我们以这个为起点，跟踪上层View的绘制流程：</p><ol><li>requestLayout或者invalidate触发更新视图请求</li><li>更新请求传递到ViewRootImpl中，ViewRootImpl向主线程MessageQueue中加入一个阻塞器，该阻塞器将会拦截所有同步消息，也就是说此时，我们再通过Handler向主线程MessageQueue发送的所有Message都将无法被执行。</li><li>ViewRootImpl向Choreographer注册下一个VSync信号</li><li>Choreographer通过DisplayEventReceiver向framework层注册下一个VSync信号</li><li>当底层产生下一个VSync消息时，该信号将会发送给DisplayEventReceiver，最后传递给Choreographer</li><li>Choreographer收到VSync信号之后，向主线程MessageQueue发送了一个异步消息，我们在第二步提到，ViewRootImpl向MessageQueue发送了一个同步消息阻塞器。这里Choreographer发送的异步消息，是不会被阻塞器拦截的。</li><li>最后，异步消息的执行者是ViewRootImpl，也就是真正开始绘制下一帧了</li></ol><p>至此，底层的VSync控制上层的逻辑就解释完了，此时上层绘制图形的流程与VSync信号的关系可以用下图表示：<br><img src="20170503145317930.png" alt="draw with vsync"></p><p>时间从屏幕显示第0帧开始，CPU开始准备第1帧图形的处理，好了之后交给GPU进行处理，在上层收到下一个VSync之后，CPU立马开始第2帧的处理，上层绘图的节奏就和VSync信号保持一致了，整个绘图非常流畅。</p><p>然而，理想很丰满，现实很骨感，如果CPU和GPU没能在下一个VSync信号到来之前完成下一帧的绘制工作，又会是怎么样的呢？<br><img src="20170503150149613.png" alt="parallel processing and double buffering"></p><p>还是从屏幕显示第A帧开始，时间进入第一个16.6ms，CPU和GPU合成第B帧，当下一个VSync信号到来的时候，GPU未能及时完成第B帧的绘制，此时，GPU占有一个Surface里的Buffer，而同时SurfaceFlinger又持有一个Buffer用于合成显示下一帧到屏幕，这样的话，就导致Surface里的两个缓冲区都被占用了。此时SurfaceFlinger只能使用第A帧已经准备好的Buffer来合成，GPU继续在另一个缓冲区中合成第B帧，此时CPU无法开始下一帧的合成，因为缓冲区用完了。另外一个不好的事情是CPU只有在VSync信号来的时候才开始绘制下一帧，也是就是说在第二个16.6ms时间内，CPU一直处于空闲状态，未进行下一帧的计算。<br>只有等到第二个VSync信号来了之后，CPU才开始在绘制下一帧。如果CPU和GPU需要合成的图形太多，将会导致连续性的卡顿，如果CPU和GPU大部分时候都无法在16.6ms完成一帧的绘制，将会导致连续的卡顿现象。</p><p>别着急，请看看Google的决绝方案。</p><h5 id="parallel-processing-and-triple-buffering"><a href="#parallel-processing-and-triple-buffering" class="headerlink" title="parallel processing and triple buffering"></a>parallel processing and triple buffering</h5><p>没错，就是加入第三个Buffer，CPU和GPU还有SurfaceFlinger各占一个Buffer，并行处理图形：<br><img src="20170503153350970.png" alt="parallel processing and triple buffering"></p><p>从上图可以看出，在第一个VSync到来时，尽管SurfaceFlinger占了一个Buffer，GPU又占了一个Buffer，CPU仍然可以在第三个Buffer中开始下一帧的计算，整个显示过程就开始时卡顿了一帧，之后都是流畅的。</p><p>当然系统并非一直开启三个Buffer，因为Buffer是需要消耗资源的，并且，我们会发现，上图中，GPU处理好的图形，需要跨越两个VSync信号，才能显示。这样的话，给用户的影响是一个延迟的现象。</p><p>为了解决该问题，我们需要再次从上层往下层了解Android绘制图形的各个细节，并进行优化。对于应用程序开发人员来说，重点还是上层的优化，对自己的应用程序的内存，UI，数据等进行优化。</p><p>总结：</p><ul><li>Android通过Buffer来保存图形信息，为了让图形显示的更加流程，在提供一一个Buffer用于显示的同时，开辟一个或者多个Buffer用于后台图形的合成。</li><li>Android4.1之前，VSync信号并未传递给上层，导致生产与消费节奏不统一</li><li>Android4.1之后，上层开始绘制时机都放到了VSync信号的到来时候</li><li>除了在上层引入VSync机制，Anroid在4.1还加入了三缓冲，用来减少卡顿的产生</li><li>每个Surface都有自己的绘制流程，需要先经过CPU处理，再经过GPU处理，之后经过SurfaceFlinger与其他Surface绘制好的图形和合成在一起，供屏幕显示</li><li>VSync信号贯穿整个绘制流程，控制着整个Android图形系统的节奏</li></ul><p><em>综述转自:<a href="https://blog.csdn.net/a740169405/article/details/70548443" target="_blank" rel="noopener">Android图形显示系统</a></em></p><p>##启动surfaceflinger</p><h3 id="rc文件配置"><a href="#rc文件配置" class="headerlink" title="rc文件配置"></a>rc文件配置</h3><p>surfaceflinger启动是在系统开机时，由系统systemservice负责启动，启动相关的控制在surfaceflinger.rc中*[rc语法](init.rc 语法与解析)*。</p><pre class=" language-c"><code class="language-c">service surfaceflinger <span class="token operator">/</span>system<span class="token operator">/</span>bin<span class="token operator">/</span>surfaceflinger <span class="token comment" spellcheck="true">//服务启动的命令</span>    class core animation <span class="token comment" spellcheck="true">//服务指定的class名，同一个class 的所有服务必须同时启动或者停止。</span>    user system <span class="token comment" spellcheck="true">//在启动服务前将用户切换至&lt;system>,默认情况下用户都是root。</span>    group graphics drmrpc readproc <span class="token comment" spellcheck="true">//在启动服务前将用户组切换至&lt;groupname></span>    onrestart restart zygote <span class="token comment" spellcheck="true">//当次服务重启时，执行某些命令</span>    writepid <span class="token operator">/</span>dev<span class="token operator">/</span>stune<span class="token operator">/</span>foreground<span class="token operator">/</span>tasks <span class="token comment" spellcheck="true">//当fork一个子进程时，写子进程的pid到一个给定的文件。是给cgroup/cpuset使用</span>    <span class="token comment" spellcheck="true">//创建一个名为pdx/system/vr/display/&lt;name>的 socket，然后将它的fd值传给启动它的进，有效的&lt;type>值包括dgram,stream 和seqpacket。ueser 和group 的默认值为0</span>    socket pdx<span class="token operator">/</span>system<span class="token operator">/</span>vr<span class="token operator">/</span>display<span class="token operator">/</span>client     stream <span class="token number">0666</span> system graphics u<span class="token punctuation">:</span>object_r<span class="token punctuation">:</span>pdx_display_client_endpoint_socket<span class="token punctuation">:</span>s0    socket pdx<span class="token operator">/</span>system<span class="token operator">/</span>vr<span class="token operator">/</span>display<span class="token operator">/</span>manager    stream <span class="token number">0666</span> system graphics u<span class="token punctuation">:</span>object_r<span class="token punctuation">:</span>pdx_display_manager_endpoint_socket<span class="token punctuation">:</span>s0    socket pdx<span class="token operator">/</span>system<span class="token operator">/</span>vr<span class="token operator">/</span>display<span class="token operator">/</span>vsync      stream <span class="token number">0666</span> system graphics u<span class="token punctuation">:</span>object_r<span class="token punctuation">:</span>pdx_display_vsync_endpoint_socket<span class="token punctuation">:</span>s0    critical <span class="token comment" spellcheck="true">//是否关键，也就是4分钟之内重启超过4次的话，重启之后就进入recovery模式</span></code></pre><h3 id="surfaceflinger对象创建"><a href="#surfaceflinger对象创建" class="headerlink" title="surfaceflinger对象创建"></a>surfaceflinger对象创建</h3><p>surfaceflinger启动服务的入口函数是main_surfaceflinger.cpp的main函数</p><p>[-&gt;main_surfaceflinger.cpp]</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">signal</span><span class="token punctuation">(</span>SIGPIPE<span class="token punctuation">,</span> SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span>    hardware<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">configureRpcThreadpool</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token comment" spellcheck="true">/* maxThreads */</span><span class="token punctuation">,</span>            false <span class="token comment" spellcheck="true">/* callerWillJoin */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">startGraphicsAllocatorService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// When SF is launched in its own process, limit the number of</span>    <span class="token comment" spellcheck="true">// binder threads to 4.设置该线程可以绑定的binder线程数（binder用于通信）</span>    ProcessState<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">setThreadPoolMaxThreadCount</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// start the thread pool 启动线程池</span>    sp<span class="token operator">&lt;</span>ProcessState<span class="token operator">></span> <span class="token function">ps</span><span class="token punctuation">(</span>ProcessState<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ps<span class="token operator">-></span><span class="token function">startThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// instantiate surfaceflinger 实例化surfacefinger线程</span>    sp<span class="token operator">&lt;</span>SurfaceFlinger<span class="token operator">></span> flinger <span class="token operator">=</span> surfaceflinger<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">createSurfaceFlinger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置线程优先级</span>    <span class="token function">setpriority</span><span class="token punctuation">(</span>PRIO_PROCESS<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> PRIORITY_URGENT_DISPLAY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置调度策略</span>    <span class="token function">set_sched_policy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SP_FOREGROUND<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Put most SurfaceFlinger threads in the system-background cpuset</span>    <span class="token comment" spellcheck="true">// Keeps us from unnecessarily using big cores</span>    <span class="token comment" spellcheck="true">// Do this after the binder thread pool init 设置cpu后台运行策略，避免使用大核</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cpusets_enabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">setCpusetPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// initialize before clients can connect</span>    flinger<span class="token operator">-></span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// publish surface flinger 添加surfaceflinger服务到服务管理单元</span>    sp<span class="token operator">&lt;</span>IServiceManager<span class="token operator">></span> <span class="token function">sm</span><span class="token punctuation">(</span><span class="token function">defaultServiceManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sm<span class="token operator">-></span><span class="token function">addService</span><span class="token punctuation">(</span><span class="token function">String16</span><span class="token punctuation">(</span>SurfaceFlinger<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getServiceName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> flinger<span class="token punctuation">,</span> false<span class="token punctuation">,</span>                   IServiceManager<span class="token punctuation">:</span><span class="token punctuation">:</span>DUMP_FLAG_PRIORITY_CRITICAL <span class="token operator">|</span> IServiceManager<span class="token punctuation">:</span><span class="token punctuation">:</span>DUMP_FLAG_PROTO<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//启动显示服务</span>    <span class="token function">startDisplayService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// dependency on SF getting registered above</span>    <span class="token keyword">struct</span> sched_param param <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    param<span class="token punctuation">.</span>sched_priority <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sched_setscheduler</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SCHED_FIFO<span class="token punctuation">,</span> <span class="token operator">&amp;</span>param<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ALOGE</span><span class="token punctuation">(</span><span class="token string">"Couldn't set SCHED_FIFO"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// run surface flinger in this thread</span>    flinger<span class="token operator">-></span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>main函数主要工作;</p><ol><li>启动内存管理相关服务。</li><li>设置surfaceflinger的binder线程池大小，启动binder线程池。</li><li>创建surfaceflinger实例，设置调度策略和优先级。</li><li>调用surfaceflinger的init函数初始化实例。</li><li>添加surfaceflinger服务到系统服务管理模块。</li><li>启动显示服务。</li><li>运行surfaceflinger服务。</li></ol><p>binder线程是用于线程间通信的class，相关文档可以<a href="https://blog.csdn.net/llping2011/article/details/9706679" target="_blank" rel="noopener">参考此文档</a>;由于本文重点介绍surfaceflinger模块，所以接下来主要介绍一下创建surfaceflinger实例。</p><h4 id="创建surfaceflinger实例"><a href="#创建surfaceflinger实例" class="headerlink" title="创建surfaceflinger实例"></a>创建surfaceflinger实例</h4><p>surfaceflinger实例通过<strong>surfaceflinger::createSurfaceFlinger()</strong>函数创建，该函数位于SurfaceFlingerFactory.cpp中，定义如下</p><pre class=" language-c++"><code class="language-c++">namespace android::surfaceflinger {sp<SurfaceFlinger> createSurfaceFlinger() {    class Factory final : public surfaceflinger::Factory {    public:        Factory() = default;        ~Factory() = default;        std::unique_ptr<DispSync> createDispSync(const char* name, bool hasSyncFramework,                                                 int64_t dispSyncPresentTimeOffset) override {            // Note: We create a local temporary with the real DispSync implementation            // type temporarily so we can initialize it with the configured values,            // before storing it for more generic use using the interface type.            auto primaryDispSync = std::make_unique<android::impl::DispSync>(name);            primaryDispSync->init(hasSyncFramework, dispSyncPresentTimeOffset);            return primaryDispSync;        }        std::unique_ptr<EventControlThread> createEventControlThread(                std::function<void(bool)> setVSyncEnabled) override {            return std::make_unique<android::impl::EventControlThread>(setVSyncEnabled);        }        std::unique_ptr<HWComposer> createHWComposer(const std::string& serviceName) override {            return std::make_unique<android::impl::HWComposer>(                    std::make_unique<Hwc2::impl::Composer>(serviceName));        }        std::unique_ptr<MessageQueue> createMessageQueue() override {            return std::make_unique<android::impl::MessageQueue>();        }        std::unique_ptr<scheduler::PhaseOffsets> createPhaseOffsets() override {            return std::make_unique<scheduler::impl::PhaseOffsets>();        }        std::unique_ptr<Scheduler> createScheduler(                std::function<void(bool)> callback,                const scheduler::RefreshRateConfigs& refreshRateConfig) override {            return std::make_unique<Scheduler>(callback, refreshRateConfig);        }        std::unique_ptr<SurfaceInterceptor> createSurfaceInterceptor(                SurfaceFlinger* flinger) override {            return std::make_unique<android::impl::SurfaceInterceptor>(flinger);        }        sp<StartPropertySetThread> createStartPropertySetThread(                bool timestampPropertyValue) override {            return new StartPropertySetThread(timestampPropertyValue);        }        sp<DisplayDevice> createDisplayDevice(DisplayDeviceCreationArgs&& creationArgs) override {            return new DisplayDevice(std::move(creationArgs));        }        sp<GraphicBuffer> createGraphicBuffer(uint32_t width, uint32_t height, PixelFormat format,                                              uint32_t layerCount, uint64_t usage,                                              std::string requestorName) override {            return new GraphicBuffer(width, height, format, layerCount, usage, requestorName);        }        void createBufferQueue(sp<IGraphicBufferProducer>* outProducer,                               sp<IGraphicBufferConsumer>* outConsumer,                               bool consumerIsSurfaceFlinger) override {            BufferQueue::createBufferQueue(outProducer, outConsumer, consumerIsSurfaceFlinger);        }        std::unique_ptr<surfaceflinger::NativeWindowSurface> createNativeWindowSurface(                const sp<IGraphicBufferProducer>& producer) override {            return surfaceflinger::impl::createNativeWindowSurface(producer);        }        std::unique_ptr<compositionengine::CompositionEngine> createCompositionEngine() override {            return compositionengine::impl::createCompositionEngine();        }        sp<ContainerLayer> createContainerLayer(const LayerCreationArgs& args) override {            return new ContainerLayer(args);        }        sp<BufferQueueLayer> createBufferQueueLayer(const LayerCreationArgs& args) override {            return new BufferQueueLayer(args);        }        sp<BufferStateLayer> createBufferStateLayer(const LayerCreationArgs& args) override {            return new BufferStateLayer(args);        }        sp<ColorLayer> createColorLayer(const LayerCreationArgs& args) override {            return new ColorLayer(args);        }        std::shared_ptr<TimeStats> createTimeStats() override {            return std::make_shared<android::impl::TimeStats>();        }    };    static Factory factory;    return new SurfaceFlingerEx(factory);}} </code></pre><p>createSurfaceFlinger函数<strong>首先</strong>定义了Factory类，该类派生于surfaceflinger::Factory,实现了父类定义的所有虚函数。通过函数名可以知道，该类主要用于创建surfaceflinger中的类成员变量的实例。<strong>接着</strong>定义一个Factory实例，最后返回一个通过Factory实例创建的SurfaceFlingerEx对象。</p><h4 id="SurfaceFlinger和SurfaceFlingerEx"><a href="#SurfaceFlinger和SurfaceFlingerEx" class="headerlink" title="SurfaceFlinger和SurfaceFlingerEx"></a>SurfaceFlinger和SurfaceFlingerEx</h4><p>surfaceFlingerEx类是surfaceFlinger的之类，这个是由各个厂家自己定义的，除了继承SurfaceFlinger类的方法外，还根据各个厂家的产品自己增加了一些扩展。我司SurfaceFlingerEx的定义请自行于源码中搜索<a href="./vendor/huawei/Emui/frameworks/hwCommInterface/include/SurfaceFlingerEx.h">SurfaceFlingerEx.h</a>和<a href="./vendor/huawei/Emui/frameworks/native/services/surfaceflinger/SurfaceFlingerEx.cpp">SurfaceFlingerEx.cpp</a>查看。我们只看surfaceFlinger类。</p><p>[-&gt;surfaceflinger.cpp]</p><pre class=" language-C++"><code class="language-C++">SurfaceFlinger::SurfaceFlinger(Factory& factory, SkipInitializationTag)      : mFactory(factory),        mPhaseOffsets(mFactory.createPhaseOffsets()),        mInterceptor(mFactory.createSurfaceInterceptor(this)),        mTimeStats(mFactory.createTimeStats()),        mEventQueue(mFactory.createMessageQueue()),        skipScrnRecDelay(false),        skipScreenRecord(0),        mShotSkipVAssistLayer(0),        mKnuckleScreenShot(0),        mRogWidth(0),        mRogHeight(0),        mRogFeature(0),        mIsSdrSupported(false),        mPrimaryConfigSize(0),        mLastSDRComposeWidth(0),        mLastSDRComposeHeight(0),        mCompositionEngine(mFactory.createCompositionEngine()),        // hisi Xsync and PreComposite opt        mSuppressTouchSync(false),        mTouchSyncOn(false),        mLargeLayerCount(0),        mIsTouchMode(false),        mVsyncEnabled(false),        mDownAppSfOffsetWorkFlag(false),        mFrameRateOptSwitch(false) {    mItouchToSurfaceflingerInfo.firstFrameOpt = false;    mItouchToSurfaceflingerInfo.backPressureOpt = false;    mItouchToSurfaceflingerInfo.backPressureCount = BACKPRESSURE_INIT_COUNT;    mItouchToSurfaceflingerInfo.backPressureCountMax = BACKPRESSURE_COUNT_MAX;}SurfaceFlinger::SurfaceFlinger(Factory& factory) : SurfaceFlinger(factory, SkipInitialization) {    ALOGI("SurfaceFlinger is starting");    hasSyncFramework = running_without_sync_framework(true);    dispSyncPresentTimeOffset = present_time_offset_from_vsync_ns(0);    useHwcForRgbToYuv = force_hwc_copy_for_virtual_displays(false);    maxVirtualDisplaySize = max_virtual_display_dimension(0);    // Vr flinger is only enabled on Daydream ready devices.    useVrFlinger = use_vr_flinger(false);    maxFrameBufferAcquiredBuffers = max_frame_buffer_acquired_buffers(2);    hasWideColorDisplay = has_wide_color_display(false);    useColorManagement = use_color_management(false);    mDefaultCompositionDataspace =            static_cast<ui::Dataspace>(default_composition_dataspace(Dataspace::V0_SRGB));    mWideColorGamutCompositionDataspace = static_cast<ui::Dataspace>(wcg_composition_dataspace(            hasWideColorDisplay ? Dataspace::DISPLAY_P3 : Dataspace::V0_SRGB));    defaultCompositionDataspace = mDefaultCompositionDataspace;    wideColorGamutCompositionDataspace = mWideColorGamutCompositionDataspace;    defaultCompositionPixelFormat = static_cast<ui::PixelFormat>(            default_composition_pixel_format(ui::PixelFormat::RGBA_8888));    wideColorGamutCompositionPixelFormat =            static_cast<ui::PixelFormat>(wcg_composition_pixel_format(ui::PixelFormat::RGBA_8888));    useContextPriority = use_context_priority(true);    auto tmpPrimaryDisplayOrientation = primary_display_orientation(            SurfaceFlingerProperties::primary_display_orientation_values::ORIENTATION_0);    switch (tmpPrimaryDisplayOrientation) {        case SurfaceFlingerProperties::primary_display_orientation_values::ORIENTATION_90:            SurfaceFlinger::primaryDisplayOrientation = DisplayState::eOrientation90;            break;        case SurfaceFlingerProperties::primary_display_orientation_values::ORIENTATION_180:            SurfaceFlinger::primaryDisplayOrientation = DisplayState::eOrientation180;            break;        case SurfaceFlingerProperties::primary_display_orientation_values::ORIENTATION_270:            SurfaceFlinger::primaryDisplayOrientation = DisplayState::eOrientation270;            break;        default:            SurfaceFlinger::primaryDisplayOrientation = DisplayState::eOrientationDefault;            break;    }    ALOGV("Primary Display Orientation is set to %2d.", SurfaceFlinger::primaryDisplayOrientation);    mInternalDisplayPrimaries = sysprop::getDisplayNativePrimaries();    // debugging stuff...    char value[PROPERTY_VALUE_MAX];    property_get("ro.bq.gpu_to_cpu_unsupported", value, "0");    mGpuToCpuSupported = !atoi(value);    property_get("debug.sf.showupdates", value, "0");    mDebugRegion = atoi(value);    ALOGI_IF(mDebugRegion, "showupdates enabled");    // DDMS debugging deprecated (b/120782499)    property_get("debug.sf.ddms", value, "0");    int debugDdms = atoi(value);    ALOGI_IF(debugDdms, "DDMS debugging not supported");    property_get("debug.sf.disable_backpressure", value, "0");    mPropagateBackpressure = !atoi(value);    ALOGI_IF(!mPropagateBackpressure, "Disabling backpressure propagation");    property_get("debug.sf.enable_gl_backpressure", value, "0");    mPropagateBackpressureClientComposition = atoi(value);    ALOGI_IF(mPropagateBackpressureClientComposition,             "Enabling backpressure propagation for Client Composition");    property_get("debug.sf.enable_hwc_vds", value, "0");    mUseHwcVirtualDisplays = atoi(value);    ALOGI_IF(mUseHwcVirtualDisplays, "Enabling HWC virtual displays");    property_get("ro.sf.disable_triple_buffer", value, "0");    mLayerTripleBufferingDisabled = atoi(value);    ALOGI_IF(mLayerTripleBufferingDisabled, "Disabling Triple Buffering");    property_get("debug.sf.partialCompose", value, "1");    mUsePartialCompose = atoi(value);    ALOGI_IF(!mUsePartialCompose, "Disable partial compose");    const size_t defaultListSize = MAX_LAYERS;    auto listSize = property_get_int32("debug.sf.max_igbp_list_size", int32_t(defaultListSize));    mMaxGraphicBufferProducerListSize = (listSize > 0) ? size_t(listSize) : defaultListSize;    mUseSmart90ForVideo = use_smart_90_for_video(false);    property_get("debug.sf.use_smart_90_for_video", value, "0");    int int_value = atoi(value);    if (int_value) {        mUseSmart90ForVideo = true;    }    property_get("debug.sf.luma_sampling", value, "1");    mLumaSampling = atoi(value);    const auto [early, gl, late] = mPhaseOffsets->getCurrentOffsets();    mVsyncModulator.setPhaseOffsets(early, gl, late);    // We should be reading 'persist.sys.sf.color_saturation' here    // but since /data may be encrypted, we need to wait until after vold    // comes online to attempt to read the property. The property is    // instead read after the boot animation    // hisi Xsync and PreComposite opt    property_get("persist.kirin.touch_vsync_opt", value, "0");    mTouchVsyncOpt = atoi(value);    ALOGI_IF(mTouchVsyncOpt, "Touch Vsync opt enabled");    if (useTrebleTestingOverride()) {        // Without the override SurfaceFlinger cannot connect to HIDL        // services that are not listed in the manifests.  Considered        // deriving the setting from the set service name, but it        // would be brittle if the name that's not 'default' is used        // for production purposes later on.        setenv("TREBLE_TESTING_OVERRIDE", "true", true);    }    GameExLayer::CreateWorkerThread();    xcollie_init();}</code></pre><p>通过构造函数SurfaceFlinger(Factory&amp; factory)创建对象，该构造函数先通过SurfaceFlinger(Factory&amp; factory, SkipInitializationTag)初始化部分成员变量，然后自己再配置SurfaceFlinger的相关属性参数。其中比较重要的是通过factory对象初始化的变量，如下</p><blockquote><p>mFactory(factory)<br>mPhaseOffsets(mFactory.createPhaseOffsets())<br>mInterceptor(mFactory.createSurfaceInterceptor(this))<br>mTimeStats(mFactory.createTimeStats())<br>mEventQueue(mFactory.createMessageQueue())<br>mCompositionEngine(mFactory.createCompositionEngine())</p></blockquote><h3 id="SurfaceFlinger初始化"><a href="#SurfaceFlinger初始化" class="headerlink" title="SurfaceFlinger初始化"></a>SurfaceFlinger初始化</h3><h4 id="OnFistRef调用"><a href="#OnFistRef调用" class="headerlink" title="OnFistRef调用"></a>OnFistRef调用</h4><p>在main_SurfaceFlinger.cpp文件的main函数中可以看到，实例初始化代码是<strong>sp<surfaceflinger> flinger = surfaceflinger::createSurfaceFlinger()</surfaceflinger></strong>，这里使用的是sp强引用，根据C++11的新特性可知，在使用强引用时，会自动调用对象的OnFistRef函数。SurfaceFlinger类重定义了OnFistRef函数如下：</p><pre class=" language-c++"><code class="language-c++">void SurfaceFlinger::onFirstRef(){    mEventQueue->init(this);}</code></pre><p>onFirstRef函数主要是初始化了mEventQueue，mEventQueue主要作用是线程间发送接收消息。</p><p>因为mEnentQueue是通过mFactory创建的，而mFactory对应的类是在createSurfaceFlinger函数中定义的，所以mFactory相关的操作都可以到createSurfaceFlinger中去找，此处从createMessageQueue()函数可知mEventQueue是android::impl::MessageQueue()类的实例。</p><h5 id="mEventQueue"><a href="#mEventQueue" class="headerlink" title="mEventQueue"></a>mEventQueue</h5><p>mEventQueue-&gt;init(this)中this及surfaceFlinger对象本身，mEventQueue-&gt;init(this)代码如下：</p><p>[-&gt;MessageQueue.cpp]</p><pre class=" language-c++"><code class="language-c++">void MessageQueue::init(const sp<SurfaceFlinger>& flinger) {    mFlinger = flinger;    mLooper = new Looper(true);    mHandler = new Handler(*this);}</code></pre><p>init函数保存了surfaceFlinger对象，同时创建了一个looper对象和一个Handler对象。</p><p>looper是android的looper类，可以<a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">参考此文档</a>。</p><p>Handler继承与MeeeageHandler类，声明和定义如下：</p><p>[-&gt;MEssageQueue.h]</p><pre class=" language-c++"><code class="language-c++">class MessageQueue final : public android::MessageQueue {    class Handler : public MessageHandler {        enum { eventMaskInvalidate = 0x1, eventMaskRefresh = 0x2, eventMaskTransaction = 0x4 };        MessageQueue& mQueue;        int32_t mEventMask;    public:        explicit Handler(MessageQueue& queue) : mQueue(queue), mEventMask(0) {}        virtual void handleMessage(const Message& message);        void dispatchRefresh();        void dispatchInvalidate();    };</code></pre><p>[-&gt;MessageQueue.cpp]</p><pre class=" language-c++"><code class="language-c++">void MessageQueue::Handler::dispatchRefresh() {    if ((android_atomic_or(eventMaskRefresh, &mEventMask) & eventMaskRefresh) == 0) {        mQueue.mLooper->sendMessage(this, Message(MessageQueue::REFRESH));    }}void MessageQueue::Handler::dispatchInvalidate() {    if ((android_atomic_or(eventMaskInvalidate, &mEventMask) & eventMaskInvalidate) == 0) {        mQueue.mLooper->sendMessage(this, Message(MessageQueue::INVALIDATE));    }}void MessageQueue::Handler::handleMessage(const Message& message) {    switch (message.what) {        case INVALIDATE:            android_atomic_and(~eventMaskInvalidate, &mEventMask);            mQueue.mFlinger->onMessageReceived(message.what);            break;        case REFRESH:            android_atomic_and(~eventMaskRefresh, &mEventMask);            mQueue.mFlinger->onMessageReceived(message.what);            break;    }}</code></pre><p>可以看到，mHandle主要用于处理message，对象保存了mEventQueue和msurfaceFlinger对象。</p><p>mEventQueue中mFlinger，mlooper，mhandler之间关系如下：</p><pre class="mermaid">graph LRA[mhandle]--&gt;|dispatchInvalidate|B[mloop.sendMessage]A--&gt;|dispatchRefresh|BA--&gt;|handleMessage|C[mFlinger.onMessageReceived]</pre><p>简单描述上述关系是：mEventQueue是SurfaceFlinger的消息管理队列，SurfaceFlinger通过mEventQueue管理消息，mEventQueue又通过mhandle处理消息，其中mhandle通过mlooper发送消息，通过回调SurfaceFlinger的OnMessageReceived函数处理消息。</p><p><em>从MessageQueue的代码看，SurfaceFlinger只是通过MessageQueue的looper发送消息，并没用mHandle的handleMessage处理消息，也就是说SurfaceFlinger的OnMessageReceived函数并没有被MessageQueue的mHandle变量调用，那么被谁调用了呢？其实，handleMessage是被looper自动调用的，handler线程被注册到looper线程，loop线程自动调用handler.handleMessage</em></p><pre class="mermaid">graph TBMessageQueue--&gt;|Refresh|mHandler.dispatchRefreshmHandler.dispatchRefresh--&gt;|Refresh|mLooper.sendMessagemLooper.sendMessage--&gt;|Refresh|handler.handleMessagehandler.handleMessage--&gt;|Refresh|sflinger.OnMessageReceiveddispVsync--&gt;|gui::bitupe|mLoopermLooper--&gt;|callback|MessageQueue::cb_eventReceiverMessageQueue::cb_eventReceiver--&gt;MessageQueue::eventReceiverMessageQueue::eventReceiver--&gt;Handler::dispatchInvalidateHandler::dispatchInvalidate--&gt;|Invalided|mLooper.sendMessagemLooper.sendMessage--&gt;|Invalided|handler.handleMessagehandler.handleMessage--&gt;|Invalided|sflinger.OnMessageReceivedsflinger.OnMessageReceived--&gt;|Invalided_To_Refresh|MessageQueue</pre><h4 id="init初始化"><a href="#init初始化" class="headerlink" title="init初始化"></a>init初始化</h4><p>surfaceFlinger的init代码如下：</p><p>[-&gt;surfaceFlinger.cpp]</p><pre class=" language-c++"><code class="language-c++">void SurfaceFlinger::init() {    ALOGI(  "SurfaceFlinger's main thread ready to run. "            "Initializing graphics H/W...");    ALOGI("Phase offset NS: %" PRId64 "", mPhaseOffsets->getCurrentAppOffset());    Mutex::Autolock _l(mStateLock);    // start the EventThread    mScheduler =            getFactory().createScheduler([this](bool enabled) { setPrimaryVsyncEnabled(enabled); },                                         mRefreshRateConfigs);    auto resyncCallback =            mScheduler->makeResyncCallback(std::bind(&SurfaceFlinger::getVsyncPeriod, this));    mAppConnectionHandle =            mScheduler->createConnection("app", mPhaseOffsets->getCurrentAppOffset(),                                         resyncCallback,                                         impl::EventThread::InterceptVSyncsCallback());    mSfConnectionHandle = mScheduler->createConnection("sf", mPhaseOffsets->getCurrentSfOffset(),                                                       resyncCallback, [this](nsecs_t timestamp) {                                                           mInterceptor->saveVSyncEvent(timestamp);                                                       });    //把sf时钟的回调数据与mEventQueue的looper线程联系在一起    mEventQueue->setEventConnection(mScheduler->getEventConnection(mSfConnectionHandle));    mVsyncModulator.setSchedulerAndHandles(mScheduler.get(), mAppConnectionHandle.get(),                                           mSfConnectionHandle.get());    mRegionSamplingThread =            new RegionSamplingThread(*this, *mScheduler,                                     RegionSamplingThread::EnvironmentTimingTunables());    // Get a RenderEngine for the given display / config (can't fail)    int32_t renderEngineFeature = 0;    renderEngineFeature |= (useColorManagement ?                            renderengine::RenderEngine::USE_COLOR_MANAGEMENT : 0);    renderEngineFeature |= (useContextPriority ?                            renderengine::RenderEngine::USE_HIGH_PRIORITY_CONTEXT : 0);    renderEngineFeature |=            (enable_protected_contents(false) ? renderengine::RenderEngine::ENABLE_PROTECTED_CONTEXT                                              : 0);    // TODO(b/77156734): We need to stop casting and use HAL types when possible.    // Sending maxFrameBufferAcquiredBuffers as the cache size is tightly tuned to single-display.    mCompositionEngine->setRenderEngine(            renderengine::RenderEngine::create(static_cast<int32_t>(defaultCompositionPixelFormat),                                               renderEngineFeature,                                               maxFrameBufferAcquiredBuffers + mPartialComposeCacheSize));    LOG_ALWAYS_FATAL_IF(mVrFlingerRequestsDisplay,            "Starting with vr flinger active is not currently supported.");    //通过HWC::impl:Composer创建android::impl::Composer实例    mCompositionEngine->setHwComposer(getFactory().createHWComposer(getBE().mHwcServiceName));    //向HWC::impl::Composer注册三个回调函数。    mCompositionEngine->getHwComposer().registerCallback(this, getBE().mComposerSequenceId);    // Process any initial hotplug and resulting display changes.    //处理初始化时的热插拔消息。    processDisplayHotplugEventsLocked();    //获取显示设备的ID    const auto display = getDefaultDisplayDeviceLocked();    LOG_ALWAYS_FATAL_IF(!display, "Missing internal display after registering composer callback.");    LOG_ALWAYS_FATAL_IF(!getHwComposer().isConnected(*display->getId()),                        "Internal display is disconnected.");    if (useVrFlinger) {        auto vrFlingerRequestDisplayCallback = [this](bool requestDisplay) {            // This callback is called from the vr flinger dispatch thread. We            // need to call signalTransaction(), which requires holding            // mStateLock when we're not on the main thread. Acquiring            // mStateLock from the vr flinger dispatch thread might trigger a            // deadlock in surface flinger (see b/66916578), so post a message            // to be handled on the main thread instead.            postMessageAsync(new LambdaMessage([=] {                ALOGI("VR request display mode: requestDisplay=%d", requestDisplay);                mVrFlingerRequestsDisplay = requestDisplay;                signalTransaction();            }));        };        mVrFlinger = dvr::VrFlinger::Create(getHwComposer().getComposer(),                                            getHwComposer()                                                    .fromPhysicalDisplayId(*display->getId())                                                    .value_or(0),                                            vrFlingerRequestDisplayCallback);        if (!mVrFlinger) {            ALOGE("Failed to start vrflinger");        }    }    // initialize our drawing state    mDrawingState = mCurrentState;    // set initial conditions (e.g. unblank default device)    //发送异步消息，初始化设备    initializeDisplays();    getRenderEngine().primeCache();    // Inform native graphics APIs whether the present timestamp is supported:    //创建启动动画线程    const bool presentFenceReliable =            !getHwComposer().hasCapability(HWC2::Capability::PresentFenceIsNotReliable);    mStartPropertySetThread = getFactory().createStartPropertySetThread(presentFenceReliable);    //启动开机动画线程    if (mStartPropertySetThread->Start() != NO_ERROR) {        ALOGE("Run StartPropertySetThread failed!");    }    //配置刷新了改变回调函数    mScheduler->setChangeRefreshRateCallback(            [this](RefreshRateType type, Scheduler::ConfigEvent event) {                Mutex::Autolock lock(mStateLock);                setRefreshRateTo(type, event);            });    //配置周期获取回调函数    mScheduler->setGetVsyncPeriodCallback([this] {        Mutex::Autolock lock(mStateLock);        return getVsyncPeriod();    });    //保存当前刷新了参数    mRefreshRateConfigs.populate(getHwComposer().getConfigs(*display->getId()));    mRefreshRateStats.setConfigMode(getHwComposer().getActiveConfigIndex(*display->getId()));    // obtain hwvsync period and initial vsync offset    sfFrameInfo.intialSfVsyncOffset = ns2ms(mPhaseOffsets->getCurrentSfOffset());    // ns transfer ms for float type    sfFrameInfo.hwVsyncPeriod = getVsyncPeriod() / 1000000.0;    ALOGV("Done initializing");}</code></pre><p>代码有点长，我们慢慢看，</p><p><strong>mScheduler</strong></p><pre class=" language-c++"><code class="language-c++">    mScheduler =            getFactory().createScheduler([this](bool enabled) { setPrimaryVsyncEnabled(enabled); },                                         mRefreshRateConfigs);    auto resyncCallback =            mScheduler->makeResyncCallback(std::bind(&SurfaceFlinger::getVsyncPeriod, this));    mAppConnectionHandle =            mScheduler->createConnection("app", mPhaseOffsets->getCurrentAppOffset(),                                         resyncCallback,                                         impl::EventThread::InterceptVSyncsCallback());    mSfConnectionHandle = mScheduler->createConnection("sf", mPhaseOffsets->getCurrentSfOffset(),                                                       resyncCallback, [this](nsecs_t timestamp) {                                                           mInterceptor->saveVSyncEvent(timestamp);                                                       });</code></pre><p>创建Scheduler实例，两个入参：</p><ol><li>lamda定义的回调函数[this](bool enabled) { setPrimaryVsyncEnabled(enabled);函数实现是SurfaceFlinger控制Vsync信号的开关。也就是SurfaceFlinger的Vsync信号使能是由Schedule控制的。</li><li>刷新率配置变量的地址，Scheduler内部操作的mRefreshRateConfigs变量就是SurfaceFlinger的mRefreshRateConfigs。</li></ol><p>使用Scheduler::makeResyncCallback函数构造一个回调函数，回调的是SurfaceFlinger实例对象的getVsyncPeriod函数。</p><p>使用CreateConnection函数创建app和sf时钟信号。app信号用于管理app的消息处理。sf信号用来管理SurfaceFlinger内部的消息处理。创建过程如下：</p><pre class=" language-c++"><code class="language-c++">sp<Scheduler::ConnectionHandle> Scheduler::createConnection(        const char* connectionName, int64_t phaseOffsetNs, ResyncCallback resyncCallback,        impl::EventThread::InterceptVSyncsCallback interceptCallback) {    const int64_t id = sNextId++;    ALOGV("Creating a connection handle with ID: %" PRId64 "\n", id);    std::unique_ptr<EventThread> eventThread =            makeEventThread(connectionName, mPrimaryDispSync.get(), phaseOffsetNs,                            std::move(interceptCallback));    auto eventThreadConnection =            createConnectionInternal(eventThread.get(), std::move(resyncCallback));    mConnections.emplace(id,                         std::make_unique<Connection>(new ConnectionHandle(id),                                                      eventThreadConnection,                                                      std::move(eventThread)));    return mConnections[id]->handle;}std::unique_ptr<EventThread> Scheduler::makeEventThread(        const char* connectionName, DispSync* dispSync, int64_t phaseOffsetNs,        impl::EventThread::InterceptVSyncsCallback interceptCallback) {    std::unique_ptr<VSyncSource> eventThreadSource =            std::make_unique<DispSyncSource>(dispSync, phaseOffsetNs, true, connectionName);    return std::make_unique<impl::EventThread>(std::move(eventThreadSource),                                               std::move(interceptCallback), connectionName);}sp<EventThreadConnection> Scheduler::createConnectionInternal(EventThread* eventThread,                                                              ResyncCallback&& resyncCallback) {    return eventThread->createEventConnection(std::move(resyncCallback));}</code></pre><p>首先通过makeEventThread创建eventThread实例，实例创建需要三个参数，connectionName,initerceptCallback,eventThreadSource。</p><ul><li><p>先是通过mPrimaryDispSync创建VSyncSource类的实例eventThreadSource。mPrimaryDispSync变量在Scheduler的构造函数中初始化，是一个android::impl::DispSync类。</p></li><li><p>创建android::impl::EventThread类实例，同时传入构造函数。</p></li></ul><p>接着通过createConnectionInternal函数把EventThread和SurfaceFlinger函数的回调getVsyncPeriod链接起来。</p><p>所以在整个场景关系图如下所示：</p><pre class="mermaid">graph LRShecdule[Scheduler::mConnections]--&gt;Connect[appconnect]Connect--&gt;id[connectionHandle::id]Connect--&gt;EvenctTc[EventThreadConnection eventThreadConnection]Connect--&gt;ET[android::impl::EventThread eventThread]ET--&gt;|create|EvenctTcEvenctTc--&gt;|resyncCallback|F[surfaceFlinger::getVsyncPeriod]ET--&gt;VsyncSource[VsyncSource::eventThreadSource]DispVsync[android::impl::DispSync mPrimaryDispSync]--&gt;VsyncSourceET--&gt;|mInterceptVSyncsCallback|ETetc[impl::EventThread::InterceptVSyncsCallback]Shecdule--&gt;Connect1[sfconnect]Connect1--&gt;id1[connectionHandle::id]Connect1--&gt;EvenctTc1[EventThreadConnection eventThreadConnection]Connect1--&gt;ET1[android::impl::EventThread eventThread]ET1--&gt;|create|EvenctTc1EvenctTc1--&gt;|resyncCallback|F1[surfaceFlinger::getVsyncPeriod]ET1--&gt;VsyncSource1[VsyncSource::eventThreadSource]DispVsync[android::impl::DispSync mPrimaryDispSync]--&gt;VsyncSource1ET1--&gt;|mInterceptVSyncsCallback|ETetc1[Scheduler mInterceptor.saveVSyncEvent]EvenctTc1--&gt;|setEventConnnect|EvenctTc1SFMQ[sfMessageQueue]SFVM[VSyncModulator]--&gt;|mScheduler|ShecduleSFVM--&gt;|mAppConnectionHandle|idSFVM--&gt;|mSfConnectionHandle|id1</pre><pre class="mermaid">graph LRSF[surfaceFlinger]--&gt;|mScheduler|Schedule[android::Schedule]SF--&gt;|mAppConnectionHandle|appConnectionHandle[Scheduler::ConnectionHandle]SF--&gt;|msfConnectionHandle|sfConnectionHandle[Scheduler::ConnectionHandle]SF--&gt;|mEventQueue|SFEvConnect[sfEventThreadConnect]VSyncModulator--&gt;|mSchedule|ScheduleVSyncModulator--&gt;|mAppConnectionHandle|appConnectionHandleVSyncModulator--&gt;|mSfConnectionHandle|sfConnectionHandleSF--&gt;|mVsyncModulator|VSyncModulator</pre><h2 id="surfaceFlinger运行通路"><a href="#surfaceFlinger运行通路" class="headerlink" title="surfaceFlinger运行通路"></a>surfaceFlinger运行通路</h2><p>surfaceFlinger的主要作用有三个：向app侧传递app-Vsync信号；向app侧和HWC提供surface layer；根据sf-Vsync节奏合成surface layer。其中app-Vsync和sf-Vsync是SF传递的时钟信号，本节主要介绍的内容。surface layer是上下层的数据流，数据流的传递后续章节结合app侧和HWC侧介绍。</p><h3 id="app-Vsync信号注册和回调"><a href="#app-Vsync信号注册和回调" class="headerlink" title="app-Vsync信号注册和回调"></a>app-Vsync信号注册和回调</h3><p>application的activity在java层经过一系列流程创建完成之后，通过DisplayerEventListener与native的SF进行app-VSync的通信，主要通信流程如下所示：</p><pre class="mermaid">sequenceDiagramBpDisplayerListener-&gt;&gt;BnDisplayerListener:gui:bitubeBnDisplayerListener-&gt;&gt;DisplayEventReceiver:newDisplayEventReceiver-&gt;&gt;surfaceFlinger:createDisplayEventConnectsurfaceFlinger-&gt;&gt;Scheduler:createConnectionInternalScheduler-&gt;&gt;EventThreadConnection:newEventThreadConnection-&gt;&gt;EventThread:OnfirstRefEventThread-&gt;&gt;connection:registerDisplayEventConnectionloop app-Vsync    DispVsync-&gt;&gt;EventThread:onVsync    EventThread-&gt;&gt;EventThread:notify_allend    loop threadmain    EventThread-&gt;&gt;EventThread:waite notifyed    EventThread-&gt;&gt;connection:connection    connection-&gt;&gt;EventThreadConnection:post    EventThreadConnection-&gt;&gt;DisplayEventReceiver:sedEvents    DisplayEventReceiver-&gt;&gt;BpDisplayerListener:gui::bitube:sendObjectsend</pre><p>BpDisplayerListener是WMS(windowManagerServer)的一个的与native接口的类，app-Vsync消息处理其实真正对应的类有三个，EventThreadConnection，EventThread，DispVsync。一个activity的一个layer或surface注册一个ETC（EventThreadConnection），所有的 ETC保存在EventThread的Vector中。DispVsync负责向EventThread发送Vsync到来信号。简化流程如下</p><pre class="mermaid">graph LRDispEventReceiver--&gt;|注册app-Vsync监听|vectorEventThreadConnectionDispVsync--&gt;|appVsync信号|EventThreadEventThread--&gt;|调用OnVsync处理|vectorEventThreadConnection  vectorEventThreadConnection --&gt;EventThreadConnection1EventThreadConnection1--&gt;|向java层发app-Vsync消息|app1vectorEventThreadConnection --&gt;EventThreadConnection2EventThreadConnection2--&gt;|向java层发app-Vsync消息|app2vectorEventThreadConnection --&gt;EventThreadConnection3EventThreadConnection3--&gt;|向java层发app-Vsync消息|app3vectorEventThreadConnection --&gt;EventThreadConnection4EventThreadConnection4--&gt;|向java层发app-Vsync消息|app4</pre><h3 id="sf-Vsync信号注册和回调"><a href="#sf-Vsync信号注册和回调" class="headerlink" title="sf-Vsync信号注册和回调"></a>sf-Vsync信号注册和回调</h3><h4 id="代码调用流程"><a href="#代码调用流程" class="headerlink" title="代码调用流程"></a>代码调用流程</h4><p>sf-Vsync的时钟产生和消息处理通路与app-Vsync消息的产生和处理通路类似，不同的是sf-Vsync消息对应的是一个EventThreadConnection，EventThreadConnection再调用MessageQueue去处理surface合成。主要通信流程如下：</p><pre class="mermaid">sequenceDiagram surface-&gt;&gt;surfaceFlinger:register VectorSurfacesurfaceFlinger-&gt;&gt;Scheduler:CreateConnectionScheduler-&gt;&gt;EventThread:newScheduler-&gt;&gt;EventThreadConnection:newEventThreadConnection-&gt;&gt;EventThread:registeEventThreadConnection-&gt;&gt;MessageQueue:registeMessageQueue-&gt;&gt;'Loop':newMessageQueue-&gt;&gt;handler:newloop sf-Vsync    DispVsync-&gt;&gt;EventThread:onVsync    EventThread-&gt;&gt;EventThread:notify_allend loop threadmain    EventThread-&gt;&gt;EventThread:waite notifyed    EventThread-&gt;&gt;connection:connection    connection-&gt;&gt;EventThreadConnection:post    EventThreadConnection-&gt;&gt;DisplayEventReceiver:sedEvents    DisplayEventReceiver-&gt;&gt;MessageQueue:gui::bitube:sendObjectsendMessageQueue-&gt;&gt;handler:dispatchInvalidatehandler-&gt;&gt;'Loop':sendMessage INVALIDATE'Loop'-&gt;&gt;handler:handlerMessage INVALIDATEhandler-&gt;&gt;surfaceFlinger:OnMessageReceived INVALIDATEsurfaceFlinger-&gt;&gt;surfaceFlinger:handlerSurfaceCompose VectorSurfacesurfaceFlinger-&gt;&gt;MessageQueue:sendMessage REFERSHMessageQueue-&gt;&gt;'Loop':sendMessage REFERSH'Loop'-&gt;&gt;handler:handlerMessage REFERSHhandler-&gt;&gt;surfaceFlinger:OnMessageReceived REFERSHsurfaceFlinger--&gt;&gt;HWC:composition</pre><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p>sf-Vsync是SurfaceFlinger的内部时钟，用于处理surface合并事件，简单理解sf-Vsync的通路如下：</p><pre class="mermaid">graph TBDispVsync--&gt;|1 sfVsync信号|EventThreadEventThread--&gt;|2 调用OnVsync处理|vectorEventThreadConnection  surface--&gt;|注册layer监听|surfaceFlingervectorEventThreadConnection --&gt;|3 gui::bitupe|LooperLooper--&gt;|4 callback::cb_eventReceiver|MessageQueueMessageQueue--&gt;|5 调用loop<br>发送sfVsync/REFERSH到来消息|LooperLooper--&gt;|6 handler调用handlerMessage<br>处理loop的消息|HandlerHandler--&gt;|7 调用sf.OnMessageReceived<br>响应sfVsync/REFERSH消息|surfaceFlingersurfaceFlinger--&gt;|8 根据surface合并结果<br>确定是否刷新|MessageQueuesurfaceFlinger--&gt;|9 渲染|ESGLsurfaceFlinger--&gt;|10 fench/surface|HWCESGL--&gt;|11 release fench|HWC</pre><p>surface注册到surfaceFlinger之后，会保存到一个队列中。在sf-Vsync到来后，会处理保存的surfaces，根据处理结果判断是否需要合并surface触发刷新操作。在刷新操作中会合并surface，同时调用GPU执行合并操作，同时生成新的fench信号给HWC。</p><h2 id="创建Activity和注册surface流程"><a href="#创建Activity和注册surface流程" class="headerlink" title="创建Activity和注册surface流程"></a>创建Activity和注册surface流程</h2><h3 id="Activity的启动流程"><a href="#Activity的启动流程" class="headerlink" title="Activity的启动流程"></a>Activity的启动流程</h3><p>转载自:<a href="https://www.jianshu.com/p/9ecea420eb52" target="_blank" rel="noopener">3分钟看懂Activity启动流程</a></p><p><img src="1869462-1ee9c9600c8ac2cd.webp" alt="Activity启动流程"></p><p>Android中，一个应用程序的开始可以说就是从<strong>ActivityThread.java</strong>中的main()方法开始的。都是学过Java的人，想必也都知道Java的程序入口就是main()方法。从这点而言，我们可以把它想成是一个Java程序（注意，不是说Android是个Java程序哦）去理解。</p><p>从上图可以看到，main()方法中主要做的事情有：</p><ol><li><p>初始化主线程的Looper、主Handler。并使主线程进入等待接收Message消息的无限循环状态。</p></li><li><p>调用attach()方法，主要就是为了发送出初始化Application的消息。</p></li><li><p>创建Application的消息是如何发送的呢？</p><p>上面提到过，ActivityThread的attach()方法最终的目的是发送出一条创建Application的消息——H.BIND_APPLICATION，到主线程的主Handler中。</p></li></ol><h4 id="一切从main-方法开始"><a href="#一切从main-方法开始" class="headerlink" title="一切从main()方法开始"></a>一切从main()方法开始</h4><p>Android中，一个应用程序的开始可以说就是从<strong>ActivityThread.java</strong>中的main()方法开始的。都是学过Java的人，想必也都知道Java的程序入口就是main()方法。从这点而言，我们可以把它想成是一个Java程序（注意，不是说Android是个Java程序哦）去理解。</p><p><img src="1869462-882b8e0470adf85a.webp" alt="img"></p><p>从上图可以看到，main()方法中主要做的事情有：</p><ol><li>初始化主线程的Looper、主Handler。并使主线程进入等待接收Message消息的无限循环状态。关于Android的Handler机制，可以参考一下我上面提到的文章：<br> <a href="https://www.jianshu.com/p/8862bd2b6a29" target="_blank" rel="noopener">【惊天秘密！从Thread开始，揭露Android线程通讯的诡计和主线程的阴谋】http://www.jianshu.com/p/8862bd2b6a29</a><br> 下面是main()方法中比较关键的代码：</li></ol><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    Looper<span class="token punctuation">.</span><span class="token function">prepareMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//初始化Looper</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    ActivityThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ActivityThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实例化一个ActivityThread</span>    thread<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这个方法最后就是为了发送出创建Application的消息</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     Looper<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//主线程进入无限循环状态，等待接收消息</span><span class="token punctuation">}</span></code></pre><p>2.调用attach()方法，主要就是为了发送出初始化Application的消息。这个流程说长不长，说短不短。下文会再捋一捋。</p><h4 id="创建Application的消息是如何发送的呢？"><a href="#创建Application的消息是如何发送的呢？" class="headerlink" title="创建Application的消息是如何发送的呢？"></a>创建Application的消息是如何发送的呢？</h4><p>上面提到过，ActivityThread的attach()方法最终的目的是发送出一条创建Application的消息——H.BIND_APPLICATION，到主线程的主Handler中。那我们来看看attach()方法干了啥。<br> attach()关键代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attach</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> system<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">final</span> IActivityManager mgr <span class="token operator">=</span> ActivityManagerNative<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//获得IActivityManager实例，下面会看看它是个啥</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        mgr<span class="token punctuation">.</span><span class="token function">attachApplication</span><span class="token punctuation">(</span>mAppThread<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//看见没？关键啊。mAppThread这个参数下面也会说一下</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RemoteException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> ex<span class="token punctuation">.</span><span class="token function">rethrowFromSystemServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>莫慌莫慌，下面看看上面出现的两个对象是个啥。</p><h4 id="IActivityManager-mgr是个啥？"><a href="#IActivityManager-mgr是个啥？" class="headerlink" title="IActivityManager mgr是个啥？"></a>IActivityManager mgr是个啥？</h4><p>从上图也可以看到，IActivityManager是一个接口，当我们调用<code>ActivityManagerNative.getDefault()</code>获得的实际是一个代理类的实例——<strong>ActivityManagerProxy</strong>，这个东西实现了IActivityManager接口。打开源码你会发现，<strong>ActivityManagerProxy</strong>是ActivityManagerNative的一个内部类。可以看出，Android团队在设计的过程中是实践了<strong>最小惊异原则</strong>的，就是把相关的东西尽量放在一起。那么既然是个代理类，它究竟代理了谁？代码里看看喽。<br> 下面这个代码稍微有点绕啊！老哥，稳住！</p><ol><li>先看ActivityManagerProxy的构造函数：</li></ol><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token function">ActivityManagerProxy</span><span class="token punctuation">(</span>IBinder remote<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mRemote <span class="token operator">=</span> remote<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个构造函数非常的简单。首先它需要一个IBinder参数，然后赋值给<strong>mRemote</strong>变量。这个<strong>mRemote</strong>显然是ActivityManagerProxy的成员变量，对它的操作是由ActivityManagerProxy来代理间接进行的。这样设计的好处是保护了mRemote，并且能够在操作mRemote前执行一些别的事务，并且我们是以IActivityManager的身份来进行这些操作的！这就非常巧妙了。</p><ol><li>那么这个构造函数是在那调用的呢？</li></ol><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">static</span> <span class="token keyword">public</span> IActivityManager <span class="token function">asInterface</span><span class="token punctuation">(</span>IBinder obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    IActivityManager <span class="token keyword">in</span> <span class="token operator">=</span>        <span class="token punctuation">(</span>IActivityManager<span class="token punctuation">)</span>obj<span class="token punctuation">.</span><span class="token function">queryLocalInterface</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//先检查一下有没有</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">in</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">in</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ActivityManagerProxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这个地方调用了构造函数</span><span class="token punctuation">}</span></code></pre><p>上面这个方法是ActivityManagerNative中的一个静态方法，它会调用到ActivityManagerProxy的构造方法。然而，这个静态方法也需要一个IBinder作为参数!老夫被绕晕了。但是不怕，咱们继续往找！</p><ol><li>getDefault()获取到的静态常量gDefault</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton<span class="token operator">&lt;</span>IActivityManager<span class="token operator">></span> gDefault <span class="token operator">=</span>   <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token operator">&lt;</span>IActivityManager<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> IActivityManager <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       IBinder b <span class="token operator">=</span> ServiceManager<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span><span class="token string">"activity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//重点啊！IBinder实例就是在这里获得的。</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        IActivityManager am <span class="token operator">=</span> <span class="token function">asInterface</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用了上面的方法。</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">return</span> am<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>这是ActivityManagerNative的静态常量，它是一个单例。在其中终于获得了前面一直在用的IBinder实例。</p><pre class=" language-bash"><code class="language-bash">IBinder b <span class="token operator">=</span> ServiceManager.getService<span class="token punctuation">(</span><span class="token string">"activity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>试着在上图中找到对应位置。</p><p>这里是通过<strong>ServiceManager</strong>获取到<strong>IBinder</strong>实例的。如果你以前了解<strong>AIDL</strong>通讯流程的话。这可能比较好理解一点，这只是通过另一种方式获取<strong>IBinder</strong>实例罢了。获取<strong>IBinder</strong>的目的就是为了通过这个<strong>IBinder</strong>和<strong>ActivityManager</strong>进行通讯，进而<strong>ActivityManager</strong>会调度发送<strong>H.BIND_APPLICATION</strong>即初始化Application的Message消息。如果之前没接触过<strong>Binder</strong>机制的话，只需知道这个目的就行了。我后面会写一篇专门介绍Android中Binder机制的文章。</p><ol><li>再来看看attachApplication(mAppThread)方法。</li></ol><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attachApplication</span><span class="token punctuation">(</span>IApplicationThread app<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  mRemote<span class="token punctuation">.</span><span class="token function">transact</span><span class="token punctuation">(</span>ATTACH_APPLICATION_TRANSACTION<span class="token punctuation">,</span> data<span class="token punctuation">,</span> reply<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>这个方法我在上图中也体现出来了。</p><p>这个方法中上面这一句是关键。调用了IBinder实例的tansact()方法，并且把参数app(这个参数稍后就会提到)放到了data中，最终传递给ActivityManager。</p><p>现在，我们已经基本知道了IActivityManager是个什么东东了。其实最重要的就是它的一个实现类<strong>ActivityManagerProxy</strong>，它主要代理了内核中与<strong>ActivityManager</strong>通讯的<strong>Binder</strong>实例。下面再看看<strong>ApplicationThread mAppThread</strong>。</p><h4 id="ApplicationThread-mAppThread又是个啥？"><a href="#ApplicationThread-mAppThread又是个啥？" class="headerlink" title="ApplicationThread mAppThread又是个啥？"></a>ApplicationThread mAppThread又是个啥？</h4><ol><li>在ActivityThread的成员变量中，你能够发现：</li></ol><pre class=" language-dart"><code class="language-dart"><span class="token keyword">final</span> ApplicationThread mAppThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ApplicationThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>ApplicationThread是作为ActivityThread中的一个常量出现的。这表明系统不希望这个变量中途被修改，可见这个变量具有特定而十分重要的作用。</p><ol><li>我们看看他是啥。</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationThread</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationThreadNative</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>ApplicationThread是ActivityThread中的一个内部类，为什么没有单独出来写在别的地方呢？我觉得这也是对最小惊异原则的实践。因为ApplicationThread是专门真对这里使用的对象。</p><ol><li>它继承自ApplicationThreadNative，我们再看看它是个啥。</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationThreadNative</span> <span class="token keyword">extends</span> <span class="token class-name">Binder</span>     <span class="token keyword">implements</span> <span class="token class-name">IApplicationThread</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">//无参构造函数</span>    <span class="token keyword">public</span> <span class="token function">ApplicationThreadNative</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//这是Binder的</span>        <span class="token function">attachInterface</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>那么很明显，ApplicationThread最终也是一个Binder！同时，由于实现了IApplicationThread接口，所以它也是一个IApplicationThread。以上这系对应关系你都可以在上图中找到。</p><p>我们在ActivityThread中看到的ApplicationThread使用的构造函数是无参的，所以看上面无参构造函数都干了啥！</p><p>Binder的attachInterface(IInterface owner, String descriptor)方法没什么特别的，就是赋值了。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attachInterface</span><span class="token punctuation">(</span>IInterface owner<span class="token punctuation">,</span> String descriptor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    mOwner <span class="token operator">=</span> owner<span class="token punctuation">;</span>    mDescriptor <span class="token operator">=</span> descriptor<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>4.那么IApplicationThread又是啥？老铁，走着！我们继续挖。</p><pre class=" language-dart"><code class="language-dart">public interface <span class="token class-name">IApplicationThread</span> <span class="token keyword">extends</span> <span class="token class-name">IInterface</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    String descriptor <span class="token operator">=</span> <span class="token string">"android.app.IApplicationThread"</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//留意下这个参数</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>好吧，这在上图中没有，挖的有点什么了。但是学习嘛，咱就看看喽。</p><p>IApplicationThread是继承了IInterface的一个接口，我们需要关注一下里面的descriptor参数。后面会用它，它是一个标识，查询的时候很重要。</p><p>好，我们终于知道attach()方法中出现的两个对象是啥了。ApplicationThread作为IApplicationThread的一个实例，承担了最后发送Activity生命周期、及其它一些消息的任务。也就是说，前面绕了一大圈，最后还是回到这个地方来发送消息。我擦！</p><p>也许你会想，既然在ActivityThread中我们已经创建出了ApllicationThread的了，为什么还要绕这么弯路？，当然是为了让系统根据情况来控制这个过程喽，不然为什么要把ApplicationThread传到ActivityManager中呢？</p><h4 id="ActivityManagerService调度发送初始化消息"><a href="#ActivityManagerService调度发送初始化消息" class="headerlink" title="ActivityManagerService调度发送初始化消息"></a>ActivityManagerService调度发送初始化消息</h4><p>经过上面的辗转，ApplicationThread终于到了ActivityManagerService中了。请在上图中找到对应位置！</p><p>从上图中可以看到，ActivityManagerService中有一这样的方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">attachApplicationLocked</span><span class="token punctuation">(</span>IApplicationThread thread<span class="token punctuation">,</span> <span class="token keyword">int</span> pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    thread<span class="token punctuation">.</span><span class="token function">bindApplication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//注意啦！</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>ApplicationThread以IApplicationThread的身份到了ActivityManagerService中，经过一系列的操作，最终被调用了自己的bindApplication()方法，发出初始化Applicationd的消息。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">bindApplication</span><span class="token punctuation">(</span>String processName<span class="token punctuation">,</span>     ApplicationInfo appInfo<span class="token punctuation">,</span>    List<span class="token operator">&lt;</span>ProviderInfo<span class="token operator">></span> providers<span class="token punctuation">,</span>     ComponentName instrumentationName<span class="token punctuation">,</span>    ProfilerInfo profilerInfo<span class="token punctuation">,</span>     Bundle instrumentationArgs<span class="token punctuation">,</span>    IInstrumentationWatcher instrumentationWatcher<span class="token punctuation">,</span>    IUiAutomationConnection instrumentationUiConnection<span class="token punctuation">,</span>     <span class="token keyword">int</span> debugMode<span class="token punctuation">,</span>    <span class="token keyword">boolean</span> enableBinderTracking<span class="token punctuation">,</span>     <span class="token keyword">boolean</span> trackAllocation<span class="token punctuation">,</span>    <span class="token keyword">boolean</span> isRestrictedBackupMode<span class="token punctuation">,</span>     <span class="token keyword">boolean</span> persistent<span class="token punctuation">,</span>     Configuration config<span class="token punctuation">,</span>    CompatibilityInfo compatInfo<span class="token punctuation">,</span>     Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> IBinder<span class="token operator">></span> services<span class="token punctuation">,</span>     Bundle coreSettings<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">sendMessage</span><span class="token punctuation">(</span>H<span class="token punctuation">.</span>BIND_APPLICATION<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>吓屎老纸！这么多参数。这明明很违反参数尽量要少的原则嘛！所以说，有的时候，开发过程中还是很难避免一些参数堆积的情况的。也不能一概而论。</p><p>但是，这个地方，我们只要知道最后发了一条<strong>H.BIND_APPLICATION</strong>消息，接着程序开始了。</p><h4 id="收到初始化消息之后的世界"><a href="#收到初始化消息之后的世界" class="headerlink" title="收到初始化消息之后的世界"></a>收到初始化消息之后的世界</h4><p>上面我们已经找到初始化Applicaitond的消息是在哪发送的了。现在，需要看一看收到消息后都发生了些什么。</p><p>现在上图的H下面找到第一个消息：<strong>H.BIND_APPLICATION</strong>。一旦接收到这个消息就开始创建Application了。这个过程是在handleBindApplication()中完成的。看看这个方法。在上图中可以看到对应的方法。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> void <span class="token function">handleBindApplication</span><span class="token punctuation">(</span>AppBindData <span class="token keyword">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">..</span><span class="token punctuation">.</span>    mInstrumentation <span class="token operator">=</span> <span class="token punctuation">(</span>Instrumentation<span class="token punctuation">)</span>        cl<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token punctuation">.</span>instrumentationName<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过反射初始化一个Instrumentation仪表。后面会介绍。</span>    <span class="token operator">..</span><span class="token punctuation">.</span>    Application app <span class="token operator">=</span> <span class="token keyword">data</span><span class="token punctuation">.</span>info<span class="token punctuation">.</span><span class="token function">makeApplication</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token punctuation">.</span>restrictedBackupMode<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过LoadedApp命令创建Application实例</span>    mInitialApplication <span class="token operator">=</span> app<span class="token punctuation">;</span>    <span class="token operator">..</span><span class="token punctuation">.</span>    mInstrumentation<span class="token punctuation">.</span><span class="token function">callApplicationOnCreate</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//让仪器调用Application的onCreate()方法</span>    <span class="token operator">..</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>handleBindApplication()是一个很长的方法，但是我为各位看官精选出了上面这几句代码。对于本篇的主题来说，他们是至关重要的。上面短短的代码中出现了几个新对象。下面我会一一道来。</p><h4 id="Instrumentation仪表，什么鬼？"><a href="#Instrumentation仪表，什么鬼？" class="headerlink" title="Instrumentation仪表，什么鬼？"></a>Instrumentation仪表，什么鬼？</h4><p>1.这个叫Instrumentation仪表的东西十分诡异，姑且翻译为仪器吧。字面上看不出任何它是干什么的线索。但是，我们可以打开文档看看喽。</p><blockquote><p>Instrumentation会在应用程序的任何代码运行之前被实例化，它能够允许你监视应用程序和系统的所有交互。</p></blockquote><p>大概就这个意思啦。</p><p>2.但是，从上面的代码我们可以看出，Instrumentation确实是在Application初始化之前就被创建了。那么它是如何实现监视应用程序和系统交互的呢？</p><p>打开这个类你可以发现，最终Apllication的创建，Activity的创建，以及生命周期都会经过这个对象去执行。简单点说，就是把这些操作包装了一层。通过操作Instrumentation进而实现上述的功能。</p><p>3.那么这样做究竟有什么好处呢？仔细想想。Instrumentation作为抽象，当我们约定好需要实现的功能之后，我们只需要给Instrumentation仪表添加这些抽象功能，然后调用就好。剩下的，不管怎么实现这些功能，都交给Instrumentation仪器的实现对象就好。啊！这是多态的运用。啊！这是依赖抽象，不依赖具体的实践。啊！这是上层提出需求，底层定义接口，即依赖倒置原则的践行。呵！抽象不过如此。</p><p>从代码中可以看到，这里实例化Instrumentation的方法是反射！而反射的ClassName是来自于从ActivityManagerService中传过来的Binder的。套路太深！就是为了隐藏具体的实现对象。但是这样耦合性会很低。</p><p>4.好了，不瞎扯了。既然在说Instrumentation，那就看看最后调的callApplicationOnCreate()方法。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callApplicationOnCreate</span><span class="token punctuation">(</span>Application app<span class="token punctuation">)</span> <span class="token punctuation">{</span>    app<span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>你没看错，它啥也没干。只是调用了一下Application的onCreate()方法。这就是为什么它能够起到监控的作用。</p><p>在上图中你能够看到Instrumentation，以及它的交互过程。</p><h4 id="LoadedApk就是data-info哦！"><a href="#LoadedApk就是data-info哦！" class="headerlink" title="LoadedApk就是data.info哦！"></a>LoadedApk就是data.info哦！</h4><p>关于它是怎么来的本篇就不说了，以后可能会介绍下。本篇就看流程就好。所以直接进去看它的makeApplication()干了啥，就把Application给创建了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Application <span class="token function">makeApplication</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> forceDefaultAppClass<span class="token punctuation">,</span>    Instrumentation instrumentation<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    String appClass <span class="token operator">=</span> mApplicationInfo<span class="token punctuation">.</span>className<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Application的类名。明显是要用反射了。</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    ContextImpl appContext <span class="token operator">=</span> ContextImpl<span class="token punctuation">.</span><span class="token function">createAppContext</span><span class="token punctuation">(</span>mActivityThread        <span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//留意下Context</span>    app <span class="token operator">=</span> mActivityThread<span class="token punctuation">.</span>mInstrumentation        <span class="token punctuation">.</span><span class="token function">newApplication</span><span class="token punctuation">(</span> cl<span class="token punctuation">,</span> appClass<span class="token punctuation">,</span> appContext<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过仪表创建Application</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>在这个方法中，我们需要知道的就是，在取得Application的实际类名之后，最终的创建工作还是交由Instrumentation去完成，就像前面所说的一样。</p><p>值得留意的是，就像上图所标注的一样，当需要第二次获取Application时，同样只需要调用这个方法就好。“真是方便！”</p><h4 id="现在把目光移回Instrumentation"><a href="#现在把目光移回Instrumentation" class="headerlink" title="现在把目光移回Instrumentation"></a>现在把目光移回Instrumentation</h4><p>看看newApplication()中是如何完成Application的创建的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">public</span> Application <span class="token function">newApplication</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz    <span class="token punctuation">,</span> Context context<span class="token punctuation">)</span> <span class="token keyword">throws</span> InstantiationException    <span class="token punctuation">,</span> IllegalAccessException    <span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>        Application app <span class="token operator">=</span> <span class="token punctuation">(</span>Application<span class="token punctuation">)</span>clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//反射创建，简单粗暴</span>        app<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//关注下这里，Application被创建后第一个调用的方法。</span>        <span class="token comment" spellcheck="true">//目的是为了绑定Context。</span>        <span class="token keyword">return</span> app<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>我的天，绕了这么多，这Application可算是创建出来了。快给自己一个小红花吧！</p><h4 id="LaunchActivity"><a href="#LaunchActivity" class="headerlink" title="LaunchActivity"></a>LaunchActivity</h4><p>当Application初始化完成后，系统会更具Manifests中的配置的启动Activity发送一个Intent去启动相应的Activity。这个过程本篇先不提，下次再说。主要看流程！</p><p>直接的，H就收到了一条LAUNCH_ACTIVITY的消息。然后开始初始化Activity之旅。收到消息后，真正处理是在ActivityThread中的handleLaunchActivity()中进行的。是不是迫不及待的想要知道发生了啥？快在上图中找到对应的步骤吧！</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handleLaunchActivity</span><span class="token punctuation">(</span>ActivityClientRecord r    <span class="token punctuation">,</span> Intent customIntent    <span class="token punctuation">,</span> String reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    Activity a <span class="token operator">=</span> <span class="token function">performLaunchActivity</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> customIntent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//妈蛋！又封装到另一个方法中创建了。</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">handleResumeActivity</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>token        <span class="token punctuation">,</span> <span class="token keyword">false</span>        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>isForward        <span class="token punctuation">,</span><span class="token operator">!</span>r<span class="token punctuation">.</span>activity<span class="token punctuation">.</span>mFinished <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>r<span class="token punctuation">.</span>startsNotResumed        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>lastProcessedSeq<span class="token punctuation">,</span> reason<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Activity创建成功就往onResume()走了！</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从上面的代码中可以看出…好吧，什么都看不出来！</p><p>再走一个方法。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">private</span> Activity <span class="token function">performLaunchActivity</span><span class="token punctuation">(</span>ActivityClientRecord r    <span class="token punctuation">,</span> Intent customIntent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    activity <span class="token operator">=</span> mInstrumentation<span class="token punctuation">.</span><span class="token function">newActivity</span><span class="token punctuation">(</span>         cl<span class="token punctuation">,</span> component<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过仪表来创建Activity</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     Application app <span class="token operator">=</span> r<span class="token punctuation">.</span>packageInfo<span class="token punctuation">.</span><span class="token function">makeApplication</span><span class="token punctuation">(</span><span class="token boolean">false</span>     <span class="token punctuation">,</span> mInstrumentation<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//前面说过，是在获取Application</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    activity<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>appContext        <span class="token punctuation">,</span> <span class="token keyword">this</span>        <span class="token punctuation">,</span> <span class="token function">getInstrumentation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>token        <span class="token punctuation">,</span><span class="token punctuation">.</span>ident        <span class="token punctuation">,</span> app        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>intent        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>activityInfo        <span class="token punctuation">,</span> title        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>parent        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>embeddedID        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>lastNonConfigurationInstances        <span class="token punctuation">,</span> config        <span class="token punctuation">,</span>r<span class="token punctuation">.</span>referrer        <span class="token punctuation">,</span> r<span class="token punctuation">.</span>voiceInteractor        <span class="token punctuation">,</span> window<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//方法怪出现！</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">isPersistable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mInstrumentation<span class="token punctuation">.</span><span class="token function">callActivityOnCreate</span><span class="token punctuation">(</span>          activity<span class="token punctuation">,</span> r<span class="token punctuation">.</span>state<span class="token punctuation">,</span> r<span class="token punctuation">.</span>persistentState<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        mInstrumentation<span class="token punctuation">.</span><span class="token function">callActivityOnCreate</span><span class="token punctuation">(</span>activity<span class="token punctuation">,</span> r<span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//根据是否可持久化选择onCreate()方法。</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>这个方法内容较多，我们一个个看。</p><pre class=" language-undefined"><code class="language-undefined">activity = mInstrumentation.newActivity(         cl, component.getClassName(), r.intent);</code></pre><p>正如前面所说，Activity、Application的创建及生命周期都被承包给Instrumentation仪表了。所以由它来负责。看看Instrumentation干了啥。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Activity <span class="token function">newActivity</span><span class="token punctuation">(</span>ClassLoader cl<span class="token punctuation">,</span> String className<span class="token punctuation">,</span>            Intent intent<span class="token punctuation">)</span>            <span class="token keyword">throws</span> InstantiationException            <span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">,</span>            ClassNotFoundException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>Activity<span class="token punctuation">)</span>cl<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//真的没干啥。反射实例化Activity而已</span>    <span class="token punctuation">}</span></code></pre><p>就是反射出一个Activity而已。</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">(</span>r.isPersistable<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>        mInstrumentation.callActivityOnCreate<span class="token punctuation">(</span>          activity, r.state, r.persistentState<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        mInstrumentation.callActivityOnCreate<span class="token punctuation">(</span>activity, r.state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>根据是否可持久化选择Activity的onCreate()方法。同样是通过Instrumentation仪表来执行onCreate()的。它两分别对应的onCreate()方法为：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">onCreate</span><span class="token punctuation">(</span>icicle<span class="token punctuation">,</span> persistentState<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//可获得持久化数据</span></code></pre><p>和</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">onCreate</span><span class="token punctuation">(</span>icicle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//平时重写的最多的。</span></code></pre><p>中间两个方法留意一下就好，就不在解释的，感兴趣的点源码看看。</p><p>到此，Activity就跑起来了！怎么样？是不是并不复杂。</p><h3 id="surfaceFlinger创建surface"><a href="#surfaceFlinger创建surface" class="headerlink" title="surfaceFlinger创建surface"></a>surfaceFlinger创建surface</h3><p>对于window的创建，我们就从handleLaunchActivity开始，开始看源码吧：</p><pre class=" language-tsx"><code class="language-tsx">//ActivityThreadprivate void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {    ``````    //获取WindowManagerService的Binder引用(proxy端)。    WindowManagerGlobal.initialize();    //创建activity,调用attach方法，然后调用Activity的onCreate,onStart,onResotreInstanceState方法    Activity a = performLaunchActivity(r, customIntent);    if (a != null) {        ``````        //会调用Activity的onResume方法.        handleResumeActivity(r.token, false, r.isForward,                !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);        ``````    }}</code></pre><p>主要看 Activity a = performLaunchActivity(r, customIntent);方法，关注Activity的attach方法：</p><pre class=" language-jsx"><code class="language-jsx">inal <span class="token keyword">void</span> <span class="token function">attach</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> ActivityThread aThread<span class="token punctuation">,</span>        Instrumentation instr<span class="token punctuation">,</span> IBinder token<span class="token punctuation">,</span> int ident<span class="token punctuation">,</span>        Application application<span class="token punctuation">,</span> Intent intent<span class="token punctuation">,</span> ActivityInfo info<span class="token punctuation">,</span>        CharSequence title<span class="token punctuation">,</span> Activity parent<span class="token punctuation">,</span> String id<span class="token punctuation">,</span>        NonConfigurationInstances lastNonConfigurationInstances<span class="token punctuation">,</span>        Configuration config<span class="token punctuation">,</span> String referrer<span class="token punctuation">,</span> IVoiceInteractor voiceInteractor<span class="token punctuation">,</span>        Window window<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//绑定上下文</span>        <span class="token function">attachBaseContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建Window, PhoneWindow是Window的唯一具体实现类</span>        mWindow <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhoneWindow</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> window<span class="token punctuation">)</span><span class="token punctuation">;</span>        mWindow<span class="token punctuation">.</span><span class="token function">setWindowControllerCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mWindow<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token template-string"><span class="token string">``</span></span><span class="token template-string"><span class="token string">``</span></span><span class="token template-string"><span class="token string">``</span></span>        <span class="token comment" spellcheck="true">//设置WindowManager</span>        mWindow<span class="token punctuation">.</span><span class="token function">setWindowManager</span><span class="token punctuation">(</span>                <span class="token punctuation">(</span>WindowManager<span class="token punctuation">)</span>context<span class="token punctuation">.</span><span class="token function">getSystemService</span><span class="token punctuation">(</span>Context<span class="token punctuation">.</span>WINDOW_SERVICE<span class="token punctuation">)</span><span class="token punctuation">,</span>                mToken<span class="token punctuation">,</span> mComponent<span class="token punctuation">.</span><span class="token function">flattenToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span>info<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> ActivityInfo<span class="token punctuation">.</span>FLAG_HARDWARE_ACCELERATED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mParent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            mWindow<span class="token punctuation">.</span><span class="token function">setContainer</span><span class="token punctuation">(</span>mParent<span class="token punctuation">.</span><span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//创建完后通过getWindowManager就可以得到WindowManager实例</span>        mWindowManager <span class="token operator">=</span> mWindow<span class="token punctuation">.</span><span class="token function">getWindowManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//其实它是WindowManagerImpl</span>    <span class="token punctuation">}</span></code></pre><p>这里创建了一个PhoneWindow对象，并且实现了Window的Callback接口，这样activity就和window关联在了一起，并且通过callback能够接受key和touch事件。</p><p>此外，初始化且设置windowManager。每个 Activity 会有一个 WindowManager 对象，这个 mWindowManager 就是和 WindowManagerService 进行通信，也是 WindowManagerService 识别 View 具体属于那个 Activity 的关键，创建时传入 IBinder 类型的 mToken。</p><pre class=" language-css"><code class="language-css">mWindow<span class="token number">.</span><span class="token function">setWindowManager</span><span class="token punctuation">(</span><span class="token number">...</span>, mToken, <span class="token number">...</span>, <span class="token number">...</span><span class="token punctuation">)</span></code></pre><p>我们从window的setWindowManager方法出发，很容易找到WindowManager这个接口的具体的实现是WindowManagerImpl。</p><h4 id="window添加view过程"><a href="#window添加view过程" class="headerlink" title="window添加view过程"></a>window添加view过程</h4><p>我们前面知道PhoneWindow对View来说更多是扮演容器的角色，而真正完成把一个 View，作为窗口添加到 WMS 的过程是由 WindowManager 来完成的。而且从上面创建过程我们知道了WindowManager 的具体实现是 WindowManagerImpl。</p><p>那么我们继续来跟代码：</p><p>从上面handleLaunchActivity的代码中performLaunchActivity后面，有个handleResumeActivity，从名字也能看出，跟activity onResume相关。进去看看：</p><pre class=" language-dart"><code class="language-dart"><span class="token comment" spellcheck="true">//ActivityThread</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">handleResumeActivity</span><span class="token punctuation">(</span>IBinder token<span class="token punctuation">,</span>            boolean clearHide<span class="token punctuation">,</span> boolean isForward<span class="token punctuation">,</span> boolean reallyResume<span class="token punctuation">,</span> int seq<span class="token punctuation">,</span> String reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//把activity数据记录更新到ActivityClientRecord</span>        ActivityClientRecord r <span class="token operator">=</span> mActivities<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>        r <span class="token operator">=</span> <span class="token function">performResumeActivity</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> clearHide<span class="token punctuation">,</span> reason<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>window <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>a<span class="token punctuation">.</span>mFinished <span class="token operator">&amp;&amp;</span> willBeVisible<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r<span class="token punctuation">.</span>window <span class="token operator">=</span> r<span class="token punctuation">.</span>activity<span class="token punctuation">.</span><span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                View decor <span class="token operator">=</span> r<span class="token punctuation">.</span>window<span class="token punctuation">.</span><span class="token function">getDecorView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                decor<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>View<span class="token punctuation">.</span>INVISIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不可见</span>                ViewManager wm <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">getWindowManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                WindowManager<span class="token punctuation">.</span>LayoutParams l <span class="token operator">=</span> r<span class="token punctuation">.</span>window<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                a<span class="token punctuation">.</span>mDecor <span class="token operator">=</span> decor<span class="token punctuation">;</span>                l<span class="token punctuation">.</span>type <span class="token operator">=</span> WindowManager<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>TYPE_BASE_APPLICATION<span class="token punctuation">;</span>             ``````                <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>mVisibleFromClient <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>a<span class="token punctuation">.</span>mWindowAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    a<span class="token punctuation">.</span>mWindowAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    wm<span class="token punctuation">.</span><span class="token function">addView</span><span class="token punctuation">(</span>decor<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把decor添加到窗口上（划重点）</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//屏幕参数发生了改变</span>                <span class="token function">performConfigurationChanged</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>activity<span class="token punctuation">,</span> r<span class="token punctuation">.</span>tmpConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>                WindowManager<span class="token punctuation">.</span>LayoutParams l <span class="token operator">=</span> r<span class="token punctuation">.</span>window<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>activity<span class="token punctuation">.</span>mVisibleFromClient<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        ViewManager wm <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">getWindowManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        View decor <span class="token operator">=</span> r<span class="token punctuation">.</span>window<span class="token punctuation">.</span><span class="token function">getDecorView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        wm<span class="token punctuation">.</span><span class="token function">updateViewLayout</span><span class="token punctuation">(</span>decor<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//更新窗口状态</span>                    <span class="token punctuation">}</span>                ``````                <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>activity<span class="token punctuation">.</span>mVisibleFromClient<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//已经成功添加到窗口上了（绘制和事件接收），设置为可见</span>                    r<span class="token punctuation">.</span>activity<span class="token punctuation">.</span><span class="token function">makeVisible</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//通知ActivityManagerService，Activity完成Resumed</span>             ActivityManagerNative<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">activityResumed</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>我们注意到这么几行代码：</p><pre class=" language-bash"><code class="language-bash">            <span class="token keyword">if</span> <span class="token punctuation">(</span>a.mVisibleFromClient <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>a.mWindowAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    a.mWindowAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    wm.addView<span class="token punctuation">(</span>decor, l<span class="token punctuation">)</span><span class="token punctuation">;</span>/                <span class="token punctuation">}</span></code></pre><p>wm是activity getWindowManager()获取的，那不就是WindowManagerImpl的addView方法吗，追！</p><pre class=" language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//WindowManagerImpl</span>@Override<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addView</span><span class="token punctuation">(</span>@NonNull View view<span class="token punctuation">,</span> @NonNull ViewGroup<span class="token punctuation">.</span>LayoutParams <span class="token keyword">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">applyDefaultToken</span><span class="token punctuation">(</span><span class="token keyword">params</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mGlobal<span class="token punctuation">.</span><span class="token function">addView</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> <span class="token keyword">params</span><span class="token punctuation">,</span> mContext<span class="token punctuation">.</span><span class="token function">getDisplay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mParentWindow<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们看到了又代理了一层：mGlobal， 它是谁？ 如果有印象的会记得讲window类型的时候带了一嘴的WindowManagerGlobal ，那这个WindowManagerImpl原来也是一个吃空饷的家伙！对于Window(或者可以说是View)的操作都是交由WindowManagerGlobal来处理，WindowManagerGlobal以工厂的形式向外提供自己的实例。这种工作模式是桥接模式，将所有的操作全部委托给WindowManagerGlobal来实现。</p><p>在WindowManagerImpl的全局变量中通过单例模式初始化了WindowManagerGlobal，也就是说一个进程就只有一个WindowManagerGlobal对象。那看看它：</p><pre class=" language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//WindowManagerGlobal</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addView</span><span class="token punctuation">(</span>View view<span class="token punctuation">,</span> ViewGroup<span class="token punctuation">.</span>LayoutParams <span class="token keyword">params</span><span class="token punctuation">,</span>            Display display<span class="token punctuation">,</span> Window parentWindow<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>view <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"view must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>display <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"display must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">params</span> instanceof <span class="token class-name">WindowManager<span class="token punctuation">.</span>LayoutParams</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Params must be WindowManager.LayoutParams"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        final WindowManager<span class="token punctuation">.</span>LayoutParams wparams <span class="token operator">=</span> <span class="token punctuation">(</span>WindowManager<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">)</span> <span class="token keyword">params</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parentWindow <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//调整布局参数，并设置token</span>            parentWindow<span class="token punctuation">.</span><span class="token function">adjustLayoutParamsForSubWindow</span><span class="token punctuation">(</span>wparams<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ViewRootImpl root<span class="token punctuation">;</span>        View panelParentView <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token function">synchronized</span> <span class="token punctuation">(</span>mLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">findViewLocked</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>mDyingViews<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//如果待删除的view中有当前view，删除它</span>                    <span class="token comment" spellcheck="true">// Don't wait for MSG_DIE to make it's way through root's queue.</span>                    mRoots<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doDie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// The previous removeView() had not completed executing. Now it has.</span>               <span class="token comment" spellcheck="true">//之前移除View并没有完成删除操作，现在正式删除该view</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//如果这是一个子窗口个(popupWindow)，找到它的父窗口。</span>            <span class="token comment" spellcheck="true">//最本质的作用是使用父窗口的token(viewRootImpl的W类，也就是IWindow)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>wparams<span class="token punctuation">.</span>type <span class="token operator">>=</span> WindowManager<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>FIRST_SUB_WINDOW <span class="token operator">&amp;&amp;</span>                    wparams<span class="token punctuation">.</span>type <span class="token operator">&lt;=</span> WindowManager<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>LAST_SUB_WINDOW<span class="token punctuation">)</span> <span class="token punctuation">{</span>                final <span class="token keyword">int</span> count <span class="token operator">=</span> mViews<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>mRoots<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>mWindow<span class="token punctuation">.</span><span class="token function">asBinder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> wparams<span class="token punctuation">.</span>token<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//在源码中token一般代表的是Binder对象，作用于IPC进程间数据通讯。并且它也包含着此次通讯所需要的信息，</span>                    <span class="token comment" spellcheck="true">//在ViewRootImpl里，token用来表示mWindow(W类，即IWindow)，并且在WmS中只有符合要求的token才能让</span>                    <span class="token comment" spellcheck="true">//Window正常显示.</span>                        panelParentView <span class="token operator">=</span> mViews<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//创建ViewRootImpl，并且将view与之绑定</span>            root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ViewRootImpl</span><span class="token punctuation">(</span>view<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> display<span class="token punctuation">)</span><span class="token punctuation">;</span>            view<span class="token punctuation">.</span><span class="token function">setLayoutParams</span><span class="token punctuation">(</span>wparams<span class="token punctuation">)</span><span class="token punctuation">;</span>            mViews<span class="token punctuation">.</span><span class="token keyword">add</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将当前view添加到mViews集合中，mViews存储所有Window对应的View</span>            mRoots<span class="token punctuation">.</span><span class="token keyword">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将当前ViewRootImpl添加到mRoots集合中，mRoots存储所有Window对应的ViewRootImpl</span>            mParams<span class="token punctuation">.</span><span class="token keyword">add</span><span class="token punctuation">(</span>wparams<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将当前window的params添加到mParams集合中，存储所有Window对应的布局参数</span>        <span class="token punctuation">}</span>          ``````            <span class="token comment" spellcheck="true">//通过ViewRootImpl的setView方法，完成view的绘制流程，并添加到window上。</span>            root<span class="token punctuation">.</span><span class="token function">setView</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> wparams<span class="token punctuation">,</span> panelParentView<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>最最重要的是：root.setView(view, wparams, panelParentView); 一方面触发绘制流程，一方面把view添加到window上。</p><p>讲setView之前先普及下WindowManager与WindowManagerService binder IPC的两个接口：</p><p>IWindowSession: 应用程序向WMS请求功能<br>实现类：Session<br>IWindow：WMS向客户端反馈它想确认的信息<br>实现类：W</p><p><img src="2828107-ded3c74e738dbb7e.webp" alt="img"></p><p>下面看看ViewRootImpl的setView：</p><pre class=" language-tsx"><code class="language-tsx">//ViewRootImpl  public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {                int res;                 //在 Window add之前调用，确保 UI 布局绘制完成 --> measure , layout , draw                requestLayout();//View的绘制流程                if ((mWindowAttributes.inputFeatures                        & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {                    //创建InputChannel                    mInputChannel = new InputChannel();                }                try {                    //通过WindowSession进行IPC调用，将View添加到Window上                    //mWindow即W类，用来接收WmS信息                    //同时通过InputChannel接收触摸事件回调                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,                            getHostVisibility(), mDisplay.getDisplayId(),                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,                            mAttachInfo.mOutsets, mInputChannel);                }                ``````                    //处理触摸事件回调                    mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,                            Looper.myLooper());                ``````    }</code></pre><p>在ViewRootImpl的setView()方法里，</p><p>1.执行requestLayout()方法完成view的绘制流程（之后会讲）<br>2.通过WindowSession将View和InputChannel添加到WmS中，从而将View添加到Window上并且接收触摸事件。这是一次IPC 过程。<br>那么接下来看看这个IPC过程</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//ViewRootImpl的setView方法中：</span>mWindowSession<span class="token punctuation">.</span><span class="token function">addToDisplay</span><span class="token punctuation">(</span>mWindow<span class="token punctuation">,</span> mSeq<span class="token punctuation">,</span> mWindowAttributes<span class="token punctuation">,</span>        <span class="token function">getHostVisibility</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mDisplay<span class="token punctuation">.</span><span class="token function">getDisplayId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        mAttachInfo<span class="token punctuation">.</span>mContentInsets<span class="token punctuation">,</span> mAttachInfo<span class="token punctuation">.</span>mStableInsets<span class="token punctuation">,</span>        mAttachInfo<span class="token punctuation">.</span>mOutsets<span class="token punctuation">,</span> mInputChannel<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>mWindowSession：类型是interface IWindowSession</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//WindowManagerGlobal</span><span class="token keyword">public</span> <span class="token keyword">static</span> IWindowSession <span class="token function">getWindowSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>WindowManagerGlobal<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sWindowSession <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                InputMethodManager imm <span class="token operator">=</span> InputMethodManager<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                IWindowManager windowManager <span class="token operator">=</span> <span class="token function">getWindowManagerService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sWindowSession <span class="token operator">=</span> windowManager<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span>                        <span class="token keyword">new</span> <span class="token class-name">IWindowSessionCallback<span class="token punctuation">.</span>Stub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token annotation punctuation">@Override</span>                            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onAnimatorScaleChanged</span><span class="token punctuation">(</span><span class="token keyword">float</span> scale<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                ValueAnimator<span class="token punctuation">.</span><span class="token function">setDurationScale</span><span class="token punctuation">(</span>scale<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span><span class="token punctuation">,</span>                        imm<span class="token punctuation">.</span><span class="token function">getClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> imm<span class="token punctuation">.</span><span class="token function">getInputContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RemoteException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> e<span class="token punctuation">.</span><span class="token function">rethrowFromSystemServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sWindowSession<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们看到了getWindowManagerService(); 获取了WMS , 那么再看下windowManager.openSession返回值就是sWindowSession</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> IWindowSession <span class="token function">openSession</span><span class="token punctuation">(</span>IWindowSessionCallback callback<span class="token punctuation">,</span> IInputMethodClient client<span class="token punctuation">,</span>        IInputContext inputContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>client <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"null client"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inputContext <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"null inputContext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Session session <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Session</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> client<span class="token punctuation">,</span> inputContext<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> session<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>IWindowSession的真正实现类是Session，他是一个Binder. 那么Session的addToDisplay:</p><pre class=" language-dart"><code class="language-dart"><span class="token metadata symbol">@Override</span>public int <span class="token function">addToDisplay</span><span class="token punctuation">(</span>IWindow window<span class="token punctuation">,</span> int seq<span class="token punctuation">,</span> WindowManager<span class="token punctuation">.</span>LayoutParams attrs<span class="token punctuation">,</span>        int viewVisibility<span class="token punctuation">,</span> int displayId<span class="token punctuation">,</span> Rect outContentInsets<span class="token punctuation">,</span> Rect outStableInsets<span class="token punctuation">,</span>        Rect outOutsets<span class="token punctuation">,</span> InputChannel outInputChannel<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> mService<span class="token punctuation">.</span><span class="token function">addWindow</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> window<span class="token punctuation">,</span> seq<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> viewVisibility<span class="token punctuation">,</span> displayId<span class="token punctuation">,</span>            outContentInsets<span class="token punctuation">,</span> outStableInsets<span class="token punctuation">,</span> outOutsets<span class="token punctuation">,</span> outInputChannel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从这知道了，最终是WMS执行addWindow操作.</p><p>下面一张图总结下：</p><p><img src="2828107-e8bf87c5a8e3e509.webp" alt="img"></p><p>图出处：<a href="https://blog.csdn.net/freekiteyu/article/details/79408969" target="_blank" rel="noopener">https://blog.csdn.net/freekiteyu/article/details/79408969</a></p><p>WMS执行addWindow部分代码有点多，本篇就不铺开说了，不然篇幅就太长了，之后再说，看下如下的流程图：</p><p><img src="2828107-b61f6c575c591b99.webp" alt="img"></p><p>图出处：<a href="https://www.jianshu.com/p/effaff9ab9f2" target="_blank" rel="noopener">https://www.jianshu.com/p/effaff9ab9f2</a></p><p>总结起来：WMS中 addWindow流程就几点：<br>1.通过type和 token对window进行分类和验证，确保其有效性。<br>2.构造WindowState与Window一一对应。<br>3.通过token对window进行分组。<br>4.对window分配层级。</p><p>那么到这里，window添加view的过程就结束了。</p><p><strong>总结</strong>:<br>下面用一张图来总结下Activity、PhoneWindow、 DecorView 、WindowManagerGlobal 、ViewRootImpl 、Wms 以及WindowState之间的关系：</p><p><img src="2828107-490351404c329a15.webp" alt="img"></p><p>图出处：<a href="https://blog.csdn.net/qian520ao/article/details/78555397?locationNum=7&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/qian520ao/article/details/78555397?locationNum=7&amp;fps=1</a></p><p>Activity在attach的时候，创建了一个PhoneWindow对象，并且实现了Window的Callback接口，这样activity就和window绑定在了一起，通过setContentView，创建DecorView，并解析好视图树加载到DecorView的contentView部分，WindowManagerGlobal一个进程只有唯一一个，对当前进程内所有的视图进行统一管理，其中包括ViewRootImpl，它主要做两件事情，先触发view绘制流程，再通过IPC 把view添加到window上。</p><p>另外这是添加视图的方法执行时序图：</p><p><img src="2828107-3f93849f3f3f70c2.webp" alt="img"></p><p>图出处：<a href="https://blog.csdn.net/qian520ao/article/details/78555397?locationNum=7&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/qian520ao/article/details/78555397?locationNum=7&amp;fps=1</a></p><p>至于Window的删除和更新过程，举一反三，也是使用WindowManagerGlobal对ViewRootImpl的操作，最终也是通过Session的IPC跨进程通信通知到WmS。整个过程的本质都是同出一辙的。下一节接着讲DecorView布局的加载流程。</p><p>参考：<br><a href="https://blog.csdn.net/qian520ao/article/details/78555397?locationNum=7&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/qian520ao/article/details/78555397?locationNum=7&amp;fps=1</a><br><a href="https://www.jianshu.com/p/effaff9ab9f2" target="_blank" rel="noopener">https://www.jianshu.com/p/effaff9ab9f2</a><br><a href="https://blog.csdn.net/freekiteyu/article/details/79408969" target="_blank" rel="noopener">https://blog.csdn.net/freekiteyu/article/details/79408969</a></p><h4 id="native层创建surface"><a href="#native层创建surface" class="headerlink" title="native层创建surface"></a>native层创建surface</h4><p>前面讲到<strong>ViewRootImpl.setView()</strong>方法会向<strong>WindowManagerService</strong>请求添加一个<strong>Window</strong>,<strong>mWindowSession.addToDisplay()</strong>跨进程最终调用到了<strong>WindowManagerService.addWindow()</strong>:</p><blockquote><p>WindowManagerService.java</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">addWindow</span><span class="token punctuation">(</span>Session session<span class="token punctuation">,</span> IWindow client<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">//WindowState用来描述一个Window</span>    <span class="token keyword">final</span> WindowState win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WindowState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> session<span class="token punctuation">,</span> client<span class="token punctuation">,</span> token<span class="token punctuation">,</span> parentWindow<span class="token punctuation">,</span>                appOp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> seq<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> viewVisibility<span class="token punctuation">,</span> session<span class="token punctuation">.</span>mUid<span class="token punctuation">,</span>                session<span class="token punctuation">.</span>mCanAddInternalSystemWindow<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    win<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//会创建一个SurfaceSession</span>    mWindowMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>client<span class="token punctuation">.</span><span class="token function">asBinder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> win<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//mWindowMap是WindowManagerService用来保存当前所有Window新的的集合</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    win<span class="token punctuation">.</span>mToken<span class="token punctuation">.</span><span class="token function">addWindow</span><span class="token punctuation">(</span>win<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//一个token下会有多个win state。 其实token与PhoneWindow是一一对应的。</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p><code>WindowState</code>是<code>WindowManagerService</code>用来描述应用程序的一个<code>Window</code>的对象。上面注释我标注了<code>win.attach()</code>,这个方法可以说是<code>Window</code>与<code>SurfaceFlinger</code>链接的起点,它最终会调用到<code>Session.windowAddedLocked()</code>:</p><blockquote><p>Session.java</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">windowAddedLocked</span><span class="token punctuation">(</span>String packageName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mSurfaceSession <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        mSurfaceSession <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SurfaceSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//SurfaceSession类的构造方法</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SurfaceSession</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> mNativeClient<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// SurfaceComposerClient*</span>    <span class="token keyword">public</span> <span class="token function">SurfaceSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mNativeClient <span class="token operator">=</span> <span class="token function">nativeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><p>这里调用了native方法<code>nativeCreate()</code>，这个方法其实是返回了一个<code>SurfaceComposerClient指针</code>。那这个对象是怎么创建的呢？</p><h5 id="SurfaceComposerClient的创建"><a href="#SurfaceComposerClient的创建" class="headerlink" title="SurfaceComposerClient的创建"></a>SurfaceComposerClient的创建</h5><blockquote><p>android_view_SurfaceSession.cpp</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">static</span> jlong <span class="token function">nativeCreate</span><span class="token punctuation">(</span>JNIEnv<span class="token operator">*</span> env<span class="token punctuation">,</span> jclass <span class="token class-name">clazz</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    SurfaceComposerClient<span class="token operator">*</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">SurfaceComposerClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//构造函数其实并没有做什么</span>    client<span class="token operator">-</span><span class="token operator">></span><span class="token function">incStrong</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>nativeCreate<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>jlong<span class="token operator">></span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>即构造了一个<code>SurfaceComposerClient</code>对象。并返回它的指针。<strong>这个对象一个应用程序就有一个</strong>，它是应用程序与<code>SurfaceFlinger</code>沟通的桥梁，为什么这么说呢？在<code>SurfaceComposerClient指针</code>第一次使用时会调用下面这个方法:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//这个方法在第一次使用SurfaceComposerClient的指针的时候会调用</span><span class="token keyword">void</span> SurfaceComposerClient<span class="token operator">::</span><span class="token function">onFirstRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    sp<span class="token operator">&lt;</span>ISurfaceComposerClient<span class="token operator">></span> conn<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//sf 就是SurfaceFlinger</span>    conn <span class="token operator">=</span> <span class="token punctuation">(</span>rootProducer <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">?</span> sf<span class="token operator">-</span><span class="token operator">></span><span class="token function">createScopedConnection</span><span class="token punctuation">(</span>rootProducer<span class="token punctuation">)</span> <span class="token operator">:</span>            sf<span class="token operator">-</span><span class="token operator">></span><span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>即通过<code>SurfaceFlinger(它本身具有跨进程通信的能力)</code>创建了一个<code>ISurfaceComposerClient</code>对象:</p><blockquote><p>SurfaceFlinger.cpp</p></blockquote><pre class=" language-cpp"><code class="language-cpp">sp<span class="token operator">&lt;</span>ISurfaceComposerClient<span class="token operator">></span> SurfaceFlinger<span class="token operator">::</span><span class="token function">createConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">initClient</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Client</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//initClient这个方法其实并没有做什么，</span><span class="token punctuation">}</span></code></pre><p>即构造了一个<code>Client</code>对象，<code>Client</code>实现了<code>ISurfaceComposerClient</code>接口。是一个可以跨进程通信的aidl对象。即<code>SurfaceComposerClient</code>可以通过它来和<code>SurfaceFlinger</code>通信。除此之外它还可以创建<code>Surface</code>，并且维护一个应用程序的所有<code>Layer(下文会分析到它是什么)</code>。<strong>它是一个十分重要的对象</strong>，我们先来看一下它的组成,它所涉及的其他东西在下文分析中都会讲到:</p><blockquote><p>Client.h</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token operator">:</span> <span class="token keyword">public</span> BnSurfaceComposerClient<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">attachLayer</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>IBinder<span class="token operator">></span><span class="token operator">&amp;</span> handle<span class="token punctuation">,</span> <span class="token keyword">const</span> sp<span class="token operator">&lt;</span>Layer<span class="token operator">></span><span class="token operator">&amp;</span> layer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">detachLayer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Layer<span class="token operator">*</span> layer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// ISurfaceComposerClient interface。   gbp很重要，它维护这一个应用程序的渲染 Buffer队列</span>    <span class="token keyword">virtual</span> status_t <span class="token function">createSurface</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>sp<span class="token operator">&lt;</span>IBinder<span class="token operator">></span><span class="token operator">*</span> handle<span class="token punctuation">,</span> sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">></span><span class="token operator">*</span> gbp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> status_t <span class="token function">destroySurface</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>IBinder<span class="token operator">></span><span class="token operator">&amp;</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//跨进程通信方法</span>    <span class="token keyword">virtual</span> status_t <span class="token function">onTransact</span><span class="token punctuation">(</span>uint32_t code<span class="token punctuation">,</span> <span class="token keyword">const</span> Parcel<span class="token operator">&amp;</span> data<span class="token punctuation">,</span> Parcel<span class="token operator">*</span> reply<span class="token punctuation">,</span> uint32_t flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// constant</span>    sp<span class="token operator">&lt;</span>SurfaceFlinger<span class="token operator">></span> mFlinger<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// protected by mLock</span>    DefaultKeyedVector<span class="token operator">&lt;</span> wp<span class="token operator">&lt;</span>IBinder<span class="token operator">></span><span class="token punctuation">,</span> wp<span class="token operator">&lt;</span>Layer<span class="token operator">></span> <span class="token operator">></span> mLayers<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 一个应用程序的所有Layer</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>经过上面这一顿源码分析，我们大概知道了<code>ViewRootImpl.setView()</code>所引发的主要操作:</p><ol><li><code>WindowManagerService</code>创建了一个<code>WindowState</code>。用来表示客户端的一个<code>Window</code> </li><li><code>WindowManagerService</code>创建了一个<code>SurfaceSession</code>,<code>SurfaceSession</code>会与<code>SurfaceFlinger</code>构建链接，创建了一个<code>SurfaceComposerClient</code>对象，一个应用程序只具有一个这个对象。</li><li><code>SurfaceComposerClient</code>创建了一个<code>Client</code>, 这个对象十分重要，它维护这应用程序的渲染核心数据，并负责与<code>SurfaceFlinger</code>通信。</li></ol><p>如下图:</p><p><img src="https:////upload-images.jianshu.io/upload_images/2934684-93945b637d846361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1008/format/webp" alt="img"></p><p>SurfaceComposerClient的创建.png</p><p><strong>经过上面的步骤，应用程序的ViewRootImpl已经被WindowManagerService识别，并且应用程序已经与SurfaceFlinger建立连接。即创建了SurfaceComposerClient和Client对象</strong></p><p>文章开始就已经说了<code>Surface</code>是<code>Window(ViewRootImpl)</code>的UI载体，那<code>Surface</code>是在哪里创建的呢？</p><h5 id="Surface的创建"><a href="#Surface的创建" class="headerlink" title="Surface的创建"></a>Surface的创建</h5><p>其实一个<code>ViewRootImpl</code>就对应一个<code>Surface</code>。这点可以通过<code>ViewRootImpl</code>的源码看出:</p><blockquote><p>ViewRootImpl.java</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> Surface mSurface <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Surface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>即<code>ViewRootImpl</code>在构造的时候就<code>new 了一个 Surface</code>。但其实这个新new的<code>Surface</code>并没有什么逻辑，它的构造函数是空的。那么<code>Surface</code>到底是在哪里创建的呢？</p><p><strong>触发Surface的创建操作</strong></p><p>我们还是回到<code>ViewRootImpl.setView()</code>来看一下:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setView</span><span class="token punctuation">(</span>View view<span class="token punctuation">,</span> WindowManager<span class="token punctuation">.</span>LayoutParams attrs<span class="token punctuation">,</span> View panelParentView<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">requestLayout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//susion 请求layout。先添加到待渲染队列中  </span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    res <span class="token operator">=</span> mWindowSession<span class="token punctuation">.</span><span class="token function">addToDisplay</span><span class="token punctuation">(</span>mWindow<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//WindowManagerService会创建mWindow对应的WindowState</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>即在向<code>WindowManagerService</code>请求创建<code>WindowState</code>之前，调用了<code>requestLayout()</code>,这个方法会引起<code>ViewRootImpl</code>所管理的整个view tree的重新渲染。它最终会调用到<code>scheduleTraversals()</code>:</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">scheduleTraversals</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    mChoreographer<span class="token punctuation">.</span><span class="token function">postCallback</span><span class="token punctuation">(</span>Choreographer<span class="token punctuation">.</span>CALLBACK_TRAVERSAL<span class="token punctuation">,</span> mTraversalRunnable<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>对于<code>Choreographer</code>本文不做详细的分析，可以去参考 <a href="https://www.jianshu.com/p/996bca12eb1d" target="_blank" rel="noopener">Android Choreographer 源码分析</a>的分析来了解这个类。</p><p><code>scheduleTraversals()</code>会通过<code>Choreographer</code>来post一个<code>mTraversalRunnable</code>，<code>Choreographer</code>接收显示系统的时间脉冲(垂直同步信号-VSync信号，16ms发出一次)，在下一个frame渲染时控制执行这个<code>mTraversalRunnable</code>。</p><p>但是<code>mTraversalRunnable</code>的执行至少要在应用程序与<code>SurfaceFlinger</code>建立连接之后。这是因为渲染操作是由<code>SurfaceFlinger</code>负责调度了，如果应用程序还没有与<code>SurfaceFlinger</code>创建连接，那<code>SurfaceFlinger</code>当然不会渲染这个应用程序。所以在执行完<code>mWindowSession.addToDisplay(mWindow, ...)</code>之后，才会执行<code>mTraversalRunnable</code>:</p><blockquote><p>ViewRootImpl.java</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TraversalRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">doTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>doTraversal()</code>会调用到<code>ViewRootImpl.performTraversals()</code>,大部分同学可能知道这个方法是一个<code>view tree</code>的<code>measure/layout/draw</code>的控制方法:</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">performTraversals</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    finalView host <span class="token operator">=</span> mView<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//mView是一个Window的根View，对于Activity来说就是DecorView</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">relayoutWindow</span><span class="token punctuation">(</span><span class="token keyword">params</span><span class="token punctuation">,</span> viewVisibility<span class="token punctuation">,</span> insetsPending<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">performMeasure</span><span class="token punctuation">(</span>childWidthMeasureSpec<span class="token punctuation">,</span> childHeightMeasureSpec<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token function">performLayout</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> mWidth<span class="token punctuation">,</span> mHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">performDraw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p><code>Surface</code>的具体创建就由<code>relayoutWindow(params, viewVisibility, insetsPending)</code>这个方法来完成的。这个方法会通过<code>IPC</code>调用到<code>WindowManagerService.relayoutWindow()</code>:</p><blockquote><p>ViewRootImpl.java</p></blockquote><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">relayoutWindow</span><span class="token punctuation">(</span>WindowManager<span class="token punctuation">.</span>LayoutParams <span class="token keyword">params</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> throws RemoteException <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> relayoutResult <span class="token operator">=</span> mWindowSession<span class="token punctuation">.</span><span class="token function">relayout</span><span class="token punctuation">(</span>mWindow<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> mSurface<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>上面我省略了<code>mWindowSession.relayout()</code>方法的很多参数，不过有一个十分重要的参数我没有省略，就是<code>mSurface</code>。前面已经分析了它就是一个空的<code>Surface</code>对象。其实:</p><p><strong>真正的Surface创建是由SurfaceControl完成的，应用程序ViewRootImpl的Surface只是一个指针，指向这个Surface</strong></p><p>下面就来看一下<code>SurfaceControl</code>是如何创建<code>Surface</code>的:</p><p><code>mWindowSession.relayout()</code>会调用到<code>WindowManagerService.relayoutWindow()</code>:</p><blockquote><p>WindowManagerService.java</p></blockquote><pre class=" language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//这里的outSurface其实就是ViewRootImpl中的那个Surface</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">relayoutWindow</span><span class="token punctuation">(</span>Session session<span class="token punctuation">,</span> IWindow client<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Surface outSurface<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    result <span class="token operator">=</span> <span class="token function">createSurfaceControl</span><span class="token punctuation">(</span>outSurface<span class="token punctuation">,</span> result<span class="token punctuation">,</span> win<span class="token punctuation">,</span> winAnimator<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">createSurfaceControl</span><span class="token punctuation">(</span>Surface outSurface<span class="token punctuation">,</span> <span class="token keyword">int</span> result<span class="token punctuation">,</span> WindowState win<span class="token punctuation">,</span>WindowStateAnimator winAnimator<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    surfaceController <span class="token operator">=</span> winAnimator<span class="token punctuation">.</span><span class="token function">createSurfaceLocked</span><span class="token punctuation">(</span>win<span class="token punctuation">.</span>mAttrs<span class="token punctuation">.</span>type<span class="token punctuation">,</span> win<span class="token punctuation">.</span>mOwnerUid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    surfaceController<span class="token punctuation">.</span><span class="token function">getSurface</span><span class="token punctuation">(</span>outSurface<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>winAnimator.createSurfaceLocked</code>实际上是创建了一个<code>SurfaceControl</code>。即上面是先构造<code>SurfaceControl</code>，然后在构造<code>Surface</code>。</p><h5 id="SurfaceControl的创建"><a href="#SurfaceControl的创建" class="headerlink" title="SurfaceControl的创建"></a>SurfaceControl的创建</h5><p><code>winAnimator.createSurfaceLocked</code>其实是通过<code>SurfaceControl</code>的构造函数创建了一个<code>SurfaceControl</code>对象,这个对象的作用其实就是负责维护<code>Surface</code>,<code>Surface</code>其实也是由这个对象负责创建的，我们看一下这个对象的构造方法:</p><blockquote><p>SurfaceControl.java</p></blockquote><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">long</span> mNativeObject<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//成员指针变量，指向native创建的SurfaceControl</span><span class="token keyword">private</span> <span class="token function">SurfaceControl</span><span class="token punctuation">(</span>SurfaceSession session<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> format<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>            SurfaceControl parent<span class="token punctuation">,</span> <span class="token keyword">int</span> windowType<span class="token punctuation">,</span> <span class="token keyword">int</span> ownerUid<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    mNativeObject <span class="token operator">=</span> <span class="token function">nativeCreate</span><span class="token punctuation">(</span>session<span class="token punctuation">,</span> name<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> flags<span class="token punctuation">,</span>        parent <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> parent<span class="token punctuation">.</span>mNativeObject <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> windowType<span class="token punctuation">,</span> ownerUid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>即调用了<code>nativeCreate()</code>并返回一个<code>SurfaceControl</code>指针:</p><blockquote><p>android_view_SurfaceControl.cpp</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">static</span> jlong <span class="token function">nativeCreate</span><span class="token punctuation">(</span>JNIEnv<span class="token operator">*</span> env<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//这个client其实就是前面创建的SurfaceComposerClinent</span>    sp<span class="token operator">&lt;</span>SurfaceComposerClient<span class="token operator">></span> <span class="token function">client</span><span class="token punctuation">(</span><span class="token function">android_view_SurfaceSession_getClient</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> sessionObj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     sp<span class="token operator">&lt;</span>SurfaceControl<span class="token operator">></span> surface<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建成功之后，这个指针会指向新创建的SurfaceControl</span>    status_t err <span class="token operator">=</span> client<span class="token operator">-</span><span class="token operator">></span><span class="token function">createSurfaceChecked</span><span class="token punctuation">(</span><span class="token function">String8</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> <span class="token operator">&amp;</span>surface<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> windowType<span class="token punctuation">,</span> ownerUid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>jlong<span class="token operator">></span><span class="token punctuation">(</span>surface<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回这个SurfaceControl的地址</span><span class="token punctuation">}</span></code></pre><p>即调用到<code>SurfaceComposerClient.createSurfaceChecked()</code>:</p><blockquote><p>SurfaceComposerClient.cpp</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//outSurface会指向新创建的SurfaceControl</span>status_t SurfaceComposerClient<span class="token operator">::</span><span class="token function">createSurfaceChecked</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>sp<span class="token operator">&lt;</span>SurfaceControl<span class="token operator">></span><span class="token operator">*</span> outSurface<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">></span> gbp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这个对象很重要</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    err <span class="token operator">=</span> mClient<span class="token operator">-</span><span class="token operator">></span><span class="token function">createSurface</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> parentHandle<span class="token punctuation">,</span> windowType<span class="token punctuation">,</span> ownerUid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>handle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>gbp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//SurfaceControl创建成功, 指针赋值</span>        <span class="token operator">*</span>outSurface <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">SurfaceControl</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> handle<span class="token punctuation">,</span> gbp<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> err<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面这个方法实际上是调用<code>Client.createSurface()</code>来创建一个<code>Surface</code>。在创建时有一个很重要的参数<code>sp&lt;IGraphicBufferProducer&gt; gbp</code>,在下面源码分析中我们也要重点注意它。这是因为应用所渲染的每一帧，实际上都会添加到<code>IGraphicBufferProducer</code>中，来等待<code>SurfaceFlinger</code>的渲染。这个过程我们在下一篇文章中会分析，我们先继续来看一下<code>Surface</code>是如何被<code>Client</code>创建的:</p><blockquote><p>Client.cpp</p></blockquote><pre class=" language-cpp"><code class="language-cpp">status_t Client<span class="token operator">::</span><span class="token function">createSurface</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">//gbp 直接透传到了SurfaceFlinger</span>    <span class="token keyword">return</span> mFlinger<span class="token operator">-</span><span class="token operator">></span><span class="token function">createLayer</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> windowType<span class="token punctuation">,</span> ownerUid<span class="token punctuation">,</span> handle<span class="token punctuation">,</span> gbp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>??? 不是说好的要创建<code>Surface</code>呢？怎么变成<code>mFlinger-&gt;createLayer()</code>? 额，我也不明白这个突然转变，不过我们只要知道:</p><p><strong>Surface在SurfaceFlinger中对应的实体其实是Layer</strong></p><p>我们继续看一下<code>mFlinger-&gt;createLayer()</code></p><blockquote><p>SurfaceFlinger.cpp</p></blockquote><pre class=" language-cpp"><code class="language-cpp">status_t SurfaceFlinger<span class="token operator">::</span><span class="token function">createLayer</span><span class="token punctuation">(</span><span class="token keyword">const</span> String8<span class="token operator">&amp;</span> name<span class="token punctuation">,</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>Client<span class="token operator">></span><span class="token operator">&amp;</span> client<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    status_t result <span class="token operator">=</span> NO_ERROR<span class="token punctuation">;</span>    sp<span class="token operator">&lt;</span>Layer<span class="token operator">></span> layer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将要创建的layer</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> ISurfaceComposerClient<span class="token operator">::</span>eFXSurfaceMask<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> ISurfaceComposerClient<span class="token operator">::</span>eFXSurfaceNormal<span class="token operator">:</span>            result <span class="token operator">=</span> <span class="token function">createBufferLayer</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span>                    uniqueName<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> format<span class="token punctuation">,</span>                    handle<span class="token punctuation">,</span> gbp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>layer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意gbp，这时候还没有构造呢！</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//Layer 分为好几种，这里不全部列出</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    result <span class="token operator">=</span> <span class="token function">addClientLayer</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> <span class="token operator">*</span>handle<span class="token punctuation">,</span> <span class="token operator">*</span>gbp<span class="token punctuation">,</span> layer<span class="token punctuation">,</span> <span class="token operator">*</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这个layer和client相关联, 添加到Client的mLayers集合中。</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从<code>SurfaceFlinger.createLayer()</code>方法可以看出<code>Layer</code>分为好几种。我们这里只对普通的<code>BufferLayer</code>的创建做一下分析，看<code>createBufferLayer()</code>:</p><pre class=" language-cpp"><code class="language-cpp">status_t SurfaceFlinger<span class="token operator">::</span><span class="token function">createBufferLayer</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>Client<span class="token operator">></span><span class="token operator">&amp;</span> client<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> sp<span class="token operator">&lt;</span>Layer<span class="token operator">></span><span class="token operator">*</span> outLayer<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    sp<span class="token operator">&lt;</span>BufferLayer<span class="token operator">></span> layer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">BufferLayer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> client<span class="token punctuation">,</span> name<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    status_t err <span class="token operator">=</span> layer<span class="token operator">-</span><span class="token operator">></span><span class="token function">setBuffers</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> format<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//设置layer的宽高</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>handle <span class="token operator">=</span> layer<span class="token operator">-</span><span class="token operator">></span><span class="token function">getHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建handle</span>        <span class="token operator">*</span>gbp <span class="token operator">=</span> layer<span class="token operator">-</span><span class="token operator">></span><span class="token function">getProducer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建 gbp IGraphicBufferProducer</span>        <span class="token operator">*</span>outLayer <span class="token operator">=</span> layer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把新建的layer的指针拷贝给outLayer,这样outLayer就指向了新建的BufferLayer</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> err<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>前面我说过<code>IGraphicBufferProducer(gbp)</code>是一个很重要的对象，它涉及到<code>SurfaceFlinger</code>的渲染逻辑，下面我们就看一下这个对象的创建逻辑:</p><h6 id="IGraphicBufferProducer-gbp-的创建"><a href="#IGraphicBufferProducer-gbp-的创建" class="headerlink" title="IGraphicBufferProducer(gbp)的创建"></a>IGraphicBufferProducer(gbp)的创建</h6><blockquote><p>BufferLayer.cpp</p></blockquote><pre class=" language-cpp"><code class="language-cpp">sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">></span> BufferLayer<span class="token operator">::</span><span class="token function">getProducer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> mProducer<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>即<code>mProducer</code>其实是<code>Layer</code>的成员变量，它的创建时机是<code>Layer</code>第一次被使用时:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> BufferLayer<span class="token operator">::</span><span class="token function">onFirstRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    BufferQueue<span class="token operator">::</span><span class="token function">createBufferQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>producer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>consumer<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     mProducer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MonitoredProducer</span><span class="token punctuation">(</span>producer<span class="token punctuation">,</span> mFlinger<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>所以<code>mProducer</code>的实例是<code>MonitoredProducer</code>,但其实它只是一个装饰类，它实际功能都委托给构造它的参数<code>producer</code>:</p><blockquote><p>BufferQueue.cpp</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> BufferQueue<span class="token operator">::</span><span class="token function">createBufferQueue</span><span class="token punctuation">(</span>sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">></span><span class="token operator">*</span> outProducer<span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    sp<span class="token operator">&lt;</span>IGraphicBufferProducer<span class="token operator">></span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">BufferQueueProducer</span><span class="token punctuation">(</span>core<span class="token punctuation">,</span> consumerIsSurfaceFlinger<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sp<span class="token operator">&lt;</span>IGraphicBufferConsumer<span class="token operator">></span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">BufferQueueConsumer</span><span class="token punctuation">(</span>core<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注意这个consumer</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token operator">*</span>outProducer <span class="token operator">=</span> producer<span class="token punctuation">;</span>    <span class="token operator">*</span>outConsumer <span class="token operator">=</span> consumer<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>所以实际实现<code>mProducer</code>的工作的<code>queueProducer</code>是<code>BufferQueueProducer</code>。</p><p>所以构造一个<code>SurfaceControl</code>所做的工作就是创建了一个<code>SurfaceControl</code>,并让<code>SurfaceFlinger</code>创建了一个对应的<code>Layer</code>，<code>Layer</code>中有一个<code>IGraphicBufferProducer</code>,它的实例是<code>BufferQueueProducer</code>。</p><p>可以用下面这个图来描述<code>SurfaceControl</code>的创建过程:</p><p><img src="https:////upload-images.jianshu.io/upload_images/2934684-21fb8a495722870c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/889/format/webp" alt="img"></p><p>SurfaceControl的创建.png</p><h6 id="从SurfaceControl中获取Surface"><a href="#从SurfaceControl中获取Surface" class="headerlink" title="从SurfaceControl中获取Surface"></a>从SurfaceControl中获取Surface</h6><p>我们回看<code>WindowManagerService.createSurfaceControl()</code>， 来看一下java层的<code>Surface</code>对象到底是个什么:</p><blockquote><p>WindowManagerService.java</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">createSurfaceControl</span><span class="token punctuation">(</span>Surface outSurface<span class="token punctuation">,</span> <span class="token keyword">int</span> result<span class="token punctuation">,</span> WindowState win<span class="token punctuation">,</span>WindowStateAnimator winAnimator<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    surfaceController <span class="token operator">=</span> winAnimator<span class="token punctuation">.</span><span class="token function">createSurfaceLocked</span><span class="token punctuation">(</span>win<span class="token punctuation">.</span>mAttrs<span class="token punctuation">.</span>type<span class="token punctuation">,</span> win<span class="token punctuation">.</span>mOwnerUid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    surfaceController<span class="token punctuation">.</span><span class="token function">getSurface</span><span class="token punctuation">(</span>outSurface<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面我们已经了解了<code>winAnimator.createSurfaceLocked</code>的整个过程，我们看一下<code>surfaceController.getSurface(outSurface)</code>, <code>surfaceController</code>是<code>WindowSurfaceController</code>的实例:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//WindowSurfaceController.java</span><span class="token keyword">void</span> <span class="token function">getSurface</span><span class="token punctuation">(</span>Surface outSurface<span class="token punctuation">)</span> <span class="token punctuation">{</span>    outSurface<span class="token punctuation">.</span><span class="token function">copyFrom</span><span class="token punctuation">(</span>mSurfaceControl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Surface.java</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">copyFrom</span><span class="token punctuation">(</span>SurfaceControl other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">long</span> surfaceControlPtr <span class="token operator">=</span> other<span class="token punctuation">.</span>mNativeObject<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">long</span> newNativeObject <span class="token operator">=</span> <span class="token function">nativeGetFromSurfaceControl</span><span class="token punctuation">(</span>surfaceControlPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    mNativeObject <span class="token operator">=</span> ptr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// mNativeObject指向native创建的Surface</span><span class="token punctuation">}</span></code></pre><p>即<code>Surface.copyFrom()</code>方法调用<code>nativeGetFromSurfaceControl()</code>来获取一个指针，这个指针是根据前面创建的<code>SurfaceControl</code>的指针来寻找的，即传入的参数<code>surfaceControlPtr</code>:</p><blockquote><p>android_view_Surface.cpp</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">static</span> jlong <span class="token function">nativeGetFromSurfaceControl</span><span class="token punctuation">(</span>JNIEnv<span class="token operator">*</span> env<span class="token punctuation">,</span> jclass <span class="token class-name">clazz</span><span class="token punctuation">,</span> jlong surfaceControlNativeObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sp<span class="token operator">&lt;</span>SurfaceControl<span class="token operator">></span> <span class="token function">ctrl</span><span class="token punctuation">(</span><span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>SurfaceControl <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>surfaceControlNativeObj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把java指针转化内native指针</span>    sp<span class="token operator">&lt;</span>Surface<span class="token operator">></span> <span class="token function">surface</span><span class="token punctuation">(</span>ctrl<span class="token operator">-</span><span class="token operator">></span><span class="token function">getSurface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//直接构造一个Surface，指向 ctrl->getSurface()</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>surface <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        surface<span class="token operator">-</span><span class="token operator">></span><span class="token function">incStrong</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sRefBaseOwner<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//强引用</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>jlong<span class="token operator">></span><span class="token punctuation">(</span>surface<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里的<code>ctrl</code>指向前面创建的<code>SurfaceControl</code>，继续追溯<code>ctrl-&gt;getSurface()</code>:</p><blockquote><p>SurfaceControl.cpp</p></blockquote><pre class=" language-cpp"><code class="language-cpp">sp<span class="token operator">&lt;</span>Surface<span class="token operator">></span> SurfaceControl<span class="token operator">::</span><span class="token function">getSurface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    Mutex<span class="token operator">::</span>Autolock <span class="token function">_l</span><span class="token punctuation">(</span>mLock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mSurfaceData <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">generateSurfaceLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> mSurfaceData<span class="token punctuation">;</span><span class="token punctuation">}</span>sp<span class="token operator">&lt;</span>Surface<span class="token operator">></span> SurfaceControl<span class="token operator">::</span><span class="token function">generateSurfaceLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//这个mGraphicBufferProducer其实就是上面分析的BufferQueueProducer</span>    mSurfaceData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Surface</span><span class="token punctuation">(</span>mGraphicBufferProducer<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> mSurfaceData<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>即直接new了一个<code>nativie的Surface</code>返回给java层，<code>java层的Surface</code>指向的就是<code>native层的Surface</code>。</p><p>所以<code>Surface</code>的实际创建可以用下图表示:</p><p><img src="https:////upload-images.jianshu.io/upload_images/2934684-6a4f3b80766d1547.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/586/format/webp" alt="img"></p><p>Surface的创建.png</p><p>经过上面这个图，也可以理解<code>SurfaceControl</code>为什么叫<code>SurfaceControl</code>了。</p><h2 id="app侧硬件加速绘制surface流程"><a href="#app侧硬件加速绘制surface流程" class="headerlink" title="app侧硬件加速绘制surface流程"></a>app侧硬件加速绘制surface流程</h2><p>Android4.0之后，系统默认开启硬件加速来渲染视图，通过GPU处理数据，OpenGL主要处理的任务有Surface的composition及图形图像的渲染，本篇文章简单说一下后半部分的模型，这部分对于理解View渲染也有不少帮助，也能更好的帮助理解GPU渲染玄学曲线。</p><p>不过这里有个概念要先弄清，OpenGL仅仅是提供标准的API及调用规则，在不同的硬件平台上有不同的实现，比如驱动等，这部分代码一般是不开源，本文主要基于Android libagl（6.0），它是Android中通过软件方法实现的一套OpenGL动态库，并结合Systrace真机上的调用栈，对比两者区别（GPU厂商提供的硬件实现的OpenGL），猜测libhgl（硬件OpenGL）的实现。对于Android APP而言，基于GPU的硬件加速绘制可以分为如下几个阶段：</p><ul><li>第一阶段：APP在UI线程构建OpenGL渲染需要的命令及数据</li><li>第二阶段：CPU将数据上传（共享或者拷贝）给GPU，PC上一般有显存一说，但是ARM这种嵌入式设备内存一般是GPU、CPU共享内存</li><li>第三阶段：通知GPU渲染，一般而言，真机不会阻塞等待GPU渲染结束，效率低，CPU通知结束后就返回继续执行其他任务，当然，理论上也可以阻塞执行，glFinish就能满足这样的需求（<strong>不同GPU厂商实现不同，Android源码自带的是软件实现的，只具有参考意义</strong>）（Fence机制辅助GPU CPU同步）</li><li>第四阶段：swapBuffers，并通知SurfaceFlinger图层合成</li><li>第五阶段：SurfaceFlinger开始合成图层，如果之前提交的GPU渲染任务没结束，则等待GPU渲染完成，再合成（Fence机制），合成依然是依赖GPU，不过这就是下一个任务了</li></ul><p>第一个阶段，其实主要做的就是构建DrawOp树（里面封装OpenGL渲染命令），同时，预处理分组一些相似命令，以便提高GPU处理效率，这个阶段主要是CPU在工作，不过这个阶段前期运行在UI线程，后期部分运行在RenderThread（渲染线程），第二个阶段主要运行在渲染线程，CPU将数据同步（共享）给GPU，之后，通知GPU进行渲染，不过这里需要注意的是，CPU一般不会阻塞等待GPU渲染完毕，而是通知结束后就返回，除非GPU非常繁忙，来不及响应CPU的请求，没有给CPU发送通知，CPU才会阻塞等待。CPU返回后，会直接将GraphicBuffer提交给SurfaceFlinger，告诉SurfaceFlinger进行合成，但是这个时候GPU可能并未完成图像的渲染，这个时候就牵扯到一个同步，Android中，这里用的是Fence机制，SurfaceFlinger合成前会查询这个Fence，如果GPU渲染没有结束，则等待GPU渲染结束，GPU结束后，会通知SurfaceFlinger进行合成，SF合成后，提交显示，如此完成图像的渲染显示，简单画下示意图：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1460468-b4cf44398e5d221c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>Android CPU GPU通信模型</p><p>之前已经简单分析过DrawOp树的构建，优化，本文主要是分析GPU如何完成OpenGL渲染，这个过程主要在Render线程，通过OpenGL API通知GPU处理渲染任务。</p><h3 id="Android-OpenGL环境的初始化"><a href="#Android-OpenGL环境的初始化" class="headerlink" title="Android OpenGL环境的初始化"></a>Android OpenGL环境的初始化</h3><p>一般在使用OpenGL的时候，首先需要获取OpenGL相应的配置，再为其构建渲染环境，比如必须创建OpenGL上下文(Context)，上下文可以看做是OpenGL的化身，没有上下文就没有OpenGL环境，同时还要构建一个用于绘图的画布GlSurface，在Android中抽象出来就是EglContext与EglSurface，示例如下：</p><pre class=" language-jsx"><code class="language-jsx">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">initGL</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mEgl <span class="token operator">=</span> <span class="token punctuation">(</span>EGL10<span class="token punctuation">)</span> EGLContext<span class="token punctuation">.</span><span class="token function">getEGL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>获取display显示目标<span class="token operator">--</span><span class="token operator">></span>        mEglDisplay <span class="token operator">=</span> mEgl<span class="token punctuation">.</span><span class="token function">eglGetDisplay</span><span class="token punctuation">(</span>EGL10<span class="token punctuation">.</span>EGL_DEFAULT_DISPLAY<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>构建配置<span class="token operator">--</span><span class="token operator">></span>        mEglConfig <span class="token operator">=</span> <span class="token function">chooseEglConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>构建上下文<span class="token operator">--</span><span class="token operator">></span>        mEglContext <span class="token operator">=</span> <span class="token function">createContext</span><span class="token punctuation">(</span>mEgl<span class="token punctuation">,</span> mEglDisplay<span class="token punctuation">,</span> mEglConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>构建绘图Surface<span class="token operator">--</span><span class="token operator">></span>        mEglSurface <span class="token operator">=</span> mEgl<span class="token punctuation">.</span><span class="token function">eglCreateWindowSurface</span><span class="token punctuation">(</span>mEglDisplay<span class="token punctuation">,</span> mEglConfig<span class="token punctuation">,</span> mSurface<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>Android系统中，APP端如何为每个窗口配置OpenGL环境的，在一个窗口被添加到窗口的时候会调用其ViewRootImpl对象的setView：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setView</span><span class="token punctuation">(</span>View view<span class="token punctuation">,</span> WindowManager<span class="token punctuation">.</span>LayoutParams attrs<span class="token punctuation">,</span> View panelParentView<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token function">enableHardwareAcceleration</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span></code></pre><p>setView会调用enableHardwareAcceleration，配置OpenGL的硬件加速环境：</p><pre class=" language-xml"><code class="language-xml">private void enableHardwareAcceleration(WindowManager.LayoutParams attrs) {        mAttachInfo.mHardwareAccelerated = false;        mAttachInfo.mHardwareAccelerationRequested = false;            ...        final boolean hardwareAccelerated =                (attrs.flags &amp; WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED) != 0;        if (hardwareAccelerated) {        <span class="token comment" spellcheck="true">&lt;!--可以开启硬件加速 ，一般都是true--></span>            if (!HardwareRenderer.isAvailable()) {                return;            }                    ...                <span class="token comment" spellcheck="true">&lt;!--创建硬件加速环境--></span>                mAttachInfo.mHardwareRenderer = HardwareRenderer.create(mContext, translucent);                if (mAttachInfo.mHardwareRenderer != null) {                    mAttachInfo.mHardwareRenderer.setName(attrs.getTitle().toString());                    mAttachInfo.mHardwareAccelerated =                            mAttachInfo.mHardwareAccelerationRequested = true;                }            }        }    }</code></pre><p>Android中每个显示的Window（Activity、Dialog、PopupWindow等）都对应一个ViewRootImpl对象，也会对应一个AttachInfo对象，之后通过</p><pre class=" language-css"><code class="language-css">HardwareRenderer<span class="token number">.</span><span class="token function">create</span><span class="token punctuation">(</span>mContext, translucent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>创建的HardwareRenderer对象就被保存在ViewRootImpl的AttachInfo中，跟Window是一对一的关系，通过HardwareRenderer.create(mContext, translucent)创建硬件加速环境后，在需要draw绘制的时候，通过：</p><pre class=" language-css"><code class="language-css">    mAttachInfo<span class="token number">.</span>mHardwareRenderer<span class="token number">.</span><span class="token function">draw</span><span class="token punctuation">(</span>mView, mAttachInfo, this<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>进一步渲染。回过头，接着看APP如何初始化硬件加速环境：<strong>直观上说，主要是构建OpenGLContext、EglSurface、RenderThread(如果没启动的话)</strong>。</p><pre class=" language-xml"><code class="language-xml">static HardwareRenderer create(Context context, boolean translucent) {    HardwareRenderer renderer = null;    if (DisplayListCanvas.isAvailable()) {        renderer = new ThreadedRenderer(context, translucent);    }    return renderer;}ThreadedRenderer(Context context, boolean translucent) {    final TypedArray a = context.obtainStyledAttributes(null, R.styleable.Lighting, 0, 0);    ...    <span class="token comment" spellcheck="true">&lt;!--创建rootnode--></span>    long rootNodePtr = nCreateRootRenderNode();    mRootNode = RenderNode.adopt(rootNodePtr);   <span class="token comment" spellcheck="true">&lt;!--创建native ThreadProxy--></span>    mNativeProxy = nCreateProxy(translucent, rootNodePtr);    <span class="token comment" spellcheck="true">&lt;!--初始化AssetAtlas,本文不分析--></span>    ProcessInitializer.sInstance.init(context, mNativeProxy);    ...}</code></pre><p>之前分析过，nCreateRootRenderNode 为ViewRootimpl创建一个root RenderNode，UI线程通过递归mRootNode，可以构建ViewTree所有的OpenGL绘制命令及数据，nCreateProxy会为当前widow创建一个ThreadProxy ，ThreadProxy则主要用来向RenderThread线程提交一些OpenGL相关任务，比如初始化，绘制、更新等：</p><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">ANDROID_API</span> RenderProxy <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ANDROID_API <span class="token function">RenderProxy</span><span class="token punctuation">(</span><span class="token keyword">bool</span> translucent<span class="token punctuation">,</span> RenderNode<span class="token operator">*</span> rootNode<span class="token punctuation">,</span> IContextFactory<span class="token operator">*</span> contextFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    ANDROID_API <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">RenderProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    ANDROID_API <span class="token keyword">bool</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>ANativeWindow<span class="token operator">></span><span class="token operator">&amp;</span> window<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    ANDROID_API <span class="token keyword">int</span> <span class="token function">syncAndDrawFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    ANDROID_API DeferredLayerUpdater<span class="token operator">*</span> <span class="token function">createTextureLayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ANDROID_API <span class="token keyword">void</span> <span class="token function">buildLayer</span><span class="token punctuation">(</span>RenderNode<span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>    ANDROID_API <span class="token keyword">bool</span> <span class="token function">copyLayerInto</span><span class="token punctuation">(</span>DeferredLayerUpdater<span class="token operator">*</span> layer<span class="token punctuation">,</span> SkBitmap<span class="token operator">&amp;</span> bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    ANDROID_API <span class="token keyword">void</span> <span class="token function">fence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">destroyContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">post</span><span class="token punctuation">(</span>RenderTask<span class="token operator">*</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">postAndWait</span><span class="token punctuation">(</span>MethodInvokeRenderTask<span class="token operator">*</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>RenderProxy的在创建之初会做什么？其实主要两件事，第一：如果RenderThread未启动，则启动它，第二：向RenderThread提交第一个Task–为当前窗口创建CanvasContext，CanvasContext有点EglContext的意味，所有的绘制命令都会通过CanvasContext进行中转：</p><pre class=" language-xml"><code class="language-xml">RenderProxy::RenderProxy(bool translucent, RenderNode* rootRenderNode, IContextFactory* contextFactory)        : mRenderThread(RenderThread::getInstance())        , mContext(nullptr) {     <span class="token comment" spellcheck="true">&lt;!--创建CanvasContext--></span>    SETUP_TASK(createContext);    args->translucent = translucent;    args->rootRenderNode = rootRenderNode;    args->thread = &amp;mRenderThread;    args->contextFactory = contextFactory;    mContext = (CanvasContext*) postAndWait(task);    <span class="token comment" spellcheck="true">&lt;!--初始化DrawFrameTask--></span>    mDrawFrameTask.setContext(&amp;mRenderThread, mContext);}</code></pre><p>从其构造函数中可以看出，OpenGL Render线程是一个单例，同一个进程只有一个RenderThread，RenderProxy 通过mRenderThread引用该单例，将来需要提交任务的时候，直接通过该引用向RenderThread的Queue中插入消息，而RenderThread主要负责从Queue取出消息，并执行，比如将OpenGL命令issue提交给GPU，并通知GPU渲染。在Android Profile的CPU工具中可以清楚的看到该线程的存在（没有显示任务的进程是没有的：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1460468-265afedca9d749a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/509/format/webp" alt="img"></p><p>renderThread</p><p>简单看下RenderThread()这个单例线程的创建与启动，</p><pre class=" language-cpp"><code class="language-cpp">RenderThread<span class="token operator">::</span><span class="token function">RenderThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Singleton<span class="token operator">&lt;</span>RenderThread<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mNextWakeup</span><span class="token punctuation">(</span>LLONG_MAX<span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mDisplayEventReceiver</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mVsyncRequested</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mFrameCallbackTaskPending</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mFrameCallbackTask</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mRenderState</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mEglManager</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Properties<span class="token operator">::</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mFrameCallbackTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">DispatchFrameCallbacks</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mLooper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Looper</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">run</span><span class="token punctuation">(</span><span class="token string">"RenderThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>RenderThread会维护一个MessageQuene，并通过loop的方式读取消息，执行，RenderThread在启动之前，会为OpenGL创建EglManager、RenderState、VSync信号接收器（这个主要为了动画）等OpenGL渲染需要工具组件，之后启动该线程进入loop：</p><pre class=" language-xml"><code class="language-xml">bool RenderThread::threadLoop() {    <span class="token comment" spellcheck="true">&lt;!--初始化--></span>    setpriority(PRIO_PROCESS, 0, PRIORITY_DISPLAY);    initThreadLocals();    int timeoutMillis = -1;    for (;;) {    <span class="token comment" spellcheck="true">&lt;!--等待消息队列不为空--></span>        int result = mLooper->pollOnce(timeoutMillis);        nsecs_t nextWakeup;        // Process our queue, if we have anything        <span class="token comment" spellcheck="true">&lt;!--获取消息并执行--></span>        while (RenderTask* task = nextTask(&amp;nextWakeup)) {            task->run();        }        ...     return false;}</code></pre><p>初始化，主要是创建EglContext中必须的一些组件，到这里其实都是工具的创建，基本上还没构建OpenGL需要的任何实质性的东西</p><pre class=" language-xml"><code class="language-xml">     void RenderThread::initThreadLocals() {    sp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>IBinder</span><span class="token punctuation">></span></span> dtoken(SurfaceComposerClient::getBuiltInDisplay(            ISurfaceComposer::eDisplayIdMain));    status_t status = SurfaceComposerClient::getDisplayInfo(dtoken, &amp;mDisplayInfo);    nsecs_t frameIntervalNanos = static_cast<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nsecs_t</span><span class="token punctuation">></span></span>(1000000000 / mDisplayInfo.fps);    mTimeLord.setFrameInterval(frameIntervalNanos);    <span class="token comment" spellcheck="true">&lt;!--初始化vsync接收器--></span>    initializeDisplayEventReceiver();    <span class="token comment" spellcheck="true">&lt;!--管家--></span>    mEglManager = new EglManager(*this);    <span class="token comment" spellcheck="true">&lt;!--状态机--></span>    mRenderState = new RenderState(*this);    <span class="token comment" spellcheck="true">&lt;!--debug分析工具--></span>    mJankTracker = new JankTracker(frameIntervalNanos);}</code></pre><p>Android5.0之后，有些动画是可以完全在RenderThread完成的，这个时候render渲染线程需要接受Vsync，等信号到来后，回调RenderThread::displayEventReceiverCallback，计算当前动画状态，最后调用doFrame绘制当前动画帧（不详述），有时间可以看下Vsync机制</p><pre class=" language-php"><code class="language-php">void RenderThread<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">initializeDisplayEventReceiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mDisplayEventReceiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DisplayEventReceiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    status_t status <span class="token operator">=</span> mDisplayEventReceiver<span class="token operator">-</span><span class="token operator">></span><span class="token function">initCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mLooper<span class="token operator">-</span><span class="token operator">></span><span class="token function">addFd</span><span class="token punctuation">(</span>mDisplayEventReceiver<span class="token operator">-</span><span class="token operator">></span><span class="token function">getFd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>            Looper<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">EVENT_INPUT</span><span class="token punctuation">,</span> RenderThread<span class="token punctuation">:</span><span class="token punctuation">:</span>displayEventReceiverCallback<span class="token punctuation">,</span> this<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其次RenderThread需要new一个EglManager及RenderState，两者跟上面的DisplayEventReceiver都从属RenderThread，因此在一个进程中，也是单例的</p><pre class=" language-cpp"><code class="language-cpp">EglManager<span class="token operator">::</span><span class="token function">EglManager</span><span class="token punctuation">(</span>RenderThread<span class="token operator">&amp;</span> thread<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">mRenderThread</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mEglDisplay</span><span class="token punctuation">(</span>EGL_NO_DISPLAY<span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mEglConfig</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mEglContext</span><span class="token punctuation">(</span>EGL_NO_CONTEXT<span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mPBufferSurface</span><span class="token punctuation">(</span>EGL_NO_SURFACE<span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mAllowPreserveBuffer</span><span class="token punctuation">(</span><span class="token function">load_dirty_regions_property</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mCurrentSurface</span><span class="token punctuation">(</span>EGL_NO_SURFACE<span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mAtlasMap</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mAtlasMapSize</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mCanSetPreserveBuffer <span class="token operator">=</span> mAllowPreserveBuffer<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>EglManager主要作用是管理OpenGL上下文，比如创建EglSurface、指定当前操作的Surface、swapBuffers等，主要负责场景及节点的管理工作：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">EglManager</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// Returns true on success, false on failure</span>    <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    EGLSurface <span class="token function">createSurface</span><span class="token punctuation">(</span>EGLNativeWindowType window<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">destroySurface</span><span class="token punctuation">(</span>EGLSurface surface<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token function">isCurrent</span><span class="token punctuation">(</span>EGLSurface surface<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> mCurrentSurface <span class="token operator">==</span> surface<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Returns true if the current surface changed, false if it was already current</span>    <span class="token keyword">bool</span> <span class="token function">makeCurrent</span><span class="token punctuation">(</span>EGLSurface surface<span class="token punctuation">,</span> EGLint<span class="token operator">*</span> errOut <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">beginFrame</span><span class="token punctuation">(</span>EGLSurface surface<span class="token punctuation">,</span> EGLint<span class="token operator">*</span> width<span class="token punctuation">,</span> EGLint<span class="token operator">*</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token function">swapBuffers</span><span class="token punctuation">(</span>EGLSurface surface<span class="token punctuation">,</span> <span class="token keyword">const</span> SkRect<span class="token operator">&amp;</span> dirty<span class="token punctuation">,</span> EGLint width<span class="token punctuation">,</span> EGLint height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Returns true iff the surface is now preserving buffers.</span>    <span class="token keyword">bool</span> <span class="token function">setPreserveBuffer</span><span class="token punctuation">(</span>EGLSurface surface<span class="token punctuation">,</span> <span class="token keyword">bool</span> preserve<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setTextureAtlas</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>GraphicBuffer<span class="token operator">></span><span class="token operator">&amp;</span> buffer<span class="token punctuation">,</span> int64_t<span class="token operator">*</span> map<span class="token punctuation">,</span> size_t mapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">fence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">RenderThread</span><span class="token punctuation">;</span>    <span class="token function">EglManager</span><span class="token punctuation">(</span>RenderThread<span class="token operator">&amp;</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// EglContext is never destroyed, method is purposely not implemented</span>    <span class="token operator">~</span><span class="token function">EglManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">createPBufferSurface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">loadConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">initAtlas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    RenderThread<span class="token operator">&amp;</span> mRenderThread<span class="token punctuation">;</span>    EGLDisplay mEglDisplay<span class="token punctuation">;</span>    EGLConfig mEglConfig<span class="token punctuation">;</span>    EGLContext mEglContext<span class="token punctuation">;</span>    EGLSurface mPBufferSurface<span class="token punctuation">;</span>    <span class="token punctuation">,</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>而RenderState可以看做是OpenGL状态机的具体呈现，真正负责OpenGL的渲染状态的维护及渲染命令的issue</p><pre class=" language-php"><code class="language-php">RenderState<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">RenderState</span><span class="token punctuation">(</span>renderthread<span class="token punctuation">:</span><span class="token punctuation">:</span>RenderThread<span class="token operator">&amp;</span> thread<span class="token punctuation">)</span>        <span class="token punctuation">:</span> <span class="token function">mRenderThread</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mViewportWidth</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mViewportHeight</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mFramebuffer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mThreadId <span class="token operator">=</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在RenderProxy创建之初，插入到的第一条消息就是SETUP_TASK(createContext)，构建CanvasContext ,它可以看做OpenGL的Context及Surface的封装，</p><pre class=" language-php"><code class="language-php"><span class="token function">CREATE_BRIDGE4</span><span class="token punctuation">(</span>createContext<span class="token punctuation">,</span> RenderThread<span class="token operator">*</span> thread<span class="token punctuation">,</span> bool translucent<span class="token punctuation">,</span>        RenderNode<span class="token operator">*</span> rootRenderNode<span class="token punctuation">,</span> IContextFactory<span class="token operator">*</span> contextFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CanvasContext</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token operator">-</span><span class="token operator">></span><span class="token property">thread</span><span class="token punctuation">,</span> args<span class="token operator">-</span><span class="token operator">></span><span class="token property">translucent</span><span class="token punctuation">,</span>            args<span class="token operator">-</span><span class="token operator">></span><span class="token property">rootRenderNode</span><span class="token punctuation">,</span> args<span class="token operator">-</span><span class="token operator">></span><span class="token property">contextFactory</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到，CanvasContext同时握有RenderThread、EglManager、RootRenderNode等，它可以看做Android中OpenGL上下文，是上层渲染API的入口</p><pre class=" language-cpp"><code class="language-cpp">CanvasContext<span class="token operator">::</span><span class="token function">CanvasContext</span><span class="token punctuation">(</span>RenderThread<span class="token operator">&amp;</span> thread<span class="token punctuation">,</span> <span class="token keyword">bool</span> translucent<span class="token punctuation">,</span>        RenderNode<span class="token operator">*</span> rootRenderNode<span class="token punctuation">,</span> IContextFactory<span class="token operator">*</span> contextFactory<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">mRenderThread</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mEglManager</span><span class="token punctuation">(</span>thread<span class="token punctuation">.</span><span class="token function">eglManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mOpaque</span><span class="token punctuation">(</span><span class="token operator">!</span>translucent<span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mAnimationContext</span><span class="token punctuation">(</span>contextFactory<span class="token operator">-</span><span class="token operator">></span><span class="token function">createAnimationContext</span><span class="token punctuation">(</span>mRenderThread<span class="token punctuation">.</span><span class="token function">timeLord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mRootRenderNode</span><span class="token punctuation">(</span>rootRenderNode<span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mJankTracker</span><span class="token punctuation">(</span>thread<span class="token punctuation">.</span><span class="token function">timeLord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">frameIntervalNanos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">mProfiler</span><span class="token punctuation">(</span>mFrames<span class="token punctuation">)</span> <span class="token punctuation">{</span>    mRenderThread<span class="token punctuation">.</span><span class="token function">renderState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerCanvasContext</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mProfiler<span class="token punctuation">.</span><span class="token function">setDensity</span><span class="token punctuation">(</span>mRenderThread<span class="token punctuation">.</span><span class="token function">mainDisplayInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>density<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其实到这里初始化完成了一般，另一半是在draw的时候，进行的也就是ThreadRender的initialize，毕竟，如果不需要绘制，是不需要初始化OpenGL环境的，省的浪费资源：</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">performTraversals</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>mAttachInfo<span class="token punctuation">.</span>mHardwareRenderer <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            hwInitialized <span class="token operator">=</span> mAttachInfo<span class="token punctuation">.</span>mHardwareRenderer<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span>mSurface<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里的mSurface其实是已经被WMS填充处理过的一个Surface，它在native层对应一个ANativeWindow（其实就是个native的Surface），随着RenderProxy的initial的初始化，EglContext跟EglSurface会被进一步创建，需要注意的是这里的initialize任务是在Render线程，OpenGL的相关操作都必须在Render线程：</p><pre class=" language-dart"><code class="language-dart"><span class="token function">CREATE_BRIDGE2</span><span class="token punctuation">(</span>initialize<span class="token punctuation">,</span> CanvasContext<span class="token operator">*</span> context<span class="token punctuation">,</span> ANativeWindow<span class="token operator">*</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> args<span class="token operator">-</span><span class="token operator">></span>context<span class="token operator">-</span><span class="token operator">></span><span class="token function">initialize</span><span class="token punctuation">(</span>args<span class="token operator">-</span><span class="token operator">></span>window<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>bool RenderProxy<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>ANativeWindow<span class="token operator">></span><span class="token operator">&amp;</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">SETUP_TASK</span><span class="token punctuation">(</span>initialize<span class="token punctuation">)</span><span class="token punctuation">;</span>    args<span class="token operator">-</span><span class="token operator">></span>context <span class="token operator">=</span> mContext<span class="token punctuation">;</span>    args<span class="token operator">-</span><span class="token operator">></span>window <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>bool<span class="token punctuation">)</span> <span class="token function">postAndWait</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>bool CanvasContext<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">initialize</span><span class="token punctuation">(</span>ANativeWindow<span class="token operator">*</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setSurface</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mCanvas<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    mCanvas <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OpenGLRenderer</span><span class="token punctuation">(</span>mRenderThread<span class="token punctuation">.</span><span class="token function">renderState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mCanvas<span class="token operator">-</span><span class="token operator">></span><span class="token function">initProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里传入的ANativeWindow* window其实就是native的Surface，CanvasContext在初始化的时候，会通过setSurface为OpenGL创建E关联Con小text、EglSurface画布，同时会为当前窗口创建一个OpenGLRenderer，OpenGLRenderer主要用来处理之前构建的DrawOp，输出对应的OpenGL命令。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">void</span> CanvasContext<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">setSurface</span><span class="token punctuation">(</span>ANativeWindow<span class="token operator">*</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span>    mNativeWindow <span class="token operator">=</span> window<span class="token punctuation">;</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>创建EglSurface画布<span class="token operator">--</span><span class="token operator">></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mEglSurface <span class="token operator">=</span> mEglManager<span class="token punctuation">.</span><span class="token function">createSurface</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mEglSurface <span class="token operator">!=</span> EGL_NO_SURFACE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> bool preserveBuffer <span class="token operator">=</span> <span class="token punctuation">(</span>mSwapBehavior <span class="token operator">!=</span> kSwap_discardBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        mBufferPreserved <span class="token operator">=</span> mEglManager<span class="token punctuation">.</span><span class="token function">setPreserveBuffer</span><span class="token punctuation">(</span>mEglSurface<span class="token punctuation">,</span> preserveBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        mHaveNewSurface <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>绑定上下文<span class="token operator">--</span><span class="token operator">></span>        <span class="token function">makeCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>EGLSurface EglManager<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">createSurface</span><span class="token punctuation">(</span>EGLNativeWindowType window<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>构建EglContext<span class="token operator">--</span><span class="token operator">></span>    <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>创建EglSurface<span class="token operator">--</span><span class="token operator">></span>    EGLSurface surface <span class="token operator">=</span> <span class="token function">eglCreateWindowSurface</span><span class="token punctuation">(</span>mEglDisplay<span class="token punctuation">,</span> mEglConfig<span class="token punctuation">,</span> window<span class="token punctuation">,</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> surface<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> EglManager<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasEglContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    mEglDisplay <span class="token operator">=</span> <span class="token function">eglGetDisplay</span><span class="token punctuation">(</span>EGL_DEFAULT_DISPLAY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">loadConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">createPBufferSurface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">makeCurrent</span><span class="token punctuation">(</span>mPBufferSurface<span class="token punctuation">)</span><span class="token punctuation">;</span>    mRenderThread<span class="token punctuation">.</span><span class="token function">renderState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onGLContextCreated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">initAtlas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> EglManager<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    EGLint attribs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> EGL_CONTEXT_CLIENT_VERSION<span class="token punctuation">,</span> GLES_VERSION<span class="token punctuation">,</span> EGL_NONE <span class="token punctuation">}</span><span class="token punctuation">;</span>    mEglContext <span class="token operator">=</span> <span class="token function">eglCreateContext</span><span class="token punctuation">(</span>mEglDisplay<span class="token punctuation">,</span> mEglConfig<span class="token punctuation">,</span> EGL_NO_CONTEXT<span class="token punctuation">,</span> attribs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LOG_ALWAYS_FATAL_IF</span><span class="token punctuation">(</span>mEglContext <span class="token operator">==</span> EGL_NO_CONTEXT<span class="token punctuation">,</span>        <span class="token string">"Failed to create context, error = %s"</span><span class="token punctuation">,</span> <span class="token function">egl_error_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>EglManager::initialize()之后EglContext、Config全都有了，之后通过eglCreateWindowSurface创建EglSurface,这里先调用eglApi.cpp 的eglCreateWindowSurface</p><pre class=" language-xml"><code class="language-xml">EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,                                    NativeWindowType window,                                    const EGLint *attrib_list) {        <span class="token comment" spellcheck="true">&lt;!--配置--></span>        int result = native_window_api_connect(window, NATIVE_WINDOW_API_EGL);        <span class="token comment" spellcheck="true">&lt;!--Android源码中，其实是调用egl.cpp的eglCreateWindowSurface，不过这一块软件模拟的跟真实硬件的应该差别不多--></span>            // Eglsurface里面是有Surface的引用的，同时swap的时候，是能通知consumer的        EGLSurface surface = cnx->egl.eglCreateWindowSurface(                iDpy, config, window, attrib_list);        ... }</code></pre><blockquote><p>egl.cpp其实是软件模拟的GPU实现库，不过这里的eglCreateWindowSurface逻辑其实跟真实GPU平台的代码差别不大，因为只是抽象逻辑：</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">static</span> EGLSurface <span class="token function">createWindowSurface</span><span class="token punctuation">(</span>EGLDisplay dpy<span class="token punctuation">,</span> EGLConfig config<span class="token punctuation">,</span>        NativeWindowType window<span class="token punctuation">,</span> <span class="token keyword">const</span> EGLint<span class="token operator">*</span> <span class="token comment" spellcheck="true">/*attrib_list*/</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    egl_surface_t<span class="token operator">*</span> surface<span class="token punctuation">;</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>其实返回的就是egl_window_surface_v2_t<span class="token operator">--</span><span class="token operator">></span>    surface <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">egl_window_surface_v2_t</span><span class="token punctuation">(</span>dpy<span class="token punctuation">,</span> config<span class="token punctuation">,</span> depthFormat<span class="token punctuation">,</span>            <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ANativeWindow<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token keyword">return</span> surface<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从上面代码可以看出，其实就是new了一个egl_window_surface_v2_t，它内部封装了一个ANativeWindow，由于EGLSurface是一个Void* 类型指针，因此egl_window_surface_v2_t型指针可以直接赋值给它，到这里初始化环境结束，OpenGL需要的渲染环境已经搭建完毕，等到View需要显示或者更新的时候，就会接着调用VieWrootImpl的draw去更新，注意这里，一个Render线程，默认一个EglContext，但是可以有多个EglSurface，用eglMakeCurrent切换绑定即可。也就是一个Window对应一个ViewRootImpl-&gt;一个AttachInfo-&gt;ThreadRender对象-&gt;ThreadProxy(RootRenderNode)-&gt;CanvasContext.cpp(DrawFrameTask、EglManager（<strong>单例复用</strong>）、EglSurface)-&gt;-&gt;RenderThread(<strong>单例复用</strong>)，对于APP而言，一般只会维持一个OpenGL渲染线程，当然，你也可以自己new一个独立的渲染线程，主动调用OpenGL API。简答类图如下</p><p><img src="https:////upload-images.jianshu.io/upload_images/1460468-6c1252ee03d0ef62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p><p>上面工作结束后，OpenGL渲染环境就已经准备好，或者说RenderThread这个渲染线程已经配置好了渲染环境，接下来，UI线程像渲染线程发送渲染任务就行了。</p><h3 id="Android-OpenGL-GPU-渲染"><a href="#Android-OpenGL-GPU-渲染" class="headerlink" title="Android OpenGL GPU 渲染"></a>Android OpenGL GPU 渲染</h3><p>之前分析<a href="https://www.jianshu.com/p/40f660e17a73" target="_blank" rel="noopener">理解Android硬件加速的小白文</a>的时候，已经分析过，ViewRootImpl的draw是入口，会调用HardwareRender的draw，先构建DrawOp树，然后合并优化DrawOp，之后issue OpenGL命令到GPU，其中构建DrawOp的任务在UI线程，后面的任务都在Render线程</p><pre class=" language-xml"><code class="language-xml">@Overridevoid draw(View view, AttachInfo attachInfo, HardwareDrawCallbacks callbacks) {   <span class="token comment" spellcheck="true">&lt;!--构建DrawOp Tree UI线程--></span>           updateRootDisplayList(view, callbacks);   <span class="token comment" spellcheck="true">&lt;!--渲染 提交任务到render线程--></span>    int syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);    ...}</code></pre><p>如上面代码所说updateRootDisplayList构建DrawOp树在UI线程，nSyncAndDrawFrame提交渲染任务到渲染线程，之前已经分析过构建流程，nSyncAndDrawFrame也简单分析了一些合并等操作，下面接着之前流程分析如何将OpenGL命令issue到GPU，这里有个同步问题，可能牵扯到UI线程的阻塞，先分析下同步</p><h4 id="SyncAndDrawFrame-同步"><a href="#SyncAndDrawFrame-同步" class="headerlink" title="SyncAndDrawFrame 同步"></a>SyncAndDrawFrame 同步</h4><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">static</span> int <span class="token function">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="token punctuation">(</span>JNIEnv<span class="token operator">*</span> env<span class="token punctuation">,</span> jobject clazz<span class="token punctuation">,</span>        jlong proxyPtr<span class="token punctuation">,</span> jlongArray frameInfo<span class="token punctuation">,</span> jint frameInfoSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    RenderProxy<span class="token operator">*</span> proxy <span class="token operator">=</span> reinterpret_cast<span class="token operator">&lt;</span>RenderProxy<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>proxyPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>    env<span class="token operator">-</span><span class="token operator">></span><span class="token function">GetLongArrayRegion</span><span class="token punctuation">(</span>frameInfo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> frameInfoSize<span class="token punctuation">,</span> proxy<span class="token operator">-</span><span class="token operator">></span><span class="token function">frameInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> proxy<span class="token operator">-</span><span class="token operator">></span><span class="token function">syncAndDrawFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>int DrawFrameTask<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">drawFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mSyncResult <span class="token operator">=</span> kSync_OK<span class="token punctuation">;</span>    mSyncQueued <span class="token operator">=</span> <span class="token function">systemTime</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">postAndWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> mSyncResult<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> DrawFrameTask<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">postAndWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    AutoMutex <span class="token function">_lock</span><span class="token punctuation">(</span>mLock<span class="token punctuation">)</span><span class="token punctuation">;</span>    mRenderThread<span class="token operator">-</span><span class="token operator">></span><span class="token function">queue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>阻塞等待，同步资源<span class="token operator">--</span><span class="token operator">></span>    mSignal<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>mLock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> DrawFrameTask<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    bool canUnblockUiThread<span class="token punctuation">;</span>    bool canDrawThisFrame<span class="token punctuation">;</span>    <span class="token punctuation">{</span>        TreeInfo <span class="token function">info</span><span class="token punctuation">(</span>TreeInfo<span class="token punctuation">:</span><span class="token punctuation">:</span>MODE_FULL<span class="token punctuation">,</span> mRenderThread<span class="token operator">-</span><span class="token operator">></span><span class="token function">renderState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>同步操作，其实就是同步Java跟native中的构建DrawOp Tree、图层、图像资源<span class="token operator">--</span><span class="token operator">></span>        canUnblockUiThread <span class="token operator">=</span> <span class="token function">syncFrameState</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>        canDrawThisFrame <span class="token operator">=</span> info<span class="token punctuation">.</span>out<span class="token punctuation">.</span>canDrawThisFrame<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Grab a copy of everything we need</span>    CanvasContext<span class="token operator">*</span> context <span class="token operator">=</span> mContext<span class="token punctuation">;</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>如果同步完成，则可以返回<span class="token operator">--</span><span class="token operator">></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>canUnblockUiThread<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">unblockUiThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>绘制，提交OpenGL命令道GPU<span class="token operator">--</span><span class="token operator">></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">CC_LIKELY</span><span class="token punctuation">(</span>canDrawThisFrame<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        context<span class="token operator">-</span><span class="token operator">></span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>看看是否之前因为同步问题阻塞了UI线程，如果阻塞了，需要唤醒<span class="token operator">--</span><span class="token operator">></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>canUnblockUiThread<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">unblockUiThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实就是调用RenderProxy的syncAndDrawFrame，将DrawFrameTask插入RenderThread，并且阻塞等待RenderThread跟UI线程同步，如果同步成功，则UI线程唤醒，否则UI线程阻塞等待直到Render线程完成OpenGL命令的issue完毕。同步结束后，之后RenderThread才会开始处理GPU渲染相关工作，先看下同步：</p><pre class=" language-xml"><code class="language-xml">bool DrawFrameTask::syncFrameState(TreeInfo&amp; info) {    int64_t vsync = mFrameInfo[static_cast<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>int</span><span class="token punctuation">></span></span>(FrameInfoIndex::Vsync)];    mRenderThread->timeLord().vsyncReceived(vsync);    mContext->makeCurrent();    Caches::getInstance().textureCache.resetMarkInUse(mContext);    <span class="token comment" spellcheck="true">&lt;!--关键点1，TextureView类处理，主要牵扯纹理--></span>    for (size_t i = 0; i &lt; mLayers.size(); i++) {        // 更新Layer 这里牵扯到图层数据的处理，可能还有拷贝，        mContext->processLayerUpdate(mLayers[i].get());    }    mLayers.clear();    <span class="token comment" spellcheck="true">&lt;!--关键点2 同步DrawOp Tree --></span>    mContext->prepareTree(info, mFrameInfo, mSyncQueued);     ...    // If prepareTextures is false, we ran out of texture cache space    return info.prepareTextures;}</code></pre><p>当Window中的TextureView（目前只考虑系统API，好像就这么一个View，自定义除外）有更新时，需要从TextureView的SurfaceTexture中读取图形缓冲区，并且封装绑定成Open GL纹理，供GPU绘制使用，这里不详述，将来有机会分析TexutureView的时候再分析。第二步，是将UI线程中构建的DrawOpTree等信息同步到Render Thread中，因为之前通过ViewRootImpl再Java层调用构建的DisplayListData还没被真正赋值到RenderNode的mDisplayListData（最终用到的对象），只是被setStagingDisplayList暂存，因为中间可能有那种多次meausre、layout的，还有可能发生改变，暂存逻辑如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">android_view_RenderNode_setDisplayListData</span><span class="token punctuation">(</span>JNIEnv<span class="token operator">*</span> env<span class="token punctuation">,</span>        jobject clazz<span class="token punctuation">,</span> jlong renderNodePtr<span class="token punctuation">,</span> jlong newDataPtr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    RenderNode<span class="token operator">*</span> renderNode <span class="token operator">=</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>RenderNode<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>renderNodePtr<span class="token punctuation">)</span><span class="token punctuation">;</span>    DisplayListData<span class="token operator">*</span> newData <span class="token operator">=</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>DisplayListData<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>newDataPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>    renderNode<span class="token operator">-</span><span class="token operator">></span><span class="token function">setStagingDisplayList</span><span class="token punctuation">(</span>newData<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> RenderNode<span class="token operator">::</span><span class="token function">setStagingDisplayList</span><span class="token punctuation">(</span>DisplayListData<span class="token operator">*</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    mNeedsDisplayListDataSync <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> mStagingDisplayListData<span class="token punctuation">;</span>    mStagingDisplayListData <span class="token operator">=</span> data<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>View的DrawOpTree同步</p><pre class=" language-xml"><code class="language-xml">void CanvasContext::prepareTree(TreeInfo&amp; info, int64_t* uiFrameInfo, int64_t syncQueued) {    mRenderThread.removeFrameCallback(this);    if (!wasSkipped(mCurrentFrameInfo)) {        mCurrentFrameInfo = &amp;mFrames.next();    }    <span class="token comment" spellcheck="true">&lt;!--同步Java层测绘信息到native，OpenGL玄学曲线的来源--></span>    mCurrentFrameInfo->importUiThreadInfo(uiFrameInfo);    mCurrentFrameInfo->set(FrameInfoIndex::SyncQueued) = syncQueued;    <span class="token comment" spellcheck="true">&lt;!--一个计时节点--></span>    mCurrentFrameInfo->markSyncStart();        info.damageAccumulator = &amp;mDamageAccumulator;    info.renderer = mCanvas;    info.canvasContext = this;    mAnimationContext->startFrame(info.mode);    // mRootRenderNode递归遍历所有节点    mRootRenderNode->prepareTree(info);  ...</code></pre><p>通过递归遍历，mRootRenderNode可以检查所有的节点，</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">void</span> RenderNode<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">prepareTree</span><span class="token punctuation">(</span>TreeInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span> <span class="token punctuation">{</span>    bool functorsNeedLayer <span class="token operator">=</span> Properties<span class="token punctuation">:</span><span class="token punctuation">:</span>debugOverdraw<span class="token punctuation">;</span>    <span class="token function">prepareTreeImpl</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> functorsNeedLayer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> RenderNode<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">prepareTreeImpl</span><span class="token punctuation">(</span>TreeInfo<span class="token operator">&amp;</span> info<span class="token punctuation">,</span> bool functorsNeedLayer<span class="token punctuation">)</span> <span class="token punctuation">{</span>    info<span class="token punctuation">.</span>damageAccumulator<span class="token operator">-</span><span class="token operator">></span><span class="token function">pushTransform</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>info<span class="token punctuation">.</span>mode <span class="token operator">==</span> TreeInfo<span class="token punctuation">:</span><span class="token punctuation">:</span>MODE_FULL<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 同步属性 </span>        <span class="token function">pushStagingPropertiesChanges</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// layer</span>    <span class="token function">prepareLayer</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> animatorDirtyMask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>同步DrawOpTree<span class="token operator">--</span><span class="token operator">></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>info<span class="token punctuation">.</span>mode <span class="token operator">==</span> TreeInfo<span class="token punctuation">:</span><span class="token punctuation">:</span>MODE_FULL<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pushStagingDisplayListChanges</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>递归处理子View<span class="token operator">--</span><span class="token operator">></span>    <span class="token function">prepareSubTree</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> childFunctorsNeedLayer<span class="token punctuation">,</span> mDisplayListData<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// push</span>    <span class="token function">pushLayerUpdate</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>    info<span class="token punctuation">.</span>damageAccumulator<span class="token operator">-</span><span class="token operator">></span><span class="token function">popTransform</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>到这里同步的时候，基本就是最终结果，只要把mStagingDisplayListData赋值到mDisplayListData即可，</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> RenderNode<span class="token operator">::</span><span class="token function">pushStagingDisplayListChanges</span><span class="token punctuation">(</span>TreeInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mNeedsDisplayListDataSync<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mNeedsDisplayListDataSync <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        mDisplayListData <span class="token operator">=</span> mStagingDisplayListData<span class="token punctuation">;</span>        mStagingDisplayListData <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mDisplayListData<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mDisplayListData<span class="token operator">-</span><span class="token operator">></span>functors<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token operator">*</span>mDisplayListData<span class="token operator">-</span><span class="token operator">></span>functors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DrawGlInfo<span class="token operator">::</span>kModeSync<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">damageSelf</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>之后通过递归遍历子View，便能够完成完成所有View的RenderNode的同步。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">void</span> RenderNode<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">prepareSubTree</span><span class="token punctuation">(</span>TreeInfo<span class="token operator">&amp;</span> info<span class="token punctuation">,</span> bool functorsNeedLayer<span class="token punctuation">,</span> DisplayListData<span class="token operator">*</span> subtree<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>subtree<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TextureCache<span class="token operator">&amp;</span> cache <span class="token operator">=</span> Caches<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>textureCache<span class="token punctuation">;</span>        info<span class="token punctuation">.</span>out<span class="token punctuation">.</span>hasFunctors <span class="token operator">|</span><span class="token operator">=</span> subtree<span class="token operator">-</span><span class="token operator">></span>functors<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>吧RenderNode用到的bitmap封装成纹理<span class="token operator">--</span><span class="token operator">></span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> info<span class="token punctuation">.</span>prepareTextures <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> subtree<span class="token operator">-</span><span class="token operator">></span>bitmapResources<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            info<span class="token punctuation">.</span>prepareTextures <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">prefetchAndMarkInUse</span><span class="token punctuation">(</span>                    info<span class="token punctuation">.</span>canvasContext<span class="token punctuation">,</span> subtree<span class="token operator">-</span><span class="token operator">></span>bitmapResources<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>递归子View<span class="token operator">--</span><span class="token operator">></span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> subtree<span class="token operator">-</span><span class="token operator">></span><span class="token function">children</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">...</span>            childNode<span class="token operator">-</span><span class="token operator">></span><span class="token function">prepareTreeImpl</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> childFunctorsNeedLayer<span class="token punctuation">)</span><span class="token punctuation">;</span>            info<span class="token punctuation">.</span>damageAccumulator<span class="token operator">-</span><span class="token operator">></span><span class="token function">popTransform</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当DrawFrameTask::syncFrameState返回值(其实是TreeInfo的prepareTextures,这里主要是针对Bitmap的处理)为true时，表示同步完成，可以立刻唤醒UI线程，但是如果返回false，则就意UI中的数据没完全传输给GPU，这个情况下UI线程需要等待， 源码中有句注释 <strong>If prepareTextures is false, we ran out of texture cache space</strong>，其实就是说一个应用程序进程可以创建的Open GL纹理是有大小限制的，如果超出这个限制，纹理就会同步失败，看6.0代码，这个限制有Bitmap自身大小的限制，还有整体可用内存的限制，看代码中的限制</p><pre class=" language-php"><code class="language-php">Texture<span class="token operator">*</span> TextureCache<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getCachedTexture</span><span class="token punctuation">(</span><span class="token keyword">const</span> SkBitmap<span class="token operator">*</span> bitmap<span class="token punctuation">,</span> AtlasUsageType atlasUsageType<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">CC_LIKELY</span><span class="token punctuation">(</span>mAssetAtlas <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> atlasUsageType <span class="token operator">==</span> AtlasUsageType<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">Use</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AssetAtlas<span class="token punctuation">:</span><span class="token punctuation">:</span>Entry<span class="token operator">*</span> entry <span class="token operator">=</span> mAssetAtlas<span class="token operator">-</span><span class="token operator">></span><span class="token function">getEntry</span><span class="token punctuation">(</span>bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">CC_UNLIKELY</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> entry<span class="token operator">-</span><span class="token operator">></span><span class="token property">texture</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    Texture<span class="token operator">*</span> texture <span class="token operator">=</span> mCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">pixelRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getStableID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 没找到情况下</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>texture<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断单个限制</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">canMakeTextureFromBitmap</span><span class="token punctuation">(</span>bitmap<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">const</span> uint32_t size <span class="token operator">=</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">rowBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//</span>        bool canCache <span class="token operator">=</span> size <span class="token operator">&lt;</span> mMaxSize<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Don't even try to cache a bitmap that's bigger than the cache</span>        <span class="token comment" spellcheck="true">// 剔除Lru算法中老的，不再用的，如果能够挪出空间，那就算成功，否则失败</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>canCache <span class="token operator">&amp;&amp;</span> mSize <span class="token operator">+</span> size <span class="token operator">></span> mMaxSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Texture<span class="token operator">*</span> oldest <span class="token operator">=</span> mCache<span class="token punctuation">.</span><span class="token function">peekOldestValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldest <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>oldest<span class="token operator">-</span><span class="token operator">></span><span class="token property">isInUse</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                mCache<span class="token punctuation">.</span><span class="token function">removeOldest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                canCache <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果能缓存，就新建一个Texture</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>canCache<span class="token punctuation">)</span> <span class="token punctuation">{</span>            texture <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Texture</span><span class="token punctuation">(</span>Caches<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            texture<span class="token operator">-</span><span class="token operator">></span><span class="token property">bitmapSize</span> <span class="token operator">=</span> size<span class="token punctuation">;</span>            <span class="token function">generateTexture</span><span class="token punctuation">(</span>bitmap<span class="token punctuation">,</span> texture<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mSize <span class="token operator">+</span><span class="token operator">=</span> size<span class="token punctuation">;</span>            <span class="token function">TEXTURE_LOGD</span><span class="token punctuation">(</span><span class="token string">"TextureCache::get: create texture(%p): name, size, mSize = %d, %d, %d"</span><span class="token punctuation">,</span>                     bitmap<span class="token punctuation">,</span> texture<span class="token operator">-</span><span class="token operator">></span><span class="token property">id</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> mSize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mDebugEnabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">ALOGD</span><span class="token punctuation">(</span><span class="token string">"Texture created, size = %d"</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            mCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">pixelRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getStableID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> texture<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>texture<span class="token operator">-</span><span class="token operator">></span><span class="token property">isInUse</span> <span class="token operator">&amp;&amp;</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">getGenerationID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> texture<span class="token operator">-</span><span class="token operator">></span><span class="token property">generation</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Texture was in the cache but is dirty, re-upload</span>        <span class="token comment" spellcheck="true">// TODO: Re-adjust the cache size if the bitmap's dimensions have changed</span>        <span class="token function">generateTexture</span><span class="token punctuation">(</span>bitmap<span class="token punctuation">,</span> texture<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> texture<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>先看单个Bitmap限制：</p><pre class=" language-rust"><code class="language-rust">bool TextureCache<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">canMakeTextureFromBitmap</span><span class="token punctuation">(</span><span class="token keyword">const</span> SkBitmap<span class="token operator">*</span> bitmap<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>bitmap<span class="token punctuation">-></span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> mMaxTextureSize <span class="token operator">||</span> bitmap<span class="token punctuation">-></span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> mMaxTextureSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">ALOGW</span><span class="token punctuation">(</span><span class="token string">"Bitmap too large to be uploaded into a texture (%dx%d, max=%dx%d)"</span><span class="token punctuation">,</span>            bitmap<span class="token punctuation">-></span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bitmap<span class="token punctuation">-></span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mMaxTextureSize<span class="token punctuation">,</span> mMaxTextureSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>单个Bitmap大小限制基本上定义：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> GL_MAX_TEXTURE_SIZE               0x0D33</span></code></pre><p>如果bitmap的宽高超过这个值，可能就会同步失败，再看第二个原因：超过能够Cache纹理总和上限：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> DEFAULT_TEXTURE_CACHE_SIZE 24.0f 这里是24M</span></code></pre><p>如果空间足够，则直接新建一个Texture，如果不够，则根据Lru算法 ，剔除老的不再使用的Textrue，剔除后的空间如果够，则新建Texture，否则按失败处理，这里虽然说得是GPU Cache，其实还是在同一个内存中，<strong>归CPU管理的</strong>，<strong>不过由于对GPU不是太了解，不知道这个数值是不是跟GPU有关系</strong>，纹理在需要新建的前提下：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">void</span> TextureCache<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">generateTexture</span><span class="token punctuation">(</span><span class="token keyword">const</span> SkBitmap<span class="token operator">*</span> bitmap<span class="token punctuation">,</span> Texture<span class="token operator">*</span> texture<span class="token punctuation">,</span> bool regenerate<span class="token punctuation">)</span> <span class="token punctuation">{</span>    SkAutoLockPixels <span class="token function">alp</span><span class="token punctuation">(</span><span class="token operator">*</span>bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>glGenTextures新建纹理<span class="token operator">--</span><span class="token operator">></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>regenerate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>texture<span class="token operator">-</span><span class="token operator">></span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    texture<span class="token operator">-</span><span class="token operator">></span>generation <span class="token operator">=</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">getGenerationID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    texture<span class="token operator">-</span><span class="token operator">></span>width <span class="token operator">=</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    texture<span class="token operator">-</span><span class="token operator">></span>height <span class="token operator">=</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>绑定纹理<span class="token operator">--</span><span class="token operator">></span>    Caches<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">textureState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bindTexture</span><span class="token punctuation">(</span>texture<span class="token operator">-</span><span class="token operator">></span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">colorType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>    <span class="token keyword">case</span> kN32_SkColorType<span class="token punctuation">:</span>     <span class="token comment" spellcheck="true">// 32位 RGBA 或者BGREA resize第一次都是true，因为一开始宽高肯定不一致</span>        <span class="token function">uploadToTexture</span><span class="token punctuation">(</span>resize<span class="token punctuation">,</span> GL_RGBA<span class="token punctuation">,</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">rowBytesAsPixels</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">bytesPerPixel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                texture<span class="token operator">-</span><span class="token operator">></span>width<span class="token punctuation">,</span> texture<span class="token operator">-</span><span class="token operator">></span>height<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> bitmap<span class="token operator">-</span><span class="token operator">></span><span class="token function">getPixels</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">...</span><span class="token punctuation">}</span></code></pre><p>上面代码主要是新建纹理，然后为纹理绑定纹理图片资源，绑定资源代码如下：</p><pre class=" language-go"><code class="language-go">void TextureCache<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">uploadToTexture</span><span class="token punctuation">(</span><span class="token builtin">bool</span> resize<span class="token punctuation">,</span> GLenum format<span class="token punctuation">,</span> GLsizei stride<span class="token punctuation">,</span> GLsizei bpp<span class="token punctuation">,</span>        GLsizei width<span class="token punctuation">,</span> GLsizei height<span class="token punctuation">,</span> GLenum <span class="token keyword">type</span><span class="token punctuation">,</span> <span class="token keyword">const</span> GLvoid <span class="token operator">*</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glPixelStorei</span><span class="token punctuation">(</span>GL_UNPACK_ALIGNMENT<span class="token punctuation">,</span> bpp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token builtin">bool</span> useStride <span class="token operator">=</span> stride <span class="token operator">!=</span> width            <span class="token operator">&amp;&amp;</span> Caches<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">extensions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasUnpackRowLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">...</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>resize<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> format<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> format<span class="token punctuation">,</span> <span class="token keyword">type</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">glTexSubImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> format<span class="token punctuation">,</span> <span class="token keyword">type</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p><strong>关键就是调用glTexImage2D将纹理图片跟纹理绑定，OpenGL的glTexImage2D一般会再次拷贝一次图片，之后，Bitmap就可以释放了，到这里就完成了纹理的上传这部分成功了，就算同步成功，UI线程可以不再阻塞</strong>。那么为什么同步失败的时候，CPU需要等待呢？我是这么理解的：如果说正常缓存了，调用glTexImage2D完成了一次数据的转移与备份，那么UI线程就不需要维持这份Bitmap对应的数据了，但是如果失败，没有为GPU生成备份，那就要保留这份数据，直到调用glTexImage2D为其生成备份。那为什么不把缓存调整很大呢？可能是在内存跟性能之间做的一个平衡，如果很大，可能同一时刻为GPU缓存的Bitmap太大，但是这个时候，GPU并没有用的到，可能是GPU太忙，来不及处理，那么这部分内存其实是浪费掉的，而且，这个时候CPU明显比GPU快了很多，可以适当让CPU等等，有的解析说防止Bitmap被修改，说实话，我也没太明白，只是个人理解，<strong>欢迎纠正</strong>，不过这里就算缓存失败，在issue提交OpenGL命令的时候，还是会再次upload Bitmap的，这大概也是UI阻塞的原因，这个时段对应的耗时如下：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1460468-73ba03209982131b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>OpenGL CPU跟GPU关系玄学曲线.jpg</p><h4 id="Render线程issue提交OpenGL渲染命令"><a href="#Render线程issue提交OpenGL渲染命令" class="headerlink" title="Render线程issue提交OpenGL渲染命令"></a>Render线程issue提交OpenGL渲染命令</h4><p>同步完成后，就可以处理之前的DrawOpTree，装换成标准的OpenGL API，提交OpenGL进行渲染，继续看DrawFrameTask的后半部分，主要是调用CanvasContext的draw，递归之前的DrawOpTree</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">void</span> CanvasContext<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    EGLint width<span class="token punctuation">,</span> height<span class="token punctuation">;</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>开始绘制，绑定EglSurface， 申请EglSurface需要的内存<span class="token operator">--</span><span class="token operator">></span>    mEglManager<span class="token punctuation">.</span><span class="token function">beginFrame</span><span class="token punctuation">(</span>mEglSurface<span class="token punctuation">,</span> <span class="token operator">&amp;</span>width<span class="token punctuation">,</span> <span class="token operator">&amp;</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">...</span>    Rect outBounds<span class="token punctuation">;</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>递归调用OpenGLRender中的OpenGL API，绘制<span class="token operator">--</span><span class="token operator">></span>    mCanvas<span class="token operator">-</span><span class="token operator">></span><span class="token function">drawRenderNode</span><span class="token punctuation">(</span>mRootRenderNode<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> outBounds<span class="token punctuation">)</span><span class="token punctuation">;</span>    bool drew <span class="token operator">=</span> mCanvas<span class="token operator">-</span><span class="token operator">></span><span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Even if we decided to cancel the frame, from the perspective of jank</span>    <span class="token comment" spellcheck="true">// metrics the frame was swapped at this point</span>    mCurrentFrameInfo<span class="token operator">-</span><span class="token operator">></span><span class="token function">markSwapBuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>通知提交画布<span class="token operator">--</span><span class="token operator">></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>drew<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swapBuffers</span><span class="token punctuation">(</span>dirty<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token operator">...</span><span class="token punctuation">}</span></code></pre><ul><li>第一步：mEglManager.beginFrame，其实是标记当前上下文，并且申请绘制内存，因为一个进程中可能存在多个window，也就是多个EglSurface，那么我们首先需要标记处理哪个，也就是用哪块画布绘画。之前<a href="https://www.jianshu.com/p/40f660e17a73" target="_blank" rel="noopener">理解Android硬件加速的小白文</a>说过，硬件加速场景会提前在SurfaceFlinger申请内存坑位，但是并未真正申请内存，这块内存是在真正绘制的时候才去申请，这里申请的内存是让GPU操作的内存，也是将来用来提交给SurfaceFlinger用来合成用的Layer数据；</li><li>第二步：递归issue OpenGL命令，提交给GPU绘制；</li><li>第三步：通过swapBuffers将绘制好的数据提交给SF去合成（<strong>其实GPU很可能并未完成渲染，但是可以提前释放Render线程，这里需要Fence机制保证同步</strong>）。不同的GPU实现不同，厂商不会将这部分开源，本文结合Android源码（软件实现的OpenGL）跟真机Systrace猜测实现。</li></ul><p>先看第一步，通过EglManager让Context绑定当前EglSurface，完成GPU绘制内存的申请</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> EglManager<span class="token operator">::</span><span class="token function">beginFrame</span><span class="token punctuation">(</span>EGLSurface surface<span class="token punctuation">,</span> EGLint<span class="token operator">*</span> width<span class="token punctuation">,</span> EGLint<span class="token operator">*</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">makeCurrent</span><span class="token punctuation">(</span>surface<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">eglBeginFrame</span><span class="token punctuation">(</span>mEglDisplay<span class="token punctuation">,</span> surface<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>makeCurrent都会向BnGraphicproducer申请一块内存，对于非自己编写的Render线程，基本都是向SurfaceFlinger申请，</p><pre class=" language-xml"><code class="language-xml">EGLBoolean eglMakeCurrent(  EGLDisplay dpy, EGLSurface draw,                            EGLSurface read, EGLContext ctx){    ogles_context_t* gl = (ogles_context_t*)ctx;    if (makeCurrent(gl) == 0) {        if (ctx) {            egl_context_t* c = egl_context_t::context(ctx);            egl_surface_t* d = (egl_surface_t*)draw;            egl_surface_t* r = (egl_surface_t*)read;            ...            if (d) {            <span class="token comment" spellcheck="true">&lt;!--牵扯到申请内存--></span>                if (d->connect() == EGL_FALSE) {                    return EGL_FALSE;                }                d->ctx = ctx;                <span class="token comment" spellcheck="true">&lt;!--绑定--></span>                d->bindDrawSurface(gl);            }           ...    return setError(EGL_BAD_ACCESS, EGL_FALSE);}</code></pre><p>如果是第一次的话，则需要调用egl_surface_t connect，其实就是调用之前创建的egl_window_surface_v2_t的connect，触发申请绘制内存：</p><pre class=" language-xml"><code class="language-xml">EGLBoolean egl_window_surface_v2_t::connect() {     // dequeue a buffer    int fenceFd = -1;    <span class="token comment" spellcheck="true">&lt;!--调用nativeWindow的dequeueBuffer申请绘制内存,获取一个Fence--></span>    if (nativeWindow->dequeueBuffer(nativeWindow, &amp;buffer,            &amp;fenceFd) != NO_ERROR) {        return setError(EGL_BAD_ALLOC, EGL_FALSE);    }    // wait for the buffer  等待申请的内存可用    sp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Fence</span><span class="token punctuation">></span></span> fence(new Fence(fenceFd));    ...    return EGL_TRUE;}</code></pre><p>上面的nativeWindow其实就是Surface:</p><pre class=" language-xml"><code class="language-xml">int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {        ...    FrameEventHistoryDelta frameTimestamps;    status_t result = mGraphicBufferProducer->dequeueBuffer(&amp;buf, &amp;fence, reqWidth, reqHeight,                                                            reqFormat, reqUsage, &amp;mBufferAge,                                                            enableFrameTimestamps ? &amp;frameTimestamps                                                                                  : nullptr);    ... 如果需要重新分配，则requestBuffer，请求分配    if ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == nullptr) {        <span class="token comment" spellcheck="true">&lt;!--请求分配--></span>        result = mGraphicBufferProducer->requestBuffer(buf, &amp;gbuf);       }    ...</code></pre><p>简单说就是先申请内存坑位，如果该坑位的内存需要重新分配，则再申请分配匿名共享内存，<strong>这里分配的内存才是EglSurface(Surface)绘制所需内存（硬件加速）</strong>，接下来就可以通知OpenGL渲染绘制了。上面流程牵扯到一个Fence机制，其实就是一种协助生产者消费者的机制，主要作用是处理GPU跟CPU的同步上，先不谈。先走完流程，CanvasContext的mCanvas其实是OpenGLRenderer，接着看OpenGLRenderer的drawRenderNode：</p><pre class=" language-xml"><code class="language-xml">void OpenGLRenderer::drawRenderNode(RenderNode* renderNode, Rect&amp; dirty, int32_t replayFlags) {    // All the usual checks and setup operations (quickReject, setupDraw, etc.)    // will be performed by the display list itself    if (renderNode &amp;&amp; renderNode->isRenderable()) {        // compute 3d ordering        <span class="token comment" spellcheck="true">&lt;!--计算Z顺序--></span>        renderNode->computeOrdering();        <span class="token comment" spellcheck="true">&lt;!--如果禁止合并Op直接绘制--></span>        if (CC_UNLIKELY(Properties::drawDeferDisabled)) {            startFrame();            ReplayStateStruct replayStruct(*this, dirty, replayFlags);            renderNode->replay(replayStruct, 0);            return;        }       ...        DeferredDisplayList deferredList(mState.currentClipRect(), avoidOverdraw);        DeferStateStruct deferStruct(deferredList, *this, replayFlags);        <span class="token comment" spellcheck="true">&lt;!--合并--></span>        renderNode->defer(deferStruct, 0);         <span class="token comment" spellcheck="true">&lt;!--处理文理图层--></span>        flushLayers();        <span class="token comment" spellcheck="true">&lt;!--设置视窗--></span>        startFrame();       <span class="token comment" spellcheck="true">&lt;!--flush，生成并提交OpenGL命令--></span>        deferredList.flush(*this, dirty);    } ...</code></pre><p>计算Z order跟合并DrawOp之前简单说过，不分析，这里只看flushLayers跟最终的issue OpenGL 命令（deferredList.flush，其实也是遍历每个DrawOp，调用自己的draw函数），flushLayers主要是处理TextureView，为了简化，先不考虑，假设不存在此类试图，那么只看flush即可，</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> DeferredDisplayList<span class="token operator">::</span><span class="token function">flush</span><span class="token punctuation">(</span>OpenGLRenderer<span class="token operator">&amp;</span> renderer<span class="token punctuation">,</span> Rect<span class="token operator">&amp;</span> dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">replayBatchList</span><span class="token punctuation">(</span>mBatches<span class="token punctuation">,</span> renderer<span class="token punctuation">,</span> dirty<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">replayBatchList</span><span class="token punctuation">(</span><span class="token keyword">const</span> Vector<span class="token operator">&lt;</span>Batch<span class="token operator">*</span><span class="token operator">></span><span class="token operator">&amp;</span> batchList<span class="token punctuation">,</span>        OpenGLRenderer<span class="token operator">&amp;</span> renderer<span class="token punctuation">,</span> Rect<span class="token operator">&amp;</span> dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> batchList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>batchList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            batchList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">replay</span><span class="token punctuation">(</span>renderer<span class="token punctuation">,</span> dirty<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="https:////upload-images.jianshu.io/upload_images/1460468-ff584edcad217367.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>DrawOp合并</p><pre class=" language-cpp"><code class="language-cpp">  <span class="token keyword">virtual</span> <span class="token keyword">void</span>  DrawBatch<span class="token operator">::</span><span class="token function">replay</span><span class="token punctuation">(</span>OpenGLRenderer<span class="token operator">&amp;</span> renderer<span class="token punctuation">,</span> Rect<span class="token operator">&amp;</span> dirty<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> override <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mOps<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            DrawOp<span class="token operator">*</span> op <span class="token operator">=</span> mOps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>op<span class="token punctuation">;</span>            <span class="token keyword">const</span> DeferredDisplayState<span class="token operator">*</span> state <span class="token operator">=</span> mOps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>            renderer<span class="token punctuation">.</span><span class="token function">restoreDisplayState</span><span class="token punctuation">(</span><span class="token operator">*</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>            op<span class="token operator">-</span><span class="token operator">></span><span class="token function">applyDraw</span><span class="token punctuation">(</span>renderer<span class="token punctuation">,</span> dirty<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>递归每个合并后的Batch，接着处理Batch中每个DrawOp，调用其replay，以DrawPointsOp画点为例：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">DrawPointsOp</span> <span class="token operator">:</span> <span class="token keyword">public</span> DrawLinesOp <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">DrawPointsOp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">float</span><span class="token operator">*</span> points<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> <span class="token keyword">const</span> SkPaint<span class="token operator">*</span> paint<span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token function">DrawLinesOp</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> count<span class="token punctuation">,</span> paint<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">applyDraw</span><span class="token punctuation">(</span>OpenGLRenderer<span class="token operator">&amp;</span> renderer<span class="token punctuation">,</span> Rect<span class="token operator">&amp;</span> dirty<span class="token punctuation">)</span> override <span class="token punctuation">{</span>        renderer<span class="token punctuation">.</span><span class="token function">drawPoints</span><span class="token punctuation">(</span>mPoints<span class="token punctuation">,</span> mCount<span class="token punctuation">,</span> mPaint<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>最终调用OpenGLrender的drawPoints</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">void</span> OpenGLRenderer<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">drawPoints</span><span class="token punctuation">(</span><span class="token keyword">const</span> float<span class="token operator">*</span> points<span class="token punctuation">,</span> int count<span class="token punctuation">,</span> <span class="token keyword">const</span> SkPaint<span class="token operator">*</span> paint<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>     count <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span><span class="token number">0x1</span><span class="token punctuation">;</span>     <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>构建VertexBuffer<span class="token operator">--</span><span class="token operator">></span>    VertexBuffer buffer<span class="token punctuation">;</span>    PathTessellator<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">tessellatePoints</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> count<span class="token punctuation">,</span> paint<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token function">currentTransform</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">...</span>        int displayFlags <span class="token operator">=</span> paint<span class="token operator">-</span><span class="token operator">></span><span class="token function">isAntiAlias</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> kVertexBuffer_Offset<span class="token punctuation">;</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>使用buffer paint绘制 <span class="token operator">--</span><span class="token operator">></span>    <span class="token function">drawVertexBuffer</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> paint<span class="token punctuation">,</span> displayFlags<span class="token punctuation">)</span><span class="token punctuation">;</span>    mDirty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> OpenGLRenderer<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">drawVertexBuffer</span><span class="token punctuation">(</span>float translateX<span class="token punctuation">,</span> float translateY<span class="token punctuation">,</span>        <span class="token keyword">const</span> VertexBuffer<span class="token operator">&amp;</span> vertexBuffer<span class="token punctuation">,</span> <span class="token keyword">const</span> SkPaint<span class="token operator">*</span> paint<span class="token punctuation">,</span> int displayFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">/</span><span class="token operator">...</span>    Glop glop<span class="token punctuation">;</span>    <span class="token function">GlopBuilder</span><span class="token punctuation">(</span>mRenderState<span class="token punctuation">,</span> mCaches<span class="token punctuation">,</span> <span class="token operator">&amp;</span>glop<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">setRoundRectClipState</span><span class="token punctuation">(</span><span class="token function">currentSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>roundRectClipState<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">setMeshVertexBuffer</span><span class="token punctuation">(</span>vertexBuffer<span class="token punctuation">,</span> shadowInterp<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">setFillPaint</span><span class="token punctuation">(</span><span class="token operator">*</span>paint<span class="token punctuation">,</span> <span class="token function">currentSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>alpha<span class="token punctuation">)</span>             <span class="token operator">...</span>            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">renderGlop</span><span class="token punctuation">(</span>glop<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> OpenGLRenderer<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">renderGlop</span><span class="token punctuation">(</span><span class="token keyword">const</span> Glop<span class="token operator">&amp;</span> glop<span class="token punctuation">,</span> GlopRenderType type<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span>mRenderState<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>glop<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">...</span></code></pre><p>Vertex是OpenGL的基础概念，drawVertexBuffer调用RenderState的render，向GPU提交绘制命令（不会立即绘制，GPU也是由缓冲区的，除非手动glFinish或者glFlush，才会即刻渲染），RenderState可以看做OpenGL状态机的抽象，render函数实现如下</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> RenderState<span class="token operator">::</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token keyword">const</span> Glop<span class="token operator">&amp;</span> glop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> Glop<span class="token operator">::</span>Mesh<span class="token operator">&amp;</span> mesh <span class="token operator">=</span> glop<span class="token punctuation">.</span>mesh<span class="token punctuation">;</span>    <span class="token keyword">const</span> Glop<span class="token operator">::</span>Mesh<span class="token operator">::</span>Vertices<span class="token operator">&amp;</span> vertices <span class="token operator">=</span> mesh<span class="token punctuation">.</span>vertices<span class="token punctuation">;</span>    <span class="token keyword">const</span> Glop<span class="token operator">::</span>Mesh<span class="token operator">::</span>Indices<span class="token operator">&amp;</span> indices <span class="token operator">=</span> mesh<span class="token punctuation">.</span>indices<span class="token punctuation">;</span>    <span class="token keyword">const</span> Glop<span class="token operator">::</span>Fill<span class="token operator">&amp;</span> fill <span class="token operator">=</span> glop<span class="token punctuation">.</span>fill<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ---------------------------------------------</span>    <span class="token comment" spellcheck="true">// ---------- Program + uniform setup ----------</span>    <span class="token comment" spellcheck="true">// ---------------------------------------------</span>    mCaches<span class="token operator">-</span><span class="token operator">></span><span class="token function">setProgram</span><span class="token punctuation">(</span>fill<span class="token punctuation">.</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fill<span class="token punctuation">.</span>colorEnabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>        fill<span class="token punctuation">.</span>program<span class="token operator">-</span><span class="token operator">></span><span class="token function">setColor</span><span class="token punctuation">(</span>fill<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    fill<span class="token punctuation">.</span>program<span class="token operator">-</span><span class="token operator">></span><span class="token function">set</span><span class="token punctuation">(</span>glop<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>ortho<span class="token punctuation">,</span>            glop<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>modelView<span class="token punctuation">,</span>            glop<span class="token punctuation">.</span>transform<span class="token punctuation">.</span><span class="token function">meshTransform</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            glop<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>transformFlags <span class="token operator">&amp;</span> TransformFlags<span class="token operator">::</span>OffsetByFudgeFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Color filter uniforms</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fill<span class="token punctuation">.</span>filterMode <span class="token operator">==</span> ProgramDescription<span class="token operator">::</span>kColorBlend<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> FloatColor<span class="token operator">&amp;</span> color <span class="token operator">=</span> fill<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>color<span class="token punctuation">;</span>        <span class="token function">glUniform4f</span><span class="token punctuation">(</span>mCaches<span class="token operator">-</span><span class="token operator">></span><span class="token function">program</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getUniform</span><span class="token punctuation">(</span><span class="token string">"colorBlend"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                color<span class="token punctuation">.</span>r<span class="token punctuation">,</span> color<span class="token punctuation">.</span>g<span class="token punctuation">,</span> color<span class="token punctuation">.</span>b<span class="token punctuation">,</span> color<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token comment" spellcheck="true">// ---------- Mesh setup ----------</span>    <span class="token comment" spellcheck="true">// vertices</span>    <span class="token keyword">const</span> <span class="token keyword">bool</span> force <span class="token operator">=</span> <span class="token function">meshState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bindMeshBufferInternal</span><span class="token punctuation">(</span>vertices<span class="token punctuation">.</span>bufferObject<span class="token punctuation">)</span>            <span class="token operator">||</span> <span class="token punctuation">(</span>vertices<span class="token punctuation">.</span>position <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">meshState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bindPositionVertexPointer</span><span class="token punctuation">(</span>force<span class="token punctuation">,</span> vertices<span class="token punctuation">.</span>position<span class="token punctuation">,</span> vertices<span class="token punctuation">.</span>stride<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// indices</span>    <span class="token function">meshState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bindIndicesBufferInternal</span><span class="token punctuation">(</span>indices<span class="token punctuation">.</span>bufferObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// ------------------------------------</span>    <span class="token comment" spellcheck="true">// ---------- GL state setup ----------</span>    <span class="token comment" spellcheck="true">// ------------------------------------</span>    <span class="token function">blend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setFactors</span><span class="token punctuation">(</span>glop<span class="token punctuation">.</span>blend<span class="token punctuation">.</span>src<span class="token punctuation">,</span> glop<span class="token punctuation">.</span>blend<span class="token punctuation">.</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ------------------------------------</span>    <span class="token comment" spellcheck="true">// ---------- Actual drawing ----------</span>    <span class="token comment" spellcheck="true">// ------------------------------------</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>indices<span class="token punctuation">.</span>bufferObject <span class="token operator">==</span> <span class="token function">meshState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQuadListIBO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Since the indexed quad list is of limited length, we loop over</span>        <span class="token comment" spellcheck="true">// the glDrawXXX method while updating the vertex pointer</span>        GLsizei elementsCount <span class="token operator">=</span> mesh<span class="token punctuation">.</span>elementCount<span class="token punctuation">;</span>        <span class="token keyword">const</span> GLbyte<span class="token operator">*</span> vertexData <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> GLbyte<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>vertices<span class="token punctuation">.</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>elementsCount <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token function">glDrawElements</span><span class="token punctuation">(</span>mesh<span class="token punctuation">.</span>primitiveMode<span class="token punctuation">,</span> drawCount<span class="token punctuation">,</span> GL_UNSIGNED_SHORT<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            elementsCount <span class="token operator">-</span><span class="token operator">=</span> drawCount<span class="token punctuation">;</span>            vertexData <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>drawCount <span class="token operator">/</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">*</span> vertices<span class="token punctuation">.</span>stride<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span>              <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>可以看到，经过一步步的设置，变换，预处理，最后都是要转换成glXXX函数，生成相应的OpenGL命令发送给GPU，通知GPU绘制，这里有两种处理方式，第一种是CPU阻塞等待GPU绘制结束后返回，再将绘制内容提交给SurfaceFlinger进行合成，第二种是CPU直接返回，然后提交给SurfaceFlinger合成，等到SurfaceFlinger合成的时候，如果还未绘制完毕，则需要阻塞等待GPU绘制完毕，软件实现的采用的是第一种，硬件实现的一般是第二种。需要注意：<strong>OpenGL绘制前各种准备包括传给GPU使用的内存都是CPU在APP的私有内存空间申请的，而GPU真正绘制到画布使用的提交给SurfaceFlinger的那块内存，是从匿名共享申请的内存，两者是不一样的</strong>，这一部分的耗时，其实就是CPU 将命令同步给GPU的耗时，在OpenGL玄学曲线中是：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1460468-e2af8168e37558d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>构建OpenGL命令.jpg</p><h4 id="Render线程swapBuffers提交图形缓冲区（加Fence机制）"><a href="#Render线程swapBuffers提交图形缓冲区（加Fence机制）" class="headerlink" title="Render线程swapBuffers提交图形缓冲区（加Fence机制）"></a>Render线程swapBuffers提交图形缓冲区（加Fence机制）</h4><p>在Android里，GraphicBuffer的同步主要借助Fence同步机制，它最大的特点是能够处理GPU、CPU、HWC间的同步。因为，GPU处理一般是异步的，当我们调用OpenGL API返回后，OpenGL命令并不是即刻被GPU执行的，而是被缓存在本地的GL命令缓冲区中，等缓冲区满的时候，才会真正通知GPU执行，而CPU可能完全不知道执行时机，除非CPU主动使用glFinish()强制刷新，阻塞等待这些命令执行完，但是，毫无疑问，这会使得CPU、GPU并行处理效率降低，至少，渲染线程是被阻塞在那里的；相对而言异步处理的效率要高一些，CPU提交命令后就返回，不等待GPU处理完，这样渲染线程被解放处理下一条消息，不过这个时候图形未被处理完毕的前提的下就被提交给SurfaceFlinger图形合成，那么SurfaceFlinger需要知道什么时候这个GraphicBuffer被GPU处理填充完毕，这个时候就是Fence机制发挥作用的地方，关于Fence不过多分析，毕竟牵扯信息也挺多，只简单画了示意图：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1460468-07cffa61dfbfffef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>Fence示意图.jpg</p><p>之前的命令被issue完毕后，CPU一般会发送最后一个命令给GPU，告诉GPU当前命令发送完毕，可以处理，GPU一般而言需要返回一个确认的指令，不过，这里并不代表执行完毕，仅仅是通知到而已，如果GPU比较忙，来不及回复通知，则CPU需要阻塞等待，CPU收到通知后，会唤起当前阻塞的Render线程，继续处理下一条消息，这个阶段是在swapBuffers中完成的，Google给的解释如下：</p><blockquote><p>Once Android finishes submitting all its display list to the GPU, the system issues one final command to tell the graphics driver that it’s done with the current frame. At this point, the driver can finally present the updated image to the screen.</p></blockquote><blockquote><p>It’s important to understand that the GPU executes work in parallel with the CPU. The Android system issues draw commands to the GPU, and then moves on to the next task. The GPU reads those draw commands from a queue and processes them.</p></blockquote><blockquote><p>In situations where the CPU issues commands faster than the GPU consumes them, the communications queue between the processors can become full. When this occurs, the CPU blocks, and waits until there is space in the queue to place the next command. This full-queue state arises often during the Swap Buffers stage, because at that point, a whole frame’s worth of commands have been submitted</p></blockquote><p>但看Android源码而言，软件实现的libagl可以看做同步的，不需要考虑Fence机制：</p><pre class=" language-php"><code class="language-php">EGLBoolean egl_window_surface_v2_t<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">swapBuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 其实就是queueBuffer，queueBuffer这里用的是-1</span>    nativeWindow<span class="token operator">-</span><span class="token operator">></span><span class="token function">queueBuffer</span><span class="token punctuation">(</span>nativeWindow<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    buffer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// dequeue a new buffer</span>    int fenceFd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里是为了什么，还是阻塞等待，难道是为了等待GPU处理完成吗？  </span>    <span class="token comment" spellcheck="true">// buffer换buffer</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nativeWindow<span class="token operator">-</span><span class="token operator">></span><span class="token function">dequeueBuffer</span><span class="token punctuation">(</span>nativeWindow<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fenceFd<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NO_ERROR</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sp<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Fence</span><span class="token punctuation">></span></span></span> <span class="token function">fence</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Fence</span><span class="token punctuation">(</span>fenceFd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// fence->wait</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fence<span class="token operator">-</span><span class="token operator">></span><span class="token function">wait</span><span class="token punctuation">(</span>Fence<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">TIMEOUT_NEVER</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nativeWindow<span class="token operator">-</span><span class="token operator">></span><span class="token function">cancelBuffer</span><span class="token punctuation">(</span>nativeWindow<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">setError</span><span class="token punctuation">(</span><span class="token constant">EGL_BAD_ALLOC</span><span class="token punctuation">,</span> <span class="token constant">EGL_FALSE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>可以看到，源码中是先将Buffer提交给SurfaceFlinger，然后再申请一个Buffer用来处理下一次请求。并且这里queueBuffer传递的Fence是-1，也就在swapbuffer的时候，软件实现的OpenGL库是不需要Fence机制的（压根不需要考虑GPU、CPU同步）。<strong>queueBuffer会触发Layer回调，并向SurfaceFlinger发送消息，请求SurfaceFlinger执行，这里是一个异步过程，不会导致阻塞</strong>，回调入口在Layer的onFrameAvailable</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Layer<span class="token operator">::</span><span class="token function">onFrameAvailable</span><span class="token punctuation">(</span><span class="token keyword">const</span> BufferItem<span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>queueBuffer后触发Layer的onFrameAvailable回调，    mFlinger<span class="token operator">-</span><span class="token operator">></span><span class="token function">signalLayerUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>而dequeueBuffer在slot上限允许的前提下，也不会阻塞，按理说，不会怎么耗时，但是就模拟器效果而言，swapBuffers好像耗时比较严重(<strong>其中下图的黄色部分就是swapBuffers耗时</strong>)，这里不太理解，因为模拟器应该是同步的，应该不会牵扯缓冲区交换时也不会隐式将命令送去GPU执行，也不会阻塞等待，为什么耗时这么多呢，模拟器的（Genymotion 6.0），不知道是不是跟Genymotion有关系：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1460468-75a85c4674621374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/561/format/webp" alt="img"></p><p>image.png</p><p>再看一下Genymotion 的Systrace：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1460468-f6088f8ab2dc18ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p><p>可以看到，Systace中的函数调用基本跟egl.cpp中基本一致，但是queue跟dequeue buffer为什么耗时这么久呢？有些不理解，希望有人能指点。而对于硬件真机，一般需要处理Fence，其egl_window_surface_v2_t::swapBuffers()应该会被重写，至少需要传递一个有效的Fence过去，</p><pre class=" language-php"><code class="language-php">    nativeWindow<span class="token operator">-</span><span class="token operator">></span><span class="token function">queueBuffer</span><span class="token punctuation">(</span>nativeWindow<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> fenceId（不应该再是<span class="token operator">-</span><span class="token number">1</span>）<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>也就是说，queueBuffer的fenceid不能再是-1了，因为需要一个有效的Fence处理GPU CPU同步，再再看下真机的Systrace（nexus5 6.0）</p><p><img src="https:////upload-images.jianshu.io/upload_images/1460468-f00b845c598e6103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>真机OpenGL渲染Systrace</p><p>可以看到真机函数的调用跟模拟器差别很大，比如dequeue、enqueue，具体可能要看各家的实现了，再看8.0的nexus6p：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1460468-98cbede7afa36a80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>nexus6p 8.0</p><p>一开始我以为，swapBuffers会在某个地方调用glFinish()或者glFlush，这个时候可能会阻塞，导致耗时增加，但是看源码说不通，因为好像也跟就不会在enqueue或者dequeue的时候直接触发，就算触发，也是异步的。一般，<strong>issue任务给驱动后，如果采用是双缓冲，在缓冲区交换操作会隐式将命令送去执行</strong>，这里猜想是不同厂商自己实现，但是看不到具体的代码，也不好确定，谁做rom的希望能指点下。 这段时间的耗时在GPU呈现曲线上如下，文档解释说是CPU等待GPU的时间，个人理解：是等待时间，但是不是等待GPU完成渲染的时间，仅仅是等待一个ACK类的信号，否则，就不存在CPU、GPU并行了：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1460468-b1f39419ace21d02.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>swapbuffer耗时.jpg</p><p>dequeueBuffer会阻塞导致耗时增加吗？应该也不会，关于swapbuffer这段时间的耗时有空再看了</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>UI线程构建OpenGL的DrawOpTree</li><li>Render线程负责DrawOpTree合并优化、数据的同步</li><li>Render线程负责将DrawOp转换成标准OpenGL命令，并isssue给GPU</li><li>Render线程通过swapbuffer通知GPU（待研究），同时完成向SurfaceFlinger画布数据的提交</li></ul><h2 id="surfaceflinger合成surface"><a href="#surfaceflinger合成surface" class="headerlink" title="surfaceflinger合成surface"></a>surfaceflinger合成surface</h2><h3 id="SurfaceFlinger合成消息"><a href="#SurfaceFlinger合成消息" class="headerlink" title="SurfaceFlinger合成消息"></a>SurfaceFlinger合成消息</h3><p>SurfaceFlinger合成图层依赖于Android的异步消息处理机制。</p><p>首先，它包含了一个MessageQueue对象（消息队列）用于处理各种异步消息，在onFirstRef()中对消息队列进行了初始化:</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//SurfaceFlinger.cpp</span>SurfaceFlinger<span class="token operator">::</span><span class="token function">onFirstRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    mEventQueue<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>分析一下MessageQueue的实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//MessageQueue.cpp</span><span class="token keyword">void</span> MessageQueue<span class="token operator">::</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">const</span> sp<span class="token operator">&lt;</span>SurfaceFlinger<span class="token operator">></span><span class="token operator">&amp;</span> flinger<span class="token punctuation">)</span><span class="token punctuation">{</span>   mFlinger <span class="token operator">=</span> flinger<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存MessageQueue的拥有者SurfaceFlinger</span>   mLooper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Looper</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建Looper对象</span>   mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建Handler对象</span><span class="token punctuation">}</span></code></pre><p>调用Handler::handleMessage()处理INVALIDATE和REFRESH消息，并将其转发给SurfaceFlinger进行处理，调用onMessageReceived():</p><pre class=" language-php"><code class="language-php">void MessageQueue<span class="token punctuation">:</span><span class="token punctuation">:</span>Handler<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">handleMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> Message<span class="token operator">&amp;</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">switch</span> <span class="token punctuation">(</span>message<span class="token punctuation">.</span>what<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">case</span> <span class="token constant">INVALIDATE</span><span class="token punctuation">:</span>           <span class="token function">android_atomic_and</span><span class="token punctuation">(</span><span class="token operator">~</span>eventMaskInvalidate<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mEventMask<span class="token punctuation">)</span><span class="token punctuation">;</span>           mQueue<span class="token punctuation">.</span>mFlinger<span class="token operator">-</span><span class="token operator">></span><span class="token function">onMessageReceived</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>what<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">break</span><span class="token punctuation">;</span>       <span class="token keyword">case</span> <span class="token constant">REFRESH</span><span class="token punctuation">:</span>           <span class="token function">android_atomic_and</span><span class="token punctuation">(</span><span class="token operator">~</span>eventMaskRefresh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mEventMask<span class="token punctuation">)</span><span class="token punctuation">;</span>           mQueue<span class="token punctuation">.</span>mFlinger<span class="token operator">-</span><span class="token operator">></span><span class="token function">onMessageReceived</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>what<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">break</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>接下来看一下SurfaceFlinger对消息的处理：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> SurfaceFlinger<span class="token operator">::</span><span class="token function">onMessageReceived</span><span class="token punctuation">(</span>int32_t what<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">ATRACE_CALL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">switch</span> <span class="token punctuation">(</span>what<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">case</span> MessageQueue<span class="token operator">::</span>INVALIDATE<span class="token operator">:</span> <span class="token punctuation">{</span>           <span class="token keyword">bool</span> refreshNeeded <span class="token operator">=</span> <span class="token function">handleMessageTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           refreshNeeded <span class="token operator">|</span><span class="token operator">=</span> <span class="token function">handleMessageInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           refreshNeeded <span class="token operator">|</span><span class="token operator">=</span> mRepaintEverything<span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>refreshNeeded<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// Signal a refresh if a transaction modified the window state,</span>               <span class="token comment" spellcheck="true">// a new buffer was latched, or if HWC has requested a full</span>               <span class="token comment" spellcheck="true">// repaint</span>               <span class="token function">signalRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">break</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">case</span> MessageQueue<span class="token operator">::</span>REFRESH<span class="token operator">:</span> <span class="token punctuation">{</span>           <span class="token function">handleMessageRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">break</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>SurfaceFlinger处理的消息分为两种：</p><p><strong>INVALIDATE消息</strong>：用于处理Layer或者display属性的变化以及Layer对应buffer的更新。</p><pre class=" language-undefined"><code class="language-undefined"> 1) Layer或者Display属性的更新通过调用handleMessageTransaction()处理; 2) buffer的更新通过调用handleMessageInvalidate()处理。</code></pre><p>REFRESH消息：表示SurfaceFlinger需要进行一次合成操作(Refresh),通过handleMessageRefresh()实现；主要有三种情况:</p><pre class=" language-dart"><code class="language-dart"> <span class="token number">1</span><span class="token punctuation">)</span> Layer属性的变化导致window state发生变化<span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">)</span> Layer有新的buffer到来<span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">)</span> HWC请求进行一次repaint。</code></pre><p>如果这三种情况之一发生，则置refreshNeeded为true，调用signalRefresh()发出MessageQueue::REFRESH消息;</p><p>当VSync信号来之前，Layer或者display属性的变化会做本地保存，只有当VSync信号到来时，SurfaceFlinger才会通过INVALIDATE和REFRESH消息来做统一的合并渲染和输出的处理工作。</p><h3 id="handleMessageTransaction"><a href="#handleMessageTransaction" class="headerlink" title="handleMessageTransaction()"></a>handleMessageTransaction()</h3><p>处理之前对屏幕和应用程序窗口的改动。因这些改动很有可能会改变图层的可见区域，进而影响脏区域的计算。</p><pre class=" language-undefined"><code class="language-undefined">主要处理以下几个方面的transaction：1）Layer属性的变化；2）Layer的增加和减少；3）Display属性的变化;4）Display的增加和减少；</code></pre><h3 id="handleMessageInvalidate"><a href="#handleMessageInvalidate" class="headerlink" title="handleMessageInvalidate()"></a>handleMessageInvalidate()</h3><p>主要调用handlePageFlip()函数。这里Page Flip是指从BufferQueue中取下一个图形缓冲区内容，就好像是“翻页”一样。该函数主要是从各Layer对应的BufferQueue中拿图形缓冲区数据，并根据内容更新脏区域（注：脏区域是需要重绘的屏幕区域。）。并且把GraphicBuffer映射为OpenGL的texture 。</p><h3 id="handleMessageRefresh"><a href="#handleMessageRefresh" class="headerlink" title="handleMessageRefresh()"></a>handleMessageRefresh()</h3><p>合并和渲染输出。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> SurfaceFlinger<span class="token operator">::</span><span class="token function">handleMessageRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">preComposition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//合成前的准备</span>    <span class="token function">rebuildLayerStacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//重建layer堆栈</span>    <span class="token function">setUpHWComposer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//hwcomposer的设定</span>    <span class="token function">doComposition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//正式的合成处理</span>    <span class="token function">postComposition</span><span class="token punctuation">(</span>refreshStartTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//合成后期的处理</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><h4 id="void-SurfaceFlinger-preComposition"><a href="#void-SurfaceFlinger-preComposition" class="headerlink" title="void SurfaceFlinger::preComposition()"></a>void SurfaceFlinger::preComposition()</h4><p>合成前准备工作。首先得到当前所有layer的集合，然后对所有的Layer调用其onPreComposition()检查是否需要ExtralInvalidate,如果需要就调用一次signalLayerUpdate(),即通过EventThread安排一次vsync。</p><h4 id="void-SurfaceFlinger-rebuildLayerStacks"><a href="#void-SurfaceFlinger-rebuildLayerStacks" class="headerlink" title="void SurfaceFlinger::rebuildLayerStacks()"></a>void SurfaceFlinger::rebuildLayerStacks()</h4><p>计算可见layer及它们的可见区域。首先每个layer都有一个layerStack来区别它属于哪个Display，系统的Display可能不止一个，所以需要逐个处理Display，根据所有layers的当前状态通过SurfaceFlinger::computeVisibleRegions方法计算各个Layer在当前display上的可见区域和脏区域等。最后把需要绘制的layer添加到layersSortedByZ中。</p><h4 id="void-SurfaceFlinger-setUpHWComposer"><a href="#void-SurfaceFlinger-setUpHWComposer" class="headerlink" title="void SurfaceFlinger::setUpHWComposer()"></a>void SurfaceFlinger::setUpHWComposer()</h4><p>为合成搭建环境。这个HWComposer并不是真正的Hal模块，而是surfaceflinger为管理HWComposer模块而设计的一个类，路径是：frameworks/native/service/surfaceflinger/displayhardware/。依次处理各个Display，构造WorkList，合成过程既可以有Hwc模块完成，也可以通过OpengGlEs来完成，具体用哪种方式是有prepare()中的compositionType来决定的。</p><h4 id="void-SurfaceFlinger-doComposition"><a href="#void-SurfaceFlinger-doComposition" class="headerlink" title="void SurfaceFlinger::doComposition()"></a>void SurfaceFlinger::doComposition()</h4><p>执行合成操作。执行openGl合成 or HWC合成。</p><h4 id="void-SurfaceFlinger-postComposition-refreshStartTime"><a href="#void-SurfaceFlinger-postComposition-refreshStartTime" class="headerlink" title="void SurfaceFlinger::postComposition(refreshStartTime)"></a>void SurfaceFlinger::postComposition(refreshStartTime)</h4><p>将图像传递到物理屏幕。</p><p>最后借用一张流程图做最后的总结：</p><p><img src="2828107-0e30a930e9023b31.webp" alt="img"></p><p>from Jeanboydev</p><p>参考：<br><a href="https://blog.csdn.net/jxt1234and2010/article/details/46057267" target="_blank" rel="noopener">https://blog.csdn.net/jxt1234and2010/article/details/46057267</a><br><a href="https://blog.csdn.net/freekiteyu/article/details/79483406" target="_blank" rel="noopener">https://blog.csdn.net/freekiteyu/article/details/79483406</a><br><a href="https://blog.csdn.net/u012878643/article/details/71104467" target="_blank" rel="noopener">https://blog.csdn.net/u012878643/article/details/71104467</a></p><h2 id="HWC消息合成通路"><a href="#HWC消息合成通路" class="headerlink" title="HWC消息合成通路"></a>HWC消息合成通路</h2><h3 id="HWC接收surface"><a href="#HWC接收surface" class="headerlink" title="HWC接收surface"></a>HWC接收surface</h3><p>[Todo]非公开内容，略</p><h3 id="HWC处理surface"><a href="#HWC处理surface" class="headerlink" title="HWC处理surface"></a>HWC处理surface</h3><p>[Todo]非公开内容，略</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> surfaceflinger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客测试</title>
      <link href="/2020/03/01/bo-ke-ce-shi/"/>
      <url>/2020/03/01/bo-ke-ce-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="博客测试"><a href="#博客测试" class="headerlink" title="博客测试"></a>博客测试</h1><blockquote><p>记录写blog过程中遇到的语法，便于查询</p></blockquote><h2 id="图片测试"><a href="#图片测试" class="headerlink" title="图片测试"></a>图片测试</h2><p><img src="Cg-4WVVoEXCIRESuAA77Pisv2KgAAEVMAK0mz0ADvtW874.jpg" alt="img"></p><p>注意，图片要放在与博客同名的文件夹中，图片路径不能包含文件夹名，为了在typora中显示图，要打开typora的“格式-&gt;图片-&gt;设置图片根目录”为博客同名文件夹，重启typora。</p><h2 id="本地链接测试"><a href="#本地链接测试" class="headerlink" title="本地链接测试"></a>本地链接测试</h2><p><a href="hello-world">hello world</a></p>  <p>这种方式可以，但是无法在typora中显示</p><h2 id="公式测试"><a href="#公式测试" class="headerlink" title="公式测试"></a>公式测试</h2><p>$$<br>a=b+c<br>$$</p><h2 id="代码块测试"><a href="#代码块测试" class="headerlink" title="代码块测试"></a>代码块测试</h2><pre class=" language-C"><code class="language-C">#include <stdio.h>#include <stdlib.h>void main(){    print("hello world\n");}</code></pre><h2 id="表格测试"><a href="#表格测试" class="headerlink" title="表格测试"></a>表格测试</h2><table><thead><tr><th>列一</th><th>列二</th><th>列三</th></tr></thead><tbody><tr><td>1</td><td>4</td><td>7</td></tr><tr><td>2</td><td>5</td><td>8</td></tr><tr><td>3</td><td>6</td><td>9</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语法测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
